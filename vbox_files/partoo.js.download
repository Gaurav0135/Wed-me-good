var Partoo;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@remix-run/router/dist/router.js":
/*!*******************************************************!*\
  !*** ./node_modules/@remix-run/router/dist/router.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbortedDeferredError: () => (/* binding */ AbortedDeferredError),
/* harmony export */   Action: () => (/* binding */ Action),
/* harmony export */   IDLE_BLOCKER: () => (/* binding */ IDLE_BLOCKER),
/* harmony export */   IDLE_FETCHER: () => (/* binding */ IDLE_FETCHER),
/* harmony export */   IDLE_NAVIGATION: () => (/* binding */ IDLE_NAVIGATION),
/* harmony export */   UNSAFE_DEFERRED_SYMBOL: () => (/* binding */ UNSAFE_DEFERRED_SYMBOL),
/* harmony export */   UNSAFE_DeferredData: () => (/* binding */ DeferredData),
/* harmony export */   UNSAFE_ErrorResponseImpl: () => (/* binding */ ErrorResponseImpl),
/* harmony export */   UNSAFE_convertRouteMatchToUiMatch: () => (/* binding */ convertRouteMatchToUiMatch),
/* harmony export */   UNSAFE_convertRoutesToDataRoutes: () => (/* binding */ convertRoutesToDataRoutes),
/* harmony export */   UNSAFE_getResolveToMatches: () => (/* binding */ getResolveToMatches),
/* harmony export */   UNSAFE_invariant: () => (/* binding */ invariant),
/* harmony export */   UNSAFE_warning: () => (/* binding */ warning),
/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),
/* harmony export */   createHashHistory: () => (/* binding */ createHashHistory),
/* harmony export */   createMemoryHistory: () => (/* binding */ createMemoryHistory),
/* harmony export */   createPath: () => (/* binding */ createPath),
/* harmony export */   createRouter: () => (/* binding */ createRouter),
/* harmony export */   createStaticHandler: () => (/* binding */ createStaticHandler),
/* harmony export */   defer: () => (/* binding */ defer),
/* harmony export */   generatePath: () => (/* binding */ generatePath),
/* harmony export */   getStaticContextFromError: () => (/* binding */ getStaticContextFromError),
/* harmony export */   getToPathname: () => (/* binding */ getToPathname),
/* harmony export */   isDeferredData: () => (/* binding */ isDeferredData),
/* harmony export */   isRouteErrorResponse: () => (/* binding */ isRouteErrorResponse),
/* harmony export */   joinPaths: () => (/* binding */ joinPaths),
/* harmony export */   json: () => (/* binding */ json),
/* harmony export */   matchPath: () => (/* binding */ matchPath),
/* harmony export */   matchRoutes: () => (/* binding */ matchRoutes),
/* harmony export */   normalizePathname: () => (/* binding */ normalizePathname),
/* harmony export */   parsePath: () => (/* binding */ parsePath),
/* harmony export */   redirect: () => (/* binding */ redirect),
/* harmony export */   redirectDocument: () => (/* binding */ redirectDocument),
/* harmony export */   resolvePath: () => (/* binding */ resolvePath),
/* harmony export */   resolveTo: () => (/* binding */ resolveTo),
/* harmony export */   stripBasename: () => (/* binding */ stripBasename)
/* harmony export */ });
/**
 * @remix-run/router v1.15.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

////////////////////////////////////////////////////////////////////////////////
//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////
/**
 * Actions represent the type of change to a location value.
 */
var Action;
(function (Action) {
  /**
   * A POP indicates a change to an arbitrary index in the history stack, such
   * as a back or forward navigation. It does not describe the direction of the
   * navigation, only that the current index changed.
   *
   * Note: This is the default action for newly created history objects.
   */
  Action["Pop"] = "POP";
  /**
   * A PUSH indicates a new entry being added to the history stack, such as when
   * a link is clicked and a new page loads. When this happens, all subsequent
   * entries in the stack are lost.
   */
  Action["Push"] = "PUSH";
  /**
   * A REPLACE indicates the entry at the current index in the history stack
   * being replaced by a new one.
   */
  Action["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
/**
 * Memory history stores the current location in memory. It is designed for use
 * in stateful non-browser environments like tests and React Native.
 */
function createMemoryHistory(options) {
  if (options === void 0) {
    options = {};
  }
  let {
    initialEntries = ["/"],
    initialIndex,
    v5Compat = false
  } = options;
  let entries; // Declare so we can access from createMemoryLocation
  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === "string" ? null : entry.state, index === 0 ? "default" : undefined));
  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);
  let action = Action.Pop;
  let listener = null;
  function clampIndex(n) {
    return Math.min(Math.max(n, 0), entries.length - 1);
  }
  function getCurrentLocation() {
    return entries[index];
  }
  function createMemoryLocation(to, state, key) {
    if (state === void 0) {
      state = null;
    }
    let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to));
    return location;
  }
  function createHref(to) {
    return typeof to === "string" ? to : createPath(to);
  }
  let history = {
    get index() {
      return index;
    },
    get action() {
      return action;
    },
    get location() {
      return getCurrentLocation();
    },
    createHref,
    createURL(to) {
      return new URL(createHref(to), "http://localhost");
    },
    encodeLocation(to) {
      let path = typeof to === "string" ? parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    },
    push(to, state) {
      action = Action.Push;
      let nextLocation = createMemoryLocation(to, state);
      index += 1;
      entries.splice(index, entries.length, nextLocation);
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 1
        });
      }
    },
    replace(to, state) {
      action = Action.Replace;
      let nextLocation = createMemoryLocation(to, state);
      entries[index] = nextLocation;
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 0
        });
      }
    },
    go(delta) {
      action = Action.Pop;
      let nextIndex = clampIndex(index + delta);
      let nextLocation = entries[nextIndex];
      index = nextIndex;
      if (listener) {
        listener({
          action,
          location: nextLocation,
          delta
        });
      }
    },
    listen(fn) {
      listener = fn;
      return () => {
        listener = null;
      };
    }
  };
  return history;
}
/**
 * Browser history stores the location in regular URLs. This is the standard for
 * most web apps, but it requires some configuration on the server to ensure you
 * serve the same app at multiple URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
 */
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window.location;
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createBrowserHref(window, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
/**
 * Hash history stores the location in window.location.hash. This makes it ideal
 * for situations where you don't want to send the location to the server for
 * some reason, either because you do cannot configure it or the URL space is
 * reserved for something else.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
 */
function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createHashLocation(window, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window.location.hash.substr(1));
    // Hash URL should always have a leading / just like window.location.pathname
    // does, so if an app ends up at a route like /#something then we add a
    // leading slash so all of our path-matching behaves the same as if it would
    // in a browser router.  This is particularly important when there exists a
    // root splat route (<Route path="*">) since that matches internally against
    // "/*" and we'd expect /#something to 404 in a hash router app.
    if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
      pathname = "/" + pathname;
    }
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createHashHref(window, to) {
    let base = window.document.querySelector("base");
    let href = "";
    if (base && base.getAttribute("href")) {
      let url = window.location.href;
      let hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);
    try {
      // Welcome to debugging history!
      //
      // This error is thrown as a convenience, so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message);
      // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
/**
 * For browser-based histories, we combine the state and key into an object
 */
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
/**
 * Creates a Location object with a unique key from the given Path
 */
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
/**
 * Creates a string URL path from the given pathname, search, and hash components.
 */
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 */
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window.history;
  let action = Action.Pop;
  let listener = null;
  let index = getIndex();
  // Index should only be null when we initialize. If not, it's because the
  // user called history.pushState or history.replaceState directly, in which
  // case we should log a warning as it will result in bugs.
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    // try...catch because iOS limits us to 100 pushState calls :/
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      // If the exception is because `state` can't be serialized, let that throw
      // outwards just like a replace call would so the dev knows the cause
      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps
      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      // They are going to lose state here, but there is no real
      // way to warn them about it since the page will refresh...
      window.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    // window.location.origin is "null" (the literal string value) in Firefox
    // under certain conditions, notably when serving from a local HTML file
    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297
    let base = window.location.origin !== "null" ? window.location.origin : window.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    // Treating this as a full URL will strip any trailing spaces so we need to
    // pre-encode them since they might be part of a matching splat param from
    // an ancestor route
    href = href.replace(/ $/, "%20");
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window, to);
    },
    createURL,
    encodeLocation(to) {
      // Encode a Location the same way window.location would
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
}
//#endregion

var ResultType;
(function (ResultType) {
  ResultType["data"] = "data";
  ResultType["deferred"] = "deferred";
  ResultType["redirect"] = "redirect";
  ResultType["error"] = "error";
})(ResultType || (ResultType = {}));
const immutableRouteKeys = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function isIndexRoute(route) {
  return route.index === true;
}
// Walk the route tree generating unique IDs where necessary, so we are working
// solely with AgnosticDataRouteObject's within the Router
function convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  if (manifest === void 0) {
    manifest = {};
  }
  return routes.map((route, index) => {
    let treePath = [...parentPath, index];
    let id = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant(!manifest[id], "Found a route id collision on id \"" + id + "\".  Route " + "id's must be globally unique within Data Router usages");
    if (isIndexRoute(route)) {
      let indexRoute = _extends({}, route, mapRouteProperties(route), {
        id
      });
      manifest[id] = indexRoute;
      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {
        id,
        children: undefined
      });
      manifest[id] = pathOrLayoutRoute;
      if (route.children) {
        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);
      }
      return pathOrLayoutRoute;
    }
  });
}
/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/utils/match-routes
 */
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    // Incoming pathnames are generally encoded from either window.location
    // or from router.navigate, but we want to match against the unencoded
    // paths in the route definitions.  Memory router locations won't be
    // encoded here but there also shouldn't be anything to decode so this
    // should be a safe operation.  This avoids needing matchRoutes to be
    // history-aware.
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(branches[i], decoded);
  }
  return matches;
}
function convertRouteMatchToUiMatch(match, loaderData) {
  let {
    route,
    pathname,
    params
  } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === undefined ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), "Absolute route path \"" + meta.relativePath + "\" nested under path " + ("\"" + parentPath + "\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    // Add the children before adding this route to the array, so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.
    if (route.children && route.children.length > 0) {
      invariant(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route.index !== true, "Index routes must not have child routes. Please remove " + ("all child routes from route path \"" + path + "\"."));
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;
    // coarse-grain check for optional params
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
/**
 * Computes all combinations of optional path segments for a given path,
 * excluding combinations that are ambiguous and of lower priority.
 *
 * For example, `/one/:two?/three/:four?/:five?` explodes to:
 * - `/one/three`
 * - `/one/:two/three`
 * - `/one/three/:four`
 * - `/one/three/:five`
 * - `/one/:two/three/:four`
 * - `/one/:two/three/:five`
 * - `/one/three/:four/:five`
 * - `/one/:two/three/:four/:five`
 */
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  // Optional path segments are denoted by a trailing `?`
  let isOptional = first.endsWith("?");
  // Compute the corresponding required segment: `foo?` -> `foo`
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    // Intepret empty string as omitting an optional segment
    // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  // All child paths with the prefix.  Do this for all children before the
  // optional version for all children, so we get consistent ordering where the
  // parent optional aspect is preferred as required.  Otherwise, we can get
  // child sections interspersed where deeper optional segments are higher than
  // parent optional segments, where for example, /:two would explode _earlier_
  // then /:one.  By always including the parent as required _for all children_
  // first, we avoid this issue
  result.push(...restExploded.map(subpath => subpath === "" ? required : [required, subpath].join("/")));
  // Then, if this is an optional value, add all child versions without
  if (isOptional) {
    result.push(...restExploded);
  }
  // for absolute paths, ensure `/` instead of empty segment
  return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first
  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
}
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = s => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ?
  // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] :
  // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match) return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
/**
 * Returns a path with params interpolated.
 *
 * @see https://reactrouter.com/utils/generate-path
 */
function generatePath(originalPath, params) {
  if (params === void 0) {
    params = {};
  }
  let path = originalPath;
  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
    warning(false, "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
    path = path.replace(/\*$/, "/*");
  }
  // ensure `/` is added at the beginning if the path is absolute
  const prefix = path.startsWith("/") ? "/" : "";
  const stringify = p => p == null ? "" : typeof p === "string" ? p : String(p);
  const segments = path.split(/\/+/).map((segment, index, array) => {
    const isLastSegment = index === array.length - 1;
    // only apply the splat if it's the last segment
    if (isLastSegment && segment === "*") {
      const star = "*";
      // Apply the splat
      return stringify(params[star]);
    }
    const keyMatch = segment.match(/^:([\w-]+)(\??)$/);
    if (keyMatch) {
      const [, key, optional] = keyMatch;
      let param = params[key];
      invariant(optional === "?" || param != null, "Missing \":" + key + "\" param");
      return stringify(param);
    }
    // Remove any optional markers from optional static segments
    return segment.replace(/\?$/g, "");
  })
  // Remove empty segments
  .filter(segment => !!segment);
  return prefix + segments.join("/");
}
/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/utils/match-path
 */
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce((memo, _ref, index) => {
    let {
      paramName,
      isOptional
    } = _ref;
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index];
    if (isOptional && !value) {
      memo[paramName] = undefined;
    } else {
      memo[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
  .replace(/^\/*/, "/") // Make sure it has a leading /
  .replace(/[\\.*+^${}|()[\]]/g, "\\$&") // Escape special regex chars
  .replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
    : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else if (end) {
    // When matching to the end, ignore trailing slashes
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    // If our path is non-empty and contains anything beyond an initial slash,
    // then we have _some_ form of path in our regex, so we should expect to
    // match only if we find the end of this path segment.  Look for an optional
    // non-captured trailing slash (to match a portion of the URL) or the end
    // of the path (if we've matched to the end).  We used to do this with a
    // word boundary but that gives false positives on routes like
    // /user-preferences since `-` counts as a word boundary.
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map(v => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(false, "The URL path \"" + value + "\" could not be decoded because it is is a " + "malformed URL segment. This is probably due to a bad percent " + ("encoding (" + error + ")."));
    return value;
  }
}
/**
 * @private
 */
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  // We want to leave trailing slash behavior in the user's control, so if they
  // specify a basename with a trailing slash, we should support it
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/utils/resolve-path
 */
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\"...\"> and the router will parse it for you.";
}
/**
 * @private
 *
 * When processing relative navigation we want to ignore ancestor routes that
 * do not contribute to the path, such that index/pathless layout routes don't
 * interfere.
 *
 * For example, when moving a route element into an index route and/or a
 * pathless layout route, relative link behavior contained within should stay
 * the same.  Both of the following examples should link back to the root:
 *
 *   <Route path="/">
 *     <Route path="accounts" element={<Link to=".."}>
 *   </Route>
 *
 *   <Route path="/">
 *     <Route path="accounts">
 *       <Route element={<AccountsLayout />}>       // <-- Does not contribute
 *         <Route index element={<Link to=".."} />  // <-- Does not contribute
 *       </Route
 *     </Route>
 *   </Route>
 */
function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
// Return the array of pathnames for the current route matches - used to
// generate the routePathnames input for resolveTo()
function getResolveToMatches(matches, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches);
  // When v7_relativeSplatPath is enabled, use the full pathname for the leaf
  // match so we include splat values for "." links.  See:
  // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329
  if (v7_relativeSplatPath) {
    return pathMatches.map((match, idx) => idx === matches.length - 1 ? match.pathname : match.pathnameBase);
  }
  return pathMatches.map(match => match.pathnameBase);
}
/**
 * @private
 */
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  // Routing is relative to the current pathname if explicitly requested.
  //
  // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    // With relative="route" (the default), each leading .. segment means
    // "go up one route" instead of "go up one URL segment".  This is a key
    // difference from how <a href> works and a major reason we call this a
    // "to" value instead of a "href".
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  // Ensure the pathname has a trailing slash if the original "to" had one
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  // Or if this was a link to the current path which has a trailing slash
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
/**
 * @private
 */
function getToPathname(to) {
  // Empty strings should be treated the same as / paths
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
}
/**
 * @private
 */
const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
/**
 * @private
 */
const normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
/**
 * @private
 */
const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
/**
 * @private
 */
const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
/**
 * This is a shortcut for creating `application/json` responses. Converts `data`
 * to JSON and sets the `Content-Type` header.
 */
const json = function json(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), _extends({}, responseInit, {
    headers
  }));
};
class AbortedDeferredError extends Error {}
class DeferredData {
  constructor(data, responseInit) {
    this.pendingKeysSet = new Set();
    this.subscribers = new Set();
    this.deferredKeys = [];
    invariant(data && typeof data === "object" && !Array.isArray(data), "defer() only accepts plain objects");
    // Set up an AbortController + Promise we can race against to exit early
    // cancellation
    let reject;
    this.abortPromise = new Promise((_, r) => reject = r);
    this.controller = new AbortController();
    let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort);
    this.controller.signal.addEventListener("abort", onAbort);
    this.data = Object.entries(data).reduce((acc, _ref2) => {
      let [key, value] = _ref2;
      return Object.assign(acc, {
        [key]: this.trackPromise(key, value)
      });
    }, {});
    if (this.done) {
      // All incoming values were resolved
      this.unlistenAbortSignal();
    }
    this.init = responseInit;
  }
  trackPromise(key, value) {
    if (!(value instanceof Promise)) {
      return value;
    }
    this.deferredKeys.push(key);
    this.pendingKeysSet.add(key);
    // We store a little wrapper promise that will be extended with
    // _data/_error props upon resolve/reject
    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, undefined, data), error => this.onSettle(promise, key, error));
    // Register rejection listeners to avoid uncaught promise rejections on
    // errors or aborted deferred values
    promise.catch(() => {});
    Object.defineProperty(promise, "_tracked", {
      get: () => true
    });
    return promise;
  }
  onSettle(promise, key, error, data) {
    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {
      this.unlistenAbortSignal();
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      return Promise.reject(error);
    }
    this.pendingKeysSet.delete(key);
    if (this.done) {
      // Nothing left to abort!
      this.unlistenAbortSignal();
    }
    // If the promise was resolved/rejected with undefined, we'll throw an error as you
    // should always resolve with a value or null
    if (error === undefined && data === undefined) {
      let undefinedError = new Error("Deferred data for key \"" + key + "\" resolved/rejected with `undefined`, " + "you must resolve/reject with a value or `null`.");
      Object.defineProperty(promise, "_error", {
        get: () => undefinedError
      });
      this.emit(false, key);
      return Promise.reject(undefinedError);
    }
    if (data === undefined) {
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      this.emit(false, key);
      return Promise.reject(error);
    }
    Object.defineProperty(promise, "_data", {
      get: () => data
    });
    this.emit(false, key);
    return data;
  }
  emit(aborted, settledKey) {
    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));
  }
  subscribe(fn) {
    this.subscribers.add(fn);
    return () => this.subscribers.delete(fn);
  }
  cancel() {
    this.controller.abort();
    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));
    this.emit(true);
  }
  async resolveData(signal) {
    let aborted = false;
    if (!this.done) {
      let onAbort = () => this.cancel();
      signal.addEventListener("abort", onAbort);
      aborted = await new Promise(resolve => {
        this.subscribe(aborted => {
          signal.removeEventListener("abort", onAbort);
          if (aborted || this.done) {
            resolve(aborted);
          }
        });
      });
    }
    return aborted;
  }
  get done() {
    return this.pendingKeysSet.size === 0;
  }
  get unwrappedData() {
    invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds");
    return Object.entries(this.data).reduce((acc, _ref3) => {
      let [key, value] = _ref3;
      return Object.assign(acc, {
        [key]: unwrapTrackedPromise(value)
      });
    }, {});
  }
  get pendingKeys() {
    return Array.from(this.pendingKeysSet);
  }
}
function isTrackedPromise(value) {
  return value instanceof Promise && value._tracked === true;
}
function unwrapTrackedPromise(value) {
  if (!isTrackedPromise(value)) {
    return value;
  }
  if (value._error) {
    throw value._error;
  }
  return value._data;
}
const defer = function defer(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  return new DeferredData(data, responseInit);
};
/**
 * A redirect response. Sets the status code and the `Location` header.
 * Defaults to "302 Found".
 */
const redirect = function redirect(url, init) {
  if (init === void 0) {
    init = 302;
  }
  let responseInit = init;
  if (typeof responseInit === "number") {
    responseInit = {
      status: responseInit
    };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }
  let headers = new Headers(responseInit.headers);
  headers.set("Location", url);
  return new Response(null, _extends({}, responseInit, {
    headers
  }));
};
/**
 * A redirect response that will force a document reload to the new location.
 * Sets the status code and the `Location` header.
 * Defaults to "302 Found".
 */
const redirectDocument = (url, init) => {
  let response = redirect(url, init);
  response.headers.set("X-Remix-Reload-Document", "true");
  return response;
};
/**
 * @private
 * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies
 *
 * We don't export the class for public use since it's an implementation
 * detail, but we export the interface above so folks can build their own
 * abstractions around instances via isRouteErrorResponse()
 */
class ErrorResponseImpl {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }
}
/**
 * Check if the given error is an ErrorResponse generated from a 4xx/5xx
 * Response thrown from an action/loader
 */
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}

const validMutationMethodsArr = ["post", "put", "patch", "delete"];
const validMutationMethods = new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
const validRequestMethods = new Set(validRequestMethodsArr);
const redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
const redirectPreserveMethodStatusCodes = new Set([307, 308]);
const IDLE_NAVIGATION = {
  state: "idle",
  location: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined,
  json: undefined,
  text: undefined
};
const IDLE_FETCHER = {
  state: "idle",
  data: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined,
  json: undefined,
  text: undefined
};
const IDLE_BLOCKER = {
  state: "unblocked",
  proceed: undefined,
  reset: undefined,
  location: undefined
};
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const defaultMapRouteProperties = route => ({
  hasErrorBoundary: Boolean(route.hasErrorBoundary)
});
const TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
//#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createRouter
////////////////////////////////////////////////////////////////////////////////
/**
 * Create a router and listen to history POP navigations
 */
function createRouter(init) {
  const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : undefined;
  const isBrowser = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
  const isServer = !isBrowser;
  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let mapRouteProperties;
  if (init.mapRouteProperties) {
    mapRouteProperties = init.mapRouteProperties;
  } else if (init.detectErrorBoundary) {
    // If they are still using the deprecated version, wrap it with the new API
    let detectErrorBoundary = init.detectErrorBoundary;
    mapRouteProperties = route => ({
      hasErrorBoundary: detectErrorBoundary(route)
    });
  } else {
    mapRouteProperties = defaultMapRouteProperties;
  }
  // Routes keyed by ID
  let manifest = {};
  // Routes in tree format for matching
  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);
  let inFlightDataRoutes;
  let basename = init.basename || "/";
  // Config driven behavior flags
  let future = _extends({
    v7_fetcherPersist: false,
    v7_normalizeFormMethod: false,
    v7_partialHydration: false,
    v7_prependBasename: false,
    v7_relativeSplatPath: false
  }, init.future);
  // Cleanup function for history
  let unlistenHistory = null;
  // Externally-provided functions to call on all state changes
  let subscribers = new Set();
  // Externally-provided object to hold scroll restoration locations during routing
  let savedScrollPositions = null;
  // Externally-provided function to get scroll restoration keys
  let getScrollRestorationKey = null;
  // Externally-provided function to get current scroll position
  let getScrollPosition = null;
  // One-time flag to control the initial hydration scroll restoration.  Because
  // we don't get the saved positions from <ScrollRestoration /> until _after_
  // the initial render, we need to manually trigger a separate updateState to
  // send along the restoreScrollPosition
  // Set to true if we have `hydrationData` since we assume we were SSR'd and that
  // SSR did the initial scroll restoration.
  let initialScrollRestored = init.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);
  let initialErrors = null;
  if (initialMatches == null) {
    // If we do not match a user-provided-route, fall back to the root
    // to allow the error boundary to take over
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    });
    let {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }
  let initialized;
  let hasLazyRoutes = initialMatches.some(m => m.route.lazy);
  let hasLoaders = initialMatches.some(m => m.route.loader);
  if (hasLazyRoutes) {
    // All initialMatches need to be loaded before we're ready.  If we have lazy
    // functions around still then we'll need to run them in initialize()
    initialized = false;
  } else if (!hasLoaders) {
    // If we've got no loaders to run, then we're good to go
    initialized = true;
  } else if (future.v7_partialHydration) {
    // If partial hydration is enabled, we're initialized so long as we were
    // provided with hydrationData for every route with a loader, and no loaders
    // were marked for explicit hydration
    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;
    let errors = init.hydrationData ? init.hydrationData.errors : null;
    let isRouteInitialized = m => {
      // No loader, nothing to initialize
      if (!m.route.loader) return true;
      // Explicitly opting-in to running on hydration
      if (m.route.loader.hydrate === true) return false;
      // Otherwise, initialized if hydrated with data or an error
      return loaderData && loaderData[m.route.id] !== undefined || errors && errors[m.route.id] !== undefined;
    };
    // If errors exist, don't consider routes below the boundary
    if (errors) {
      let idx = initialMatches.findIndex(m => errors[m.route.id] !== undefined);
      initialized = initialMatches.slice(0, idx + 1).every(isRouteInitialized);
    } else {
      initialized = initialMatches.every(isRouteInitialized);
    }
  } else {
    // Without partial hydration - we're initialized if we were provided any
    // hydrationData - which is expected to be complete
    initialized = init.hydrationData != null;
  }
  let router;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: new Map(),
    blockers: new Map()
  };
  // -- Stateful internal variables to manage navigations --
  // Current navigation in progress (to be committed in completeNavigation)
  let pendingAction = Action.Pop;
  // Should the current navigation prevent the scroll reset if scroll cannot
  // be restored?
  let pendingPreventScrollReset = false;
  // AbortController for the active navigation
  let pendingNavigationController;
  // Should the current navigation enable document.startViewTransition?
  let pendingViewTransitionEnabled = false;
  // Store applied view transitions so we can apply them on POP
  let appliedViewTransitions = new Map();
  // Cleanup function for persisting applied transitions to sessionStorage
  let removePageHideEventListener = null;
  // We use this to avoid touching history in completeNavigation if a
  // revalidation is entirely uninterrupted
  let isUninterruptedRevalidation = false;
  // Use this internal flag to force revalidation of all loaders:
  //  - submissions (completed or interrupted)
  //  - useRevalidator()
  //  - X-Remix-Revalidate (from redirect)
  let isRevalidationRequired = false;
  // Use this internal array to capture routes that require revalidation due
  // to a cancelled deferred on action submission
  let cancelledDeferredRoutes = [];
  // Use this internal array to capture fetcher loads that were cancelled by an
  // action navigation and require revalidation
  let cancelledFetcherLoads = [];
  // AbortControllers for any in-flight fetchers
  let fetchControllers = new Map();
  // Track loads based on the order in which they started
  let incrementingLoadId = 0;
  // Track the outstanding pending navigation data load to be compared against
  // the globally incrementing load when a fetcher load lands after a completed
  // navigation
  let pendingNavigationLoadId = -1;
  // Fetchers that triggered data reloads as a result of their actions
  let fetchReloadIds = new Map();
  // Fetchers that triggered redirect navigations
  let fetchRedirectIds = new Set();
  // Most recent href/match for fetcher.load calls for fetchers
  let fetchLoadMatches = new Map();
  // Ref-count mounted fetchers so we know when it's ok to clean them up
  let activeFetchers = new Map();
  // Fetchers that have requested a delete when using v7_fetcherPersist,
  // they'll be officially removed after they return to idle
  let deletedFetchers = new Set();
  // Store DeferredData instances for active route matches.  When a
  // route loader returns defer() we stick one in here.  Then, when a nested
  // promise resolves we update loaderData.  If a new navigation starts we
  // cancel active deferreds for eliminated routes.
  let activeDeferreds = new Map();
  // Store blocker functions in a separate Map outside of router state since
  // we don't need to update UI state if they change
  let blockerFunctions = new Map();
  // Flag to ignore the next history update, so we can revert the URL change on
  // a POP navigation that was blocked by the user without touching router state
  let ignoreNextHistoryUpdate = false;
  // Initialize the router, all side effects should be kicked off from here.
  // Implemented as a Fluent API for ease of:
  //   let router = createRouter(init).initialize();
  function initialize() {
    // If history informs us of a POP navigation, start the navigation but do not update
    // state.  We'll update our own state once the navigation completes
    unlistenHistory = init.history.listen(_ref => {
      let {
        action: historyAction,
        location,
        delta
      } = _ref;
      // Ignore this event if it was just us resetting the URL from a
      // blocked POP navigation
      if (ignoreNextHistoryUpdate) {
        ignoreNextHistoryUpdate = false;
        return;
      }
      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location " + "that was not created by @remix-run/router. This will fail silently in " + "production. This can happen if you are navigating outside the router " + "via `window.history.pushState`/`window.location.hash` instead of using " + "router navigation APIs.  This can also happen if you are using " + "createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        // Restore the URL to match the current UI, but don't update router state
        ignoreNextHistoryUpdate = true;
        init.history.go(delta * -1);
        // Put the blocker into a blocked state
        updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: undefined,
              reset: undefined,
              location
            });
            // Re-do the same POP navigation we just blocked
            init.history.go(delta);
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER);
            updateState({
              blockers
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    });
    if (isBrowser) {
      // FIXME: This feels gross.  How can we cleanup the lines between
      // scrollRestoration/appliedTransitions persistance?
      restoreAppliedTransitions(routerWindow, appliedViewTransitions);
      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
      routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
      removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
    }
    // Kick off initial data load if needed.  Use Pop to avoid modifying history
    // Note we don't do any handling of lazy here.  For SPA's it'll get handled
    // in the normal navigation flow.  For SSR it's expected that lazy modules are
    // resolved prior to router creation since we can't go into a fallbackElement
    // UI for SSR'd apps
    if (!state.initialized) {
      startNavigation(Action.Pop, state.location, {
        initialHydration: true
      });
    }
    return router;
  }
  // Clean up a router and it's side effects
  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    if (removePageHideEventListener) {
      removePageHideEventListener();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_, key) => deleteFetcher(key));
    state.blockers.forEach((_, key) => deleteBlocker(key));
  }
  // Subscribe to state updates for the router
  function subscribe(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  }
  // Update our state and notify the calling context of the change
  function updateState(newState, opts) {
    if (opts === void 0) {
      opts = {};
    }
    state = _extends({}, state, newState);
    // Prep fetcher cleanup so we can tell the UI which fetcher data entries
    // can be removed
    let completedFetchers = [];
    let deletedFetchersKeys = [];
    if (future.v7_fetcherPersist) {
      state.fetchers.forEach((fetcher, key) => {
        if (fetcher.state === "idle") {
          if (deletedFetchers.has(key)) {
            // Unmounted from the UI and can be totally removed
            deletedFetchersKeys.push(key);
          } else {
            // Returned to idle but still mounted in the UI, so semi-remains for
            // revalidations and such
            completedFetchers.push(key);
          }
        }
      });
    }
    // Iterate over a local copy so that if flushSync is used and we end up
    // removing and adding a new subscriber due to the useCallback dependencies,
    // we don't get ourselves into a loop calling the new subscriber immediately
    [...subscribers].forEach(subscriber => subscriber(state, {
      deletedFetchers: deletedFetchersKeys,
      unstable_viewTransitionOpts: opts.viewTransitionOpts,
      unstable_flushSync: opts.flushSync === true
    }));
    // Remove idle fetchers from state since we only care about in-flight fetchers.
    if (future.v7_fetcherPersist) {
      completedFetchers.forEach(key => state.fetchers.delete(key));
      deletedFetchersKeys.forEach(key => deleteFetcher(key));
    }
  }
  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION
  // and setting state.[historyAction/location/matches] to the new route.
  // - Location is a required param
  // - Navigation will always be set to IDLE_NAVIGATION
  // - Can pass any other state in newState
  function completeNavigation(location, newState, _temp) {
    var _location$state, _location$state2;
    let {
      flushSync
    } = _temp === void 0 ? {} : _temp;
    // Deduce if we're in a loading/actionReload state:
    // - We have committed actionData in the store
    // - The current navigation was a mutation submission
    // - We're past the submitting state and into the loading state
    // - The location being loaded is not the result of a redirect
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        // Empty actionData -> clear prior actionData due to an action error
        actionData = null;
      }
    } else if (isActionReload) {
      // Keep the current data if we're wrapping up the action reload
      actionData = state.actionData;
    } else {
      // Clear actionData on any other completed navigations
      actionData = null;
    }
    // Always preserve any existing loaderData from re-used routes
    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
    // On a successful navigation we can assume we got through all blockers
    // so we can start fresh
    let blockers = state.blockers;
    if (blockers.size > 0) {
      blockers = new Map(blockers);
      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));
    }
    // Always respect the user flag.  Otherwise don't reset on mutation
    // submission navigations unless they redirect
    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
    if (inFlightDataRoutes) {
      dataRoutes = inFlightDataRoutes;
      inFlightDataRoutes = undefined;
    }
    if (isUninterruptedRevalidation) ; else if (pendingAction === Action.Pop) ; else if (pendingAction === Action.Push) {
      init.history.push(location, location.state);
    } else if (pendingAction === Action.Replace) {
      init.history.replace(location, location.state);
    }
    let viewTransitionOpts;
    // On POP, enable transitions if they were enabled on the original navigation
    if (pendingAction === Action.Pop) {
      // Forward takes precedence so they behave like the original navigation
      let priorPaths = appliedViewTransitions.get(state.location.pathname);
      if (priorPaths && priorPaths.has(location.pathname)) {
        viewTransitionOpts = {
          currentLocation: state.location,
          nextLocation: location
        };
      } else if (appliedViewTransitions.has(location.pathname)) {
        // If we don't have a previous forward nav, assume we're popping back to
        // the new location and enable if that location previously enabled
        viewTransitionOpts = {
          currentLocation: location,
          nextLocation: state.location
        };
      }
    } else if (pendingViewTransitionEnabled) {
      // Store the applied transition on PUSH/REPLACE
      let toPaths = appliedViewTransitions.get(state.location.pathname);
      if (toPaths) {
        toPaths.add(location.pathname);
      } else {
        toPaths = new Set([location.pathname]);
        appliedViewTransitions.set(state.location.pathname, toPaths);
      }
      viewTransitionOpts = {
        currentLocation: state.location,
        nextLocation: location
      };
    }
    updateState(_extends({}, newState, {
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers
    }), {
      viewTransitionOpts,
      flushSync: flushSync === true
    });
    // Reset stateful navigation vars
    pendingAction = Action.Pop;
    pendingPreventScrollReset = false;
    pendingViewTransitionEnabled = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
    cancelledFetcherLoads = [];
  }
  // Trigger a navigation event, which can either be a numerical POP or a PUSH
  // replace with an optional submission
  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state);
    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded
    // URL from window.location, so we need to encode it here so the behavior
    // remains the same as POP and non-data-router usages.  new URL() does all
    // the same encoding we'd get from a history.pushState/window.location read
    // without having to touch history
    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : undefined;
    let historyAction = Action.Push;
    if (userReplace === true) {
      historyAction = Action.Replace;
    } else if (userReplace === false) ; else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      // By default on submissions to the current location we REPLACE so that
      // users don't have to double-click the back button to get to the prior
      // location.  If the user redirects to a different location from the
      // action/loader this will be ignored and the redirect will be a PUSH
      historyAction = Action.Replace;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : undefined;
    let flushSync = (opts && opts.unstable_flushSync) === true;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      // Put the blocker into a blocked state
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: undefined,
            reset: undefined,
            location: nextLocation
          });
          // Send the same navigation through
          navigate(to, opts);
        },
        reset() {
          let blockers = new Map(state.blockers);
          blockers.set(blockerKey, IDLE_BLOCKER);
          updateState({
            blockers
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace,
      enableViewTransition: opts && opts.unstable_viewTransition,
      flushSync
    });
  }
  // Revalidate all current loaders.  If a navigation is in progress or if this
  // is interrupted by a navigation, allow this to "succeed" by calling all
  // loaders during the next loader round
  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    });
    // If we're currently submitting an action, we don't need to start a new
    // navigation, we'll just let the follow up loader execution call all loaders
    if (state.navigation.state === "submitting") {
      return;
    }
    // If we're currently in an idle state, start a new navigation for the current
    // action/location and mark it as uninterrupted, which will skip the history
    // update in completeNavigation
    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    }
    // Otherwise, if we're currently in a loading state, just start a new
    // navigation to the navigation.location but do not trigger an uninterrupted
    // revalidation so that history correctly updates once the navigation completes
    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation
    });
  }
  // Start a navigation to the given action/location.  Can optionally provide a
  // overrideNavigation which will override the normalLoad in the case of a redirect
  // navigation
  async function startNavigation(historyAction, location, opts) {
    // Abort any in-progress navigations and start a new one. Unset any ongoing
    // uninterrupted revalidations unless told otherwise, since we want this
    // new navigation to update history normally
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
    // Save the current scroll position every time we start a new navigation,
    // and track whether we should reset scroll on completion
    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(routesToUse, location, basename);
    let flushSync = (opts && opts.flushSync) === true;
    // Short circuit with a 404 on the root error boundary if we match nothing
    if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(routesToUse);
      // Cancel all pending deferred on 404s since we don't keep any routes
      cancelActiveDeferreds();
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      }, {
        flushSync
      });
      return;
    }
    // Short circuit if it's only a hash change and not a revalidation or
    // mutation submission.
    //
    // Ignore on initial page loads because since the initial load will always
    // be "same hash".  For example, on /page#hash and submit a <Form method="post">
    // which will default to a navigation to /page
    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches
      }, {
        flushSync
      });
      return;
    }
    // Create a controller/Request for this navigation
    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionData;
    let pendingError;
    if (opts && opts.pendingError) {
      // If we have a pendingError, it means the user attempted a GET submission
      // with binary FormData so assign here and skip to handleLoaders.  That
      // way we handle calling loaders above the boundary etc.  It's not really
      // different from an actionError in that sense.
      pendingError = {
        [findNearestBoundary(matches).route.id]: opts.pendingError
      };
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      // Call action if we received an action submission
      let actionOutput = await handleAction(request, location, opts.submission, matches, {
        replace: opts.replace,
        flushSync
      });
      if (actionOutput.shortCircuited) {
        return;
      }
      pendingActionData = actionOutput.pendingActionData;
      pendingError = actionOutput.pendingActionError;
      loadingNavigation = getLoadingNavigation(location, opts.submission);
      flushSync = false;
      // Create a GET request for the loaders
      request = new Request(request.url, {
        signal: request.signal
      });
    }
    // Call loaders
    let {
      shortCircuited,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionData, pendingError);
    if (shortCircuited) {
      return;
    }
    // Clean up now that the action/loaders have completed.  Don't clean up if
    // we short circuited because pendingNavigationController will have already
    // been assigned to a new controller for the next navigation
    pendingNavigationController = null;
    completeNavigation(location, _extends({
      matches
    }, pendingActionData ? {
      actionData: pendingActionData
    } : {}, {
      loaderData,
      errors
    }));
  }
  // Call the action matched by the leaf route for this navigation and handle
  // redirects/errors
  async function handleAction(request, location, submission, matches, opts) {
    if (opts === void 0) {
      opts = {};
    }
    interruptActiveLoads();
    // Put us in a submitting state
    let navigation = getSubmittingNavigation(location, submission);
    updateState({
      navigation
    }, {
      flushSync: opts.flushSync === true
    });
    // Call our action and get the result
    let result;
    let actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let replace;
      if (opts && opts.replace != null) {
        replace = opts.replace;
      } else {
        // If the user didn't explicity indicate replace behavior, replace if
        // we redirected to the exact same location we're currently at to avoid
        // double back-buttons
        replace = result.location === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(state, result, {
        submission,
        replace
      });
      return {
        shortCircuited: true
      };
    }
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      // By default, all submissions are REPLACE navigations, but if the
      // action threw an error that'll be rendered in an errorElement, we fall
      // back to PUSH so that the user can use the back button to get back to
      // the pre-submission form location to try again
      if ((opts && opts.replace) !== true) {
        pendingAction = Action.Push;
      }
      return {
        // Send back an empty object we can use to clear out any prior actionData
        pendingActionData: {},
        pendingActionError: {
          [boundaryMatch.route.id]: result.error
        }
      };
    }
    if (isDeferredResult(result)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    return {
      pendingActionData: {
        [actionMatch.route.id]: result.data
      }
    };
  }
  // Call all applicable loaders for the given matches, handling redirects,
  // errors, etc.
  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionData, pendingError) {
    // Figure out the right navigation we want to use for data loading
    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
    // If this was a redirect from an action we don't have a "submission" but
    // we have it on the loading navigation so use that if available
    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);
    // Cancel pending deferreds for no-longer-matched routes or routes we're
    // about to reload.  Note that if this is an action reload we would have
    // already cancelled all pending deferreds so this would be a no-op
    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId));
    pendingNavigationLoadId = ++incrementingLoadId;
    // Short circuit if we have no loaders to run
    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      let updatedFetchers = markFetchRedirectsDone();
      completeNavigation(location, _extends({
        matches,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingError || null
      }, pendingActionData ? {
        actionData: pendingActionData
      } : {}, updatedFetchers ? {
        fetchers: new Map(state.fetchers)
      } : {}), {
        flushSync
      });
      return {
        shortCircuited: true
      };
    }
    // If this is an uninterrupted revalidation, we remain in our current idle
    // state.  If not, we need to switch to our loading state and load data,
    // preserving any new action data or existing action data (in the case of
    // a revalidation interrupting an actionReload)
    // If we have partialHydration enabled, then don't update the state for the
    // initial data load since it's not a "navigation"
    if (!isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration)) {
      revalidatingFetchers.forEach(rf => {
        let fetcher = state.fetchers.get(rf.key);
        let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);
        state.fetchers.set(rf.key, revalidatingFetcher);
      });
      let actionData = pendingActionData || state.actionData;
      updateState(_extends({
        navigation: loadingNavigation
      }, actionData ? Object.keys(actionData).length === 0 ? {
        actionData: null
      } : {
        actionData
      } : {}, revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}), {
        flushSync
      });
    }
    revalidatingFetchers.forEach(rf => {
      if (fetchControllers.has(rf.key)) {
        abortFetcher(rf.key);
      }
      if (rf.controller) {
        // Fetchers use an independent AbortController so that aborting a fetcher
        // (via deleteFetcher) does not abort the triggering navigation that
        // triggered the revalidation
        fetchControllers.set(rf.key, rf.controller);
      }
    });
    // Proxy navigation abort through to revalidation fetchers
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));
    if (pendingNavigationController) {
      pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    }
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    }
    // Clean up _after_ loaders have completed.  Don't clean up if we short
    // circuited because fetchControllers would have been aborted and
    // reassigned to new controllers for the next navigation
    if (pendingNavigationController) {
      pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    }
    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));
    // If any loaders returned a redirect Response, start a new REPLACE navigation
    let redirect = findRedirect(results);
    if (redirect) {
      if (redirect.idx >= matchesToLoad.length) {
        // If this redirect came from a fetcher make sure we mark it in
        // fetchRedirectIds so it doesn't get revalidated on the next set of
        // loader executions
        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
        fetchRedirectIds.add(fetcherKey);
      }
      await startRedirectNavigation(state, redirect.result, {
        replace
      });
      return {
        shortCircuited: true
      };
    }
    // Process and commit output from loaders
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);
    // Wire up subscribers to update loaderData as promises settle
    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe(aborted => {
        // Note: No need to updateState here since the TrackedPromise on
        // loaderData is stable across resolve/reject
        // Remove this instance if we were aborted or if promises have settled
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });
    // During partial hydration, preserve SSR errors for routes that don't re-run
    if (future.v7_partialHydration && initialHydration && state.errors) {
      Object.entries(state.errors).filter(_ref2 => {
        let [id] = _ref2;
        return !matchesToLoad.some(m => m.route.id === id);
      }).forEach(_ref3 => {
        let [routeId, error] = _ref3;
        errors = Object.assign(errors || {}, {
          [routeId]: error
        });
      });
    }
    let updatedFetchers = markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
    return _extends({
      loaderData,
      errors
    }, shouldUpdateFetchers ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  // Trigger a fetcher load/submit for the given fetcher key
  function fetch(key, routeId, href, opts) {
    if (isServer) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. " + "You are likely calling a useFetcher() method in the body of your component. " + "Try moving it to a useEffect or a callback.");
    }
    if (fetchControllers.has(key)) abortFetcher(key);
    let flushSync = (opts && opts.unstable_flushSync) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);
    let matches = matchRoutes(routesToUse, normalizedPath, basename);
    if (!matches) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: normalizedPath
      }), {
        flushSync
      });
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);
    if (error) {
      setFetcherError(key, routeId, error, {
        flushSync
      });
      return;
    }
    let match = getTargetMatch(matches, path);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);
      return;
    }
    // Store off the match so we can call it's shouldRevalidate on subsequent
    // revalidations
    fetchLoadMatches.set(key, {
      routeId,
      path
    });
    handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);
  }
  // Call the action for the matched fetcher.submit(), and then handle redirects,
  // errors, and revalidation
  async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    if (!match.route.action && !match.route.lazy) {
      let error = getInternalRouterError(405, {
        method: submission.formMethod,
        pathname: path,
        routeId: routeId
      });
      setFetcherError(key, routeId, error, {
        flushSync
      });
      return;
    }
    // Put this fetcher into it's submitting state
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
      flushSync
    });
    // Call the action for the fetcher
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);
    if (fetchRequest.signal.aborted) {
      // We can delete this so long as we weren't aborted by our own fetcher
      // re-submit which would have put _new_ controller is in fetchControllers
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    // When using v7_fetcherPersist, we don't want errors bubbling up to the UI
    // or redirects processed for unmounted fetchers so we just revert them to
    // idle
    if (future.v7_fetcherPersist && deletedFetchers.has(key)) {
      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
        updateFetcherState(key, getDoneFetcher(undefined));
        return;
      }
      // Let SuccessResult's fall through for revalidation
    } else {
      if (isRedirectResult(actionResult)) {
        fetchControllers.delete(key);
        if (pendingNavigationLoadId > originatingLoadId) {
          // A new navigation was kicked off after our action started, so that
          // should take precedence over this redirect navigation.  We already
          // set isRevalidationRequired so all loaders for the new route should
          // fire unless opted out via shouldRevalidate
          updateFetcherState(key, getDoneFetcher(undefined));
          return;
        } else {
          fetchRedirectIds.add(key);
          updateFetcherState(key, getLoadingFetcher(submission));
          return startRedirectNavigation(state, actionResult, {
            fetcherSubmission: submission
          });
        }
      }
      // Process any non-redirect errors thrown
      if (isErrorResult(actionResult)) {
        setFetcherError(key, routeId, actionResult.error);
        return;
      }
    }
    if (isDeferredResult(actionResult)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    // Start the data load for current matches, or the next location if we're
    // in the middle of a navigation
    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = getLoadingFetcher(submission, actionResult.data);
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, false, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, {
      [match.route.id]: actionResult.data
    }, undefined // No need to send through errors since we short circuit above
    );
    // Put all revalidating fetchers into the loading state, except for the
    // current fetcher which we want to keep in it's current loading state which
    // contains it's action submission info + action data
    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {
      let staleKey = rf.key;
      let existingFetcher = state.fetchers.get(staleKey);
      let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);
      state.fetchers.set(staleKey, revalidatingFetcher);
      if (fetchControllers.has(staleKey)) {
        abortFetcher(staleKey);
      }
      if (rf.controller) {
        fetchControllers.set(staleKey, rf.controller);
      }
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));
    abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted) {
      return;
    }
    abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));
    let redirect = findRedirect(results);
    if (redirect) {
      if (redirect.idx >= matchesToLoad.length) {
        // If this redirect came from a fetcher make sure we mark it in
        // fetchRedirectIds so it doesn't get revalidated on the next set of
        // loader executions
        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
        fetchRedirectIds.add(fetcherKey);
      }
      return startRedirectNavigation(state, redirect.result);
    }
    // Process and commit output from loaders
    let {
      loaderData,
      errors
    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);
    // Since we let revalidations complete even if the submitting fetcher was
    // deleted, only put it back to idle if it hasn't been deleted
    if (state.fetchers.has(key)) {
      let doneFetcher = getDoneFetcher(actionResult.data);
      state.fetchers.set(key, doneFetcher);
    }
    abortStaleFetchLoads(loadId);
    // If we are currently in a navigation loading state and this fetcher is
    // more recent than the navigation, we want the newer data so abort the
    // navigation and complete it with the fetcher data
    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      // otherwise just update with the fetcher data, preserving any existing
      // loaderData for loaders that did not need to reload.  We have to
      // manually merge here since we aren't going through completeNavigation
      updateState({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),
        fetchers: new Map(state.fetchers)
      });
      isRevalidationRequired = false;
    }
  }
  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.
  async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {
      flushSync
    });
    // Call the loader for this fetcher route match
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let result = await callLoaderOrAction("loader", fetchRequest, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);
    // Deferred isn't supported for fetcher loads, await everything and treat it
    // as a normal load.  resolveDeferredData will return undefined if this
    // fetcher gets aborted, so we just leave result untouched and short circuit
    // below if that happens
    if (isDeferredResult(result)) {
      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;
    }
    // We can delete this so long as we weren't aborted by our our own fetcher
    // re-load which would have put _new_ controller is in fetchControllers
    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    }
    // We don't want errors bubbling up or redirects followed for unmounted
    // fetchers, so short circuit here if it was removed from the UI
    if (deletedFetchers.has(key)) {
      updateFetcherState(key, getDoneFetcher(undefined));
      return;
    }
    // If the loader threw a redirect Response, start a new REPLACE navigation
    if (isRedirectResult(result)) {
      if (pendingNavigationLoadId > originatingLoadId) {
        // A new navigation was kicked off after our loader started, so that
        // should take precedence over this redirect navigation
        updateFetcherState(key, getDoneFetcher(undefined));
        return;
      } else {
        fetchRedirectIds.add(key);
        await startRedirectNavigation(state, result);
        return;
      }
    }
    // Process any non-redirect errors thrown
    if (isErrorResult(result)) {
      setFetcherError(key, routeId, result.error);
      return;
    }
    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");
    // Put the fetcher back into an idle state
    updateFetcherState(key, getDoneFetcher(result.data));
  }
  /**
   * Utility function to handle redirects returned from an action or loader.
   * Normally, a redirect "replaces" the navigation that triggered it.  So, for
   * example:
   *
   *  - user is on /a
   *  - user clicks a link to /b
   *  - loader for /b redirects to /c
   *
   * In a non-JS app the browser would track the in-flight navigation to /b and
   * then replace it with /c when it encountered the redirect response.  In
   * the end it would only ever update the URL bar with /c.
   *
   * In client-side routing using pushState/replaceState, we aim to emulate
   * this behavior and we also do not update history until the end of the
   * navigation (including processed redirects).  This means that we never
   * actually touch history until we've processed redirects, so we just use
   * the history action from the original navigation (PUSH or REPLACE).
   */
  async function startRedirectNavigation(state, redirect, _temp2) {
    let {
      submission,
      fetcherSubmission,
      replace
    } = _temp2 === void 0 ? {} : _temp2;
    if (redirect.revalidate) {
      isRevalidationRequired = true;
    }
    let redirectLocation = createLocation(state.location, redirect.location, {
      _isRedirect: true
    });
    invariant(redirectLocation, "Expected a location on the redirect navigation");
    if (isBrowser) {
      let isDocumentReload = false;
      if (redirect.reloadDocument) {
        // Hard reload if the response contained X-Remix-Reload-Document
        isDocumentReload = true;
      } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {
        const url = init.history.createURL(redirect.location);
        isDocumentReload =
        // Hard reload if it's an absolute URL to a new origin
        url.origin !== routerWindow.location.origin ||
        // Hard reload if it's an absolute URL that does not match our basename
        stripBasename(url.pathname, basename) == null;
      }
      if (isDocumentReload) {
        if (replace) {
          routerWindow.location.replace(redirect.location);
        } else {
          routerWindow.location.assign(redirect.location);
        }
        return;
      }
    }
    // There's no need to abort on redirects, since we don't detect the
    // redirect until the action/loaders have settled
    pendingNavigationController = null;
    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;
    // Use the incoming submission if provided, fallback on the active one in
    // state.navigation
    let {
      formMethod,
      formAction,
      formEncType
    } = state.navigation;
    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
      submission = getSubmissionFromNavigation(state.navigation);
    }
    // If this was a 307/308 submission we want to preserve the HTTP method and
    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the
    // redirected location
    let activeSubmission = submission || fetcherSubmission;
    if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends({}, activeSubmission, {
          formAction: redirect.location
        }),
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    } else {
      // If we have a navigation submission, we will preserve it through the
      // redirect navigation
      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission,
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    }
  }
  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
    // Call all navigation loaders and revalidating fetcher loaders in parallel,
    // then slice off the results into separate arrays so we can handle them
    // accordingly
    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath)), ...fetchersToLoad.map(f => {
      if (f.matches && f.match && f.controller) {
        return callLoaderOrAction("loader", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);
      } else {
        let error = {
          type: ResultType.error,
          error: getInternalRouterError(404, {
            pathname: f.path
          })
        };
        return error;
      }
    })]);
    let loaderResults = results.slice(0, matchesToLoad.length);
    let fetcherResults = results.slice(matchesToLoad.length);
    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, fetchersToLoad.map(f => f.controller ? f.controller.signal : null), true)]);
    return {
      results,
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    // Every interruption triggers a revalidation
    isRevalidationRequired = true;
    // Cancel pending route-level deferreds and mark cancelled routes for
    // revalidation
    cancelledDeferredRoutes.push(...cancelActiveDeferreds());
    // Abort in-flight fetcher loads
    fetchLoadMatches.forEach((_, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.push(key);
        abortFetcher(key);
      }
    });
  }
  function updateFetcherState(key, fetcher, opts) {
    if (opts === void 0) {
      opts = {};
    }
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  function setFetcherError(key, routeId, error, opts) {
    if (opts === void 0) {
      opts = {};
    }
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  function getFetcher(key) {
    if (future.v7_fetcherPersist) {
      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
      // If this fetcher was previously marked for deletion, unmark it since we
      // have a new instance
      if (deletedFetchers.has(key)) {
        deletedFetchers.delete(key);
      }
    }
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    let fetcher = state.fetchers.get(key);
    // Don't abort the controller if this is a deletion of a fetcher.submit()
    // in it's loading phase since - we don't want to abort the corresponding
    // revalidation and want them to complete and land
    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
      abortFetcher(key);
    }
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    deletedFetchers.delete(key);
    state.fetchers.delete(key);
  }
  function deleteFetcherAndUpdateState(key) {
    if (future.v7_fetcherPersist) {
      let count = (activeFetchers.get(key) || 0) - 1;
      if (count <= 0) {
        activeFetchers.delete(key);
        deletedFetchers.add(key);
      } else {
        activeFetchers.set(key, count);
      }
    } else {
      deleteFetcher(key);
    }
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant(controller, "Expected fetch controller: " + key);
    controller.abort();
    fetchControllers.delete(key);
  }
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = getDoneFetcher(fetcher.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    let updatedFetchers = false;
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, "Expected fetcher: " + key);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
        updatedFetchers = true;
      }
    }
    markFetchersDone(doneKeys);
    return updatedFetchers;
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn) {
      blockerFunctions.set(key, fn);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  }
  // Utility function to update blockers, ensuring valid state transitions
  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    // Poor mans state machine :)
    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM
    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
    let blockers = new Map(state.blockers);
    blockers.set(key, newBlocker);
    updateState({
      blockers
    });
  }
  function shouldBlockNavigation(_ref4) {
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = _ref4;
    if (blockerFunctions.size === 0) {
      return;
    }
    // We ony support a single active blocker at the moment since we don't have
    // any compelling use cases for multi-blocker yet
    if (blockerFunctions.size > 1) {
      warning(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      // If the blocker is currently proceeding, we don't need to re-check
      // it and can let this navigation continue
      return;
    }
    // At this point, we know we're unblocked/blocked so we need to check the
    // user-provided blocker function
    if (blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    })) {
      return blockerKey;
    }
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        // Cancel the deferred - but do not remove from activeDeferreds here -
        // we rely on the subscribers to do that so our tests can assert proper
        // cleanup via _internalActiveDeferreds
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  }
  // Opt in to capturing and reporting scroll positions during navigations,
  // used by the <ScrollRestoration> component
  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey = getKey || null;
    // Perform initial hydration scroll restoration, since we miss the boat on
    // the initial updateState() because we've not yet rendered <ScrollRestoration/>
    // and therefore have no savedScrollPositions available
    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y = getSavedScrollPosition(state.location, state.matches);
      if (y != null) {
        updateState({
          restoreScrollPosition: y
        });
      }
    }
    return () => {
      savedScrollPositions = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
    };
  }
  function getScrollKey(location, matches) {
    if (getScrollRestorationKey) {
      let key = getScrollRestorationKey(location, matches.map(m => convertRouteMatchToUiMatch(m, state.loaderData)));
      return key || location.key;
    }
    return location.key;
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollPosition) {
      let key = getScrollKey(location, matches);
      savedScrollPositions[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions) {
      let key = getScrollKey(location, matches);
      let y = savedScrollPositions[key];
      if (typeof y === "number") {
        return y;
      }
    }
    return null;
  }
  function _internalSetRoutes(newRoutes) {
    manifest = {};
    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);
  }
  router = {
    get basename() {
      return basename;
    },
    get future() {
      return future;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    get window() {
      return routerWindow;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: to => init.history.createHref(to),
    encodeLocation: to => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher: deleteFetcherAndUpdateState,
    dispose,
    getBlocker,
    deleteBlocker,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  };
  return router;
}
//#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createStaticHandler
////////////////////////////////////////////////////////////////////////////////
const UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
function createStaticHandler(routes, opts) {
  invariant(routes.length > 0, "You must provide a non-empty routes array to createStaticHandler");
  let manifest = {};
  let basename = (opts ? opts.basename : null) || "/";
  let mapRouteProperties;
  if (opts != null && opts.mapRouteProperties) {
    mapRouteProperties = opts.mapRouteProperties;
  } else if (opts != null && opts.detectErrorBoundary) {
    // If they are still using the deprecated version, wrap it with the new API
    let detectErrorBoundary = opts.detectErrorBoundary;
    mapRouteProperties = route => ({
      hasErrorBoundary: detectErrorBoundary(route)
    });
  } else {
    mapRouteProperties = defaultMapRouteProperties;
  }
  // Config driven behavior flags
  let future = _extends({
    v7_relativeSplatPath: false,
    v7_throwAbortReason: false
  }, opts ? opts.future : null);
  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);
  /**
   * The query() method is intended for document requests, in which we want to
   * call an optional action and potentially multiple loaders for all nested
   * routes.  It returns a StaticHandlerContext object, which is very similar
   * to the router state (location, loaderData, actionData, errors, etc.) and
   * also adds SSR-specific information such as the statusCode and headers
   * from action/loaders Responses.
   *
   * It _should_ never throw and should report all errors through the
   * returned context.errors object, properly associating errors to their error
   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be
   * used to emulate React error boundaries during SSr by performing a second
   * pass only down to the boundaryId.
   *
   * The one exception where we do not return a StaticHandlerContext is when a
   * redirect response is returned or thrown from any action/loader.  We
   * propagate that out and return the raw Response so the HTTP server can
   * return it directly.
   */
  async function query(request, _temp3) {
    let {
      requestContext
    } = _temp3 === void 0 ? {} : _temp3;
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);
    // SSR supports HEAD requests while SPA doesn't
    if (!isValidMethod(method) && method !== "HEAD") {
      let error = getInternalRouterError(405, {
        method
      });
      let {
        matches: methodNotAllowedMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: methodNotAllowedMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    } else if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: notFoundMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    let result = await queryImpl(request, location, matches, requestContext);
    if (isResponse(result)) {
      return result;
    }
    // When returning StaticHandlerContext, we patch back in the location here
    // since we need it for React Context.  But this helps keep our submit and
    // loadRouteData operating on a Request instead of a Location
    return _extends({
      location,
      basename
    }, result);
  }
  /**
   * The queryRoute() method is intended for targeted route requests, either
   * for fetch ?_data requests or resource route requests.  In this case, we
   * are only ever calling a single action or loader, and we are returning the
   * returned value directly.  In most cases, this will be a Response returned
   * from the action/loader, but it may be a primitive or other value as well -
   * and in such cases the calling context should handle that accordingly.
   *
   * We do respect the throw/return differentiation, so if an action/loader
   * throws, then this method will throw the value.  This is important so we
   * can do proper boundary identification in Remix where a thrown Response
   * must go to the Catch Boundary but a returned Response is happy-path.
   *
   * One thing to note is that any Router-initiated Errors that make sense
   * to associate with a status code will be thrown as an ErrorResponse
   * instance which include the raw Error, such that the calling context can
   * serialize the error as they see fit while including the proper response
   * code.  Examples here are 404 and 405 errors that occur prior to reaching
   * any user-defined loaders.
   */
  async function queryRoute(request, _temp4) {
    let {
      routeId,
      requestContext
    } = _temp4 === void 0 ? {} : _temp4;
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);
    // SSR supports HEAD requests while SPA doesn't
    if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS") {
      throw getInternalRouterError(405, {
        method
      });
    } else if (!matches) {
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);
    if (routeId && !match) {
      throw getInternalRouterError(403, {
        pathname: location.pathname,
        routeId
      });
    } else if (!match) {
      // This should never hit I don't think?
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let result = await queryImpl(request, location, matches, requestContext, match);
    if (isResponse(result)) {
      return result;
    }
    let error = result.errors ? Object.values(result.errors)[0] : undefined;
    if (error !== undefined) {
      // If we got back result.errors, that means the loader/action threw
      // _something_ that wasn't a Response, but it's not guaranteed/required
      // to be an `instanceof Error` either, so we have to use throw here to
      // preserve the "error" state outside of queryImpl.
      throw error;
    }
    // Pick off the right state value to return
    if (result.actionData) {
      return Object.values(result.actionData)[0];
    }
    if (result.loaderData) {
      var _result$activeDeferre;
      let data = Object.values(result.loaderData)[0];
      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {
        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];
      }
      return data;
    }
    return undefined;
  }
  async function queryImpl(request, location, matches, requestContext, routeMatch) {
    invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");
    try {
      if (isMutationMethod(request.method.toLowerCase())) {
        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);
        return result;
      }
      let result = await loadRouteData(request, matches, requestContext, routeMatch);
      return isResponse(result) ? result : _extends({}, result, {
        actionData: null,
        actionHeaders: {}
      });
    } catch (e) {
      // If the user threw/returned a Response in callLoaderOrAction, we throw
      // it to bail out and then return or throw here based on whether the user
      // returned or threw
      if (isQueryRouteResponse(e)) {
        if (e.type === ResultType.error) {
          throw e.response;
        }
        return e.response;
      }
      // Redirects are always returned since they don't propagate to catch
      // boundaries
      if (isRedirectResponse(e)) {
        return e;
      }
      throw e;
    }
  }
  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {
    let result;
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      let error = getInternalRouterError(405, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: actionMatch.route.id
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath, {
        isStaticRequest: true,
        isRouteRequest,
        requestContext
      });
      if (request.signal.aborted) {
        throwStaticHandlerAbortedError(request, isRouteRequest, future);
      }
    }
    if (isRedirectResult(result)) {
      // Uhhhh - this should never happen, we should always throw these from
      // callLoaderOrAction, but the type narrowing here keeps TS happy and we
      // can get back on the "throw all redirect responses" train here should
      // this ever happen :/
      throw new Response(null, {
        status: result.status,
        headers: {
          Location: result.location
        }
      });
    }
    if (isDeferredResult(result)) {
      let error = getInternalRouterError(400, {
        type: "defer-action"
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    }
    if (isRouteRequest) {
      // Note: This should only be non-Response values if we get here, since
      // isRouteRequest should throw any Response received in callLoaderOrAction
      if (isErrorResult(result)) {
        throw result.error;
      }
      return {
        matches: [actionMatch],
        loaderData: {},
        actionData: {
          [actionMatch.route.id]: result.data
        },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      let context = await loadRouteData(request, matches, requestContext, undefined, {
        [boundaryMatch.route.id]: result.error
      });
      // action status codes take precedence over loader status codes
      return _extends({}, context, {
        statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,
        actionData: null,
        actionHeaders: _extends({}, result.headers ? {
          [actionMatch.route.id]: result.headers
        } : {})
      });
    }
    // Create a GET request for the loaders
    let loaderRequest = new Request(request.url, {
      headers: request.headers,
      redirect: request.redirect,
      signal: request.signal
    });
    let context = await loadRouteData(loaderRequest, matches, requestContext);
    return _extends({}, context, result.statusCode ? {
      statusCode: result.statusCode
    } : {}, {
      actionData: {
        [actionMatch.route.id]: result.data
      },
      actionHeaders: _extends({}, result.headers ? {
        [actionMatch.route.id]: result.headers
      } : {})
    });
  }
  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {
    let isRouteRequest = routeMatch != null;
    // Short circuit if we have no loaders to run (queryRoute())
    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {
      throw getInternalRouterError(400, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: routeMatch == null ? void 0 : routeMatch.route.id
      });
    }
    let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);
    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy);
    // Short circuit if we have no loaders to run (query())
    if (matchesToLoad.length === 0) {
      return {
        matches,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: matches.reduce((acc, m) => Object.assign(acc, {
          [m.route.id]: null
        }), {}),
        errors: pendingActionError || null,
        statusCode: 200,
        loaderHeaders: {},
        activeDeferreds: null
      };
    }
    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath, {
      isStaticRequest: true,
      isRouteRequest,
      requestContext
    }))]);
    if (request.signal.aborted) {
      throwStaticHandlerAbortedError(request, isRouteRequest, future);
    }
    // Process and commit output from loaders
    let activeDeferreds = new Map();
    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);
    // Add a null for any non-loader matches for proper revalidation on the client
    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));
    matches.forEach(match => {
      if (!executedLoaders.has(match.route.id)) {
        context.loaderData[match.route.id] = null;
      }
    });
    return _extends({}, context, {
      matches,
      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null
    });
  }
  return {
    dataRoutes,
    query,
    queryRoute
  };
}
//#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Helpers
////////////////////////////////////////////////////////////////////////////////
/**
 * Given an existing StaticHandlerContext and an error thrown at render time,
 * provide an updated StaticHandlerContext suitable for a second SSR render
 */
function getStaticContextFromError(routes, context, error) {
  let newContext = _extends({}, context, {
    statusCode: isRouteErrorResponse(error) ? error.status : 500,
    errors: {
      [context._deepestRenderedBoundaryId || routes[0].id]: error
    }
  });
  return newContext;
}
function throwStaticHandlerAbortedError(request, isRouteRequest, future) {
  if (future.v7_throwAbortReason && request.signal.reason !== undefined) {
    throw request.signal.reason;
  }
  let method = isRouteRequest ? "queryRoute" : "query";
  throw new Error(method + "() call aborted: " + request.method + " " + request.url);
}
function isSubmissionNavigation(opts) {
  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== undefined);
}
function normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {
  let contextualMatches;
  let activeRouteMatch;
  if (fromRouteId) {
    // Grab matches up to the calling route so our route-relative logic is
    // relative to the correct source route
    contextualMatches = [];
    for (let match of matches) {
      contextualMatches.push(match);
      if (match.route.id === fromRouteId) {
        activeRouteMatch = match;
        break;
      }
    }
  } else {
    contextualMatches = matches;
    activeRouteMatch = matches[matches.length - 1];
  }
  // Resolve the relative path
  let path = resolveTo(to ? to : ".", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === "path");
  // When `to` is not specified we inherit search/hash from the current
  // location, unlike when to="." and we just inherit the path.
  // See https://github.com/remix-run/remix/issues/927
  if (to == null) {
    path.search = location.search;
    path.hash = location.hash;
  }
  // Add an ?index param for matched index routes if we don't already have one
  if ((to == null || to === "" || to === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  // If we're operating within a basename, prepend it to the pathname.  If
  // this is a root navigation, then just use the raw basename which allows
  // the basename to have full control over the presence of a trailing slash
  // on root actions
  if (prependBasename && basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
// Normalize navigation options by converting formMethod=GET formData objects to
// URLSearchParams so they behave identically to links with query params
function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
  // Return location verbatim on non-submission navigations
  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  }
  let getInvalidBodyError = () => ({
    path,
    error: getInternalRouterError(400, {
      type: "invalid-body"
    })
  });
  // Create a Submission on non-GET navigations
  let rawFormMethod = opts.formMethod || "get";
  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();
  let formAction = stripHashFromPath(path);
  if (opts.body !== undefined) {
    if (opts.formEncType === "text/plain") {
      // text only support POST/PUT/PATCH/DELETE submissions
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?
      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
      Array.from(opts.body.entries()).reduce((acc, _ref5) => {
        let [name, value] = _ref5;
        return "" + acc + name + "=" + value + "\n";
      }, "") : String(opts.body);
      return {
        path,
        submission: {
          formMethod,
          formAction,
          formEncType: opts.formEncType,
          formData: undefined,
          json: undefined,
          text
        }
      };
    } else if (opts.formEncType === "application/json") {
      // json only supports POST/PUT/PATCH/DELETE submissions
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      try {
        let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: undefined,
            json,
            text: undefined
          }
        };
      } catch (e) {
        return getInvalidBodyError();
      }
    }
  }
  invariant(typeof FormData === "function", "FormData is not available in this environment");
  let searchParams;
  let formData;
  if (opts.formData) {
    searchParams = convertFormDataToSearchParams(opts.formData);
    formData = opts.formData;
  } else if (opts.body instanceof FormData) {
    searchParams = convertFormDataToSearchParams(opts.body);
    formData = opts.body;
  } else if (opts.body instanceof URLSearchParams) {
    searchParams = opts.body;
    formData = convertSearchParamsToFormData(searchParams);
  } else if (opts.body == null) {
    searchParams = new URLSearchParams();
    formData = new FormData();
  } else {
    try {
      searchParams = new URLSearchParams(opts.body);
      formData = convertSearchParamsToFormData(searchParams);
    } catch (e) {
      return getInvalidBodyError();
    }
  }
  let submission = {
    formMethod,
    formAction,
    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
    formData,
    json: undefined,
    text: undefined
  };
  if (isMutationMethod(submission.formMethod)) {
    return {
      path,
      submission
    };
  }
  // Flatten submission onto URLSearchParams for GET submissions
  let parsedPath = parsePath(path);
  // On GET navigation submissions we can drop the ?index param from the
  // resulting location since all loaders will run.  But fetcher GET submissions
  // only run a single loader so we need to preserve any incoming ?index params
  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = "?" + searchParams;
  return {
    path: createPath(parsedPath),
    submission
  };
}
// Filter out all routes below any caught error as they aren't going to
// render so we don't need to load them
function getLoaderMatchesUntilBoundary(matches, boundaryId) {
  let boundaryMatches = matches;
  if (boundaryId) {
    let index = matches.findIndex(m => m.route.id === boundaryId);
    if (index >= 0) {
      boundaryMatches = matches.slice(0, index);
    }
  }
  return boundaryMatches;
}
function getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {
  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location);
  // Pick navigation matches that are net-new or qualify for revalidation
  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;
  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);
  let navigationMatches = boundaryMatches.filter((match, index) => {
    let {
      route
    } = match;
    if (route.lazy) {
      // We haven't loaded this route yet so we don't know if it's got a loader!
      return true;
    }
    if (route.loader == null) {
      return false;
    }
    if (isInitialLoad) {
      if (route.loader.hydrate) {
        return true;
      }
      return state.loaderData[route.id] === undefined && (
      // Don't re-run if the loader ran and threw an error
      !state.errors || state.errors[route.id] === undefined);
    }
    // Always call the loader on new route instances and pending defer cancellations
    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {
      return true;
    }
    // This is the default implementation for when we revalidate.  If the route
    // provides it's own implementation, then we give them full control but
    // provide this value so they can leverage it if needed after they check
    // their own specific use cases
    let currentRouteMatch = state.matches[index];
    let nextRouteMatch = match;
    return shouldRevalidateLoader(match, _extends({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      defaultShouldRevalidate:
      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
      isRevalidationRequired ||
      // Clicked the same link, resubmitted a GET form
      currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||
      // Search params affect all loaders
      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
    }));
  });
  // Pick fetcher.loads that need to be revalidated
  let revalidatingFetchers = [];
  fetchLoadMatches.forEach((f, key) => {
    // Don't revalidate:
    //  - on initial load (shouldn't be any fetchers then anyway)
    //  - if fetcher won't be present in the subsequent render
    //    - no longer matches the URL (v7_fetcherPersist=false)
    //    - was unmounted but persisted due to v7_fetcherPersist=true
    if (isInitialLoad || !matches.some(m => m.route.id === f.routeId) || deletedFetchers.has(key)) {
      return;
    }
    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);
    // If the fetcher path no longer matches, push it in with null matches so
    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is
    // currently only a use-case for Remix HMR where the route tree can change
    // at runtime and remove a route previously loaded via a fetcher
    if (!fetcherMatches) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    // Revalidating fetchers are decoupled from the route matches since they
    // load from a static href.  They revalidate based on explicit revalidation
    // (submission, useRevalidator, or X-Remix-Revalidate)
    let fetcher = state.fetchers.get(key);
    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
    let shouldRevalidate = false;
    if (fetchRedirectIds.has(key)) {
      // Never trigger a revalidation of an actively redirecting fetcher
      shouldRevalidate = false;
    } else if (cancelledFetcherLoads.includes(key)) {
      // Always revalidate if the fetcher was cancelled
      shouldRevalidate = true;
    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === undefined) {
      // If the fetcher hasn't ever completed loading yet, then this isn't a
      // revalidation, it would just be a brand new load if an explicit
      // revalidation is required
      shouldRevalidate = isRevalidationRequired;
    } else {
      // Otherwise fall back on any user-defined shouldRevalidate, defaulting
      // to explicit revalidations only
      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({
        currentUrl,
        currentParams: state.matches[state.matches.length - 1].params,
        nextUrl,
        nextParams: matches[matches.length - 1].params
      }, submission, {
        actionResult,
        defaultShouldRevalidate: isRevalidationRequired
      }));
    }
    if (shouldRevalidate) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: fetcherMatches,
        match: fetcherMatch,
        controller: new AbortController()
      });
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew =
  // [a] -> [a, b]
  !currentMatch ||
  // [a, b] -> [a, c]
  match.route.id !== currentMatch.route.id;
  // Handle the case that we don't have data for a re-used route, potentially
  // from a prior error or from a cancelled pending deferred
  let isMissingData = currentLoaderData[match.route.id] === undefined;
  // Always load if this is a net-new route or we don't yet have data
  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname ||
    // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
/**
 * Execute route.lazy() methods to lazily load route modules (loader, action,
 * shouldRevalidate) and update the routeManifest in place which shares objects
 * with dataRoutes so those get updated as well.
 */
async function loadLazyRouteModule(route, mapRouteProperties, manifest) {
  if (!route.lazy) {
    return;
  }
  let lazyRoute = await route.lazy();
  // If the lazy route function was executed and removed by another parallel
  // call then we can return - first lazy() to finish wins because the return
  // value of lazy is expected to be static
  if (!route.lazy) {
    return;
  }
  let routeToUpdate = manifest[route.id];
  invariant(routeToUpdate, "No route found in manifest");
  // Update the route in place.  This should be safe because there's no way
  // we could yet be sitting on this route as we can't get there without
  // resolving lazy() first.
  //
  // This is different than the HMR "update" use-case where we may actively be
  // on the route being updated.  The main concern boils down to "does this
  // mutation affect any ongoing navigations or any current state.matches
  // values?".  If not, it should be safe to update in place.
  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let staticRouteValue = routeToUpdate[lazyRouteProperty];
    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&
    // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning(!isPropertyStaticallyDefined, "Route \"" + routeToUpdate.id + "\" has a static property \"" + lazyRouteProperty + "\" " + "defined but its lazy function is also returning a value for this property. " + ("The lazy route property \"" + lazyRouteProperty + "\" will be ignored."));
    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
    }
  }
  // Mutate the route with the provided updates.  Do this first so we pass
  // the updated version to mapRouteProperties
  Object.assign(routeToUpdate, routeUpdates);
  // Mutate the `hasErrorBoundary` property on the route based on the route
  // updates and remove the `lazy` function so we don't resolve the lazy
  // route again.
  Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {
    lazy: undefined
  }));
}
async function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, v7_relativeSplatPath, opts) {
  if (opts === void 0) {
    opts = {};
  }
  let resultType;
  let result;
  let onReject;
  let runHandler = handler => {
    // Setup a promise we can race against so that abort signals short circuit
    let reject;
    let abortPromise = new Promise((_, r) => reject = r);
    onReject = () => reject();
    request.signal.addEventListener("abort", onReject);
    return Promise.race([handler({
      request,
      params: match.params,
      context: opts.requestContext
    }), abortPromise]);
  };
  try {
    let handler = match.route[type];
    if (match.route.lazy) {
      if (handler) {
        // Run statically defined handler in parallel with lazy()
        let handlerError;
        let values = await Promise.all([
        // If the handler throws, don't let it immediately bubble out,
        // since we need to let the lazy() execution finish so we know if this
        // route has a boundary that can handle the error
        runHandler(handler).catch(e => {
          handlerError = e;
        }), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]);
        if (handlerError) {
          throw handlerError;
        }
        result = values[0];
      } else {
        // Load lazy route module, then run any returned handler
        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);
        handler = match.route[type];
        if (handler) {
          // Handler still run even if we got interrupted to maintain consistency
          // with un-abortable behavior of handler execution on non-lazy or
          // previously-lazy-loaded routes
          result = await runHandler(handler);
        } else if (type === "action") {
          let url = new URL(request.url);
          let pathname = url.pathname + url.search;
          throw getInternalRouterError(405, {
            method: request.method,
            pathname,
            routeId: match.route.id
          });
        } else {
          // lazy() route has no loader to run.  Short circuit here so we don't
          // hit the invariant below that errors on returning undefined.
          return {
            type: ResultType.data,
            data: undefined
          };
        }
      }
    } else if (!handler) {
      let url = new URL(request.url);
      let pathname = url.pathname + url.search;
      throw getInternalRouterError(404, {
        pathname
      });
    } else {
      result = await runHandler(handler);
    }
    invariant(result !== undefined, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ("\"" + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e) {
    resultType = ResultType.error;
    result = e;
  } finally {
    if (onReject) {
      request.signal.removeEventListener("abort", onReject);
    }
  }
  if (isResponse(result)) {
    let status = result.status;
    // Process redirects
    if (redirectStatusCodes.has(status)) {
      let location = result.headers.get("Location");
      invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");
      // Support relative routing in internal redirects
      if (!ABSOLUTE_URL_REGEX.test(location)) {
        location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location, v7_relativeSplatPath);
      } else if (!opts.isStaticRequest) {
        // Strip off the protocol+origin for same-origin + same-basename absolute
        // redirects. If this is a static request, we can let it go back to the
        // browser as-is
        let currentUrl = new URL(request.url);
        let url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);
        let isSameBasename = stripBasename(url.pathname, basename) != null;
        if (url.origin === currentUrl.origin && isSameBasename) {
          location = url.pathname + url.search + url.hash;
        }
      }
      // Don't process redirects in the router during static requests requests.
      // Instead, throw the Response and let the server handle it with an HTTP
      // redirect.  We also update the Location header in place in this flow so
      // basename and relative routing is taken into account
      if (opts.isStaticRequest) {
        result.headers.set("Location", location);
        throw result;
      }
      return {
        type: ResultType.redirect,
        status,
        location,
        revalidate: result.headers.get("X-Remix-Revalidate") !== null,
        reloadDocument: result.headers.get("X-Remix-Reload-Document") !== null
      };
    }
    // For SSR single-route requests, we want to hand Responses back directly
    // without unwrapping.  We do this with the QueryRouteResponse wrapper
    // interface so we can know whether it was returned or thrown
    if (opts.isRouteRequest) {
      let queryRouteResponse = {
        type: resultType === ResultType.error ? ResultType.error : ResultType.data,
        response: result
      };
      throw queryRouteResponse;
    }
    let data;
    try {
      let contentType = result.headers.get("Content-Type");
      // Check between word boundaries instead of startsWith() due to the last
      // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type
      if (contentType && /\bapplication\/json\b/.test(contentType)) {
        if (result.body == null) {
          data = null;
        } else {
          data = await result.json();
        }
      } else {
        data = await result.text();
      }
    } catch (e) {
      return {
        type: ResultType.error,
        error: e
      };
    }
    if (resultType === ResultType.error) {
      return {
        type: resultType,
        error: new ErrorResponseImpl(status, result.statusText, data),
        headers: result.headers
      };
    }
    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (resultType === ResultType.error) {
    return {
      type: resultType,
      error: result
    };
  }
  if (isDeferredData(result)) {
    var _result$init, _result$init2;
    return {
      type: ResultType.deferred,
      deferredData: result,
      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)
    };
  }
  return {
    type: ResultType.data,
    data: result
  };
}
// Utility method for creating the Request instances for loaders/actions during
// client-side navigations and fetches.  During SSR we will always have a
// Request instance from the static handler (query/queryRoute)
function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType
    } = submission;
    // Didn't think we needed this but it turns out unlike other methods, patch
    // won't be properly normalized to uppercase and results in a 405 error.
    // See: https://fetch.spec.whatwg.org/#concept-method
    init.method = formMethod.toUpperCase();
    if (formEncType === "application/json") {
      init.headers = new Headers({
        "Content-Type": formEncType
      });
      init.body = JSON.stringify(submission.json);
    } else if (formEncType === "text/plain") {
      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)
      init.body = submission.text;
    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)
      init.body = convertFormDataToSearchParams(submission.formData);
    } else {
      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)
      init.body = submission.formData;
    }
  }
  return new Request(url, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs
    searchParams.append(key, typeof value === "string" ? value : value.name);
  }
  return searchParams;
}
function convertSearchParamsToFormData(searchParams) {
  let formData = new FormData();
  for (let [key, value] of searchParams.entries()) {
    formData.append(key, value);
  }
  return formData;
}
function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
  // Fill in loaderData/errors from our loaders
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {};
  // Process loader results into state.loaderData/state.errors
  results.forEach((result, index) => {
    let id = matchesToLoad[index].route.id;
    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      // Look upwards from the matched route for the closest ancestor
      // error boundary, defaulting to the root match
      let boundaryMatch = findNearestBoundary(matches, id);
      let error = result.error;
      // If we have a pending action error, we report it at the highest-route
      // that throws a loader error, and then clear it out to indicate that
      // it was consumed
      if (pendingError) {
        error = Object.values(pendingError)[0];
        pendingError = undefined;
      }
      errors = errors || {};
      // Prefer higher error values if lower errors bubble to the same boundary
      if (errors[boundaryMatch.route.id] == null) {
        errors[boundaryMatch.route.id] = error;
      }
      // Clear our any prior loaderData for the throwing route
      loaderData[id] = undefined;
      // Once we find our first (highest) error, we set the status code and
      // prevent deeper status codes from overriding
      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    } else {
      if (isDeferredResult(result)) {
        activeDeferreds.set(id, result.deferredData);
        loaderData[id] = result.deferredData.data;
      } else {
        loaderData[id] = result.data;
      }
      // Error status codes always override success status codes, but if all
      // loaders are successful we take the deepest status code.
      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
        statusCode = result.statusCode;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    }
  });
  // If we didn't consume the pending action error (i.e., all loaders
  // resolved), then consume it here.  Also clear out any loaderData for the
  // throwing route
  if (pendingError) {
    errors = pendingError;
    loaderData[Object.keys(pendingError)[0]] = undefined;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);
  // Process results from our revalidating fetchers
  for (let index = 0; index < revalidatingFetchers.length; index++) {
    let {
      key,
      match,
      controller
    } = revalidatingFetchers[index];
    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, "Did not find corresponding fetcher result");
    let result = fetcherResults[index];
    // Process fetcher non-redirect errors
    if (controller && controller.signal.aborted) {
      // Nothing to do for aborted fetchers
      continue;
    } else if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = _extends({}, errors, {
          [boundaryMatch.route.id]: result.error
        });
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      // Should never get here, redirects should get processed above, but we
      // keep this to type narrow to a success result in the else
      invariant(false, "Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      // Should never get here, deferred data should be awaited for fetchers
      // in resolveDeferredResults
      invariant(false, "Unhandled fetcher deferred data");
    } else {
      let doneFetcher = getDoneFetcher(result.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  return {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = _extends({}, newLoaderData);
  for (let match of matches) {
    let id = match.route.id;
    if (newLoaderData.hasOwnProperty(id)) {
      if (newLoaderData[id] !== undefined) {
        mergedLoaderData[id] = newLoaderData[id];
      }
    } else if (loaderData[id] !== undefined && match.route.loader) {
      // Preserve existing keys not included in newLoaderData and where a loader
      // wasn't removed by HMR
      mergedLoaderData[id] = loaderData[id];
    }
    if (errors && errors.hasOwnProperty(id)) {
      // Don't keep any loader data below the boundary
      break;
    }
  }
  return mergedLoaderData;
}
// Find the nearest error boundary, looking upwards from the leaf route (or the
// route specified by routeId) for the closest ancestor error boundary,
// defaulting to the root match
function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes) {
  // Prefer a root layout route if present, otherwise shim in a route object
  let route = routes.length === 1 ? routes[0] : routes.find(r => r.index || !r.path || r.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, _temp5) {
  let {
    pathname,
    routeId,
    method,
    type
  } = _temp5 === void 0 ? {} : _temp5;
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method + " request to \"" + pathname + "\" but " + ("did not provide a `loader` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (type === "defer-action") {
      errorMessage = "defer() is not supported in actions";
    } else if (type === "invalid-body") {
      errorMessage = "Unable to encode submission body";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = "Route \"" + routeId + "\" does not match URL \"" + pathname + "\"";
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = "No route matches URL \"" + pathname + "\"";
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method.toUpperCase() + " request to \"" + pathname + "\" but " + ("did not provide an `action` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (method) {
      errorMessage = "Invalid request method \"" + method.toUpperCase() + "\"";
    }
  }
  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);
}
// Find any returned redirect errors, starting from the lowest match
function findRedirect(results) {
  for (let i = results.length - 1; i >= 0; i--) {
    let result = results[i];
    if (isRedirectResult(result)) {
      return {
        result,
        idx: i
      };
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(_extends({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a, b) {
  if (a.pathname !== b.pathname || a.search !== b.search) {
    return false;
  }
  if (a.hash === "") {
    // /page -> /page#hash
    return b.hash !== "";
  } else if (a.hash === b.hash) {
    // /page#hash -> /page#hash
    return true;
  } else if (b.hash !== "") {
    // /page#hash -> /page#other
    return true;
  }
  // If the hash is removed the browser will re-perform a request to the server
  // /page#hash -> /page
  return false;
}
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
function isErrorResult(result) {
  return result.type === ResultType.error;
}
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
function isDeferredData(value) {
  let deferred = value;
  return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isRedirectResponse(result) {
  if (!isResponse(result)) {
    return false;
  }
  let status = result.status;
  let location = result.headers.get("Location");
  return status >= 300 && status <= 399 && location != null;
}
function isQueryRouteResponse(obj) {
  return obj && isResponse(obj.response) && (obj.type === ResultType.data || obj.type === ResultType.error);
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toLowerCase());
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toLowerCase());
}
async function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {
  for (let index = 0; index < results.length; index++) {
    let result = results[index];
    let match = matchesToLoad[index];
    // If we don't have a match, then we can have a deferred result to do
    // anything with.  This is for revalidating fetchers where the route was
    // removed during HMR
    if (!match) {
      continue;
    }
    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;
    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
      // Note: we do not have to touch activeDeferreds here since we race them
      // against the signal in resolveDeferredData and they'll get aborted
      // there if needed
      let signal = signals[index];
      invariant(signal, "Expected an AbortSignal for revalidating fetcher deferred result");
      await resolveDeferredData(result, signal, isFetcher).then(result => {
        if (result) {
          results[index] = result || results[index];
        }
      });
    }
  }
}
async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0) {
    unwrap = false;
  }
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) {
    return;
  }
  if (unwrap) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e) {
      // Handle any TrackedPromise._error values encountered while unwrapping
      return {
        type: ResultType.error,
        error: e
      };
    }
  }
  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some(v => v === "");
}
function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    // Return the leaf index route when index is present
    return matches[matches.length - 1];
  }
  // Otherwise grab the deepest "path contributing" match (ignoring index and
  // pathless layout routes)
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
}
function getSubmissionFromNavigation(navigation) {
  let {
    formMethod,
    formAction,
    formEncType,
    text,
    formData,
    json
  } = navigation;
  if (!formMethod || !formAction || !formEncType) {
    return;
  }
  if (text != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: undefined,
      json: undefined,
      text
    };
  } else if (formData != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData,
      json: undefined,
      text: undefined
    };
  } else if (json !== undefined) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: undefined,
      json,
      text: undefined
    };
  }
}
function getLoadingNavigation(location, submission) {
  if (submission) {
    let navigation = {
      state: "loading",
      location,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  } else {
    let navigation = {
      state: "loading",
      location,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      json: undefined,
      text: undefined
    };
    return navigation;
  }
}
function getSubmittingNavigation(location, submission) {
  let navigation = {
    state: "submitting",
    location,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text
  };
  return navigation;
}
function getLoadingFetcher(submission, data) {
  if (submission) {
    let fetcher = {
      state: "loading",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data
    };
    return fetcher;
  } else {
    let fetcher = {
      state: "loading",
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      json: undefined,
      text: undefined,
      data
    };
    return fetcher;
  }
}
function getSubmittingFetcher(submission, existingFetcher) {
  let fetcher = {
    state: "submitting",
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: existingFetcher ? existingFetcher.data : undefined
  };
  return fetcher;
}
function getDoneFetcher(data) {
  let fetcher = {
    state: "idle",
    formMethod: undefined,
    formAction: undefined,
    formEncType: undefined,
    formData: undefined,
    json: undefined,
    text: undefined,
    data
  };
  return fetcher;
}
function restoreAppliedTransitions(_window, transitions) {
  try {
    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);
    if (sessionPositions) {
      let json = JSON.parse(sessionPositions);
      for (let [k, v] of Object.entries(json || {})) {
        if (v && Array.isArray(v)) {
          transitions.set(k, new Set(v || []));
        }
      }
    }
  } catch (e) {
    // no-op, use default empty object
  }
}
function persistAppliedTransitions(_window, transitions) {
  if (transitions.size > 0) {
    let json = {};
    for (let [k, v] of transitions) {
      json[k] = [...v];
    }
    try {
      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));
    } catch (error) {
      warning(false, "Failed to save applied view transitions in sessionStorage (" + error + ").");
    }
  }
}
//#endregion


//# sourceMappingURL=router.js.map


/***/ }),

/***/ "./javascript/app/SDKBridge/messages/types.ts":
/*!****************************************************!*\
  !*** ./javascript/app/SDKBridge/messages/types.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CALLBACK_CALLED: () => (/* binding */ CALLBACK_CALLED),
/* harmony export */   ERROR_400_OCCURRED_IN_IFRAME: () => (/* binding */ ERROR_400_OCCURRED_IN_IFRAME),
/* harmony export */   ERROR_403_OCCURRED_IN_IFRAME: () => (/* binding */ ERROR_403_OCCURRED_IN_IFRAME),
/* harmony export */   ERROR_404_OCCURRED_IN_IFRAME: () => (/* binding */ ERROR_404_OCCURRED_IN_IFRAME),
/* harmony export */   ERROR_500_OCCURRED_IN_IFRAME: () => (/* binding */ ERROR_500_OCCURRED_IN_IFRAME),
/* harmony export */   IFRAME_JS_LOADED: () => (/* binding */ IFRAME_JS_LOADED),
/* harmony export */   PAGE_CHANGED: () => (/* binding */ PAGE_CHANGED),
/* harmony export */   PAGE_SIZE_GIVEN: () => (/* binding */ PAGE_SIZE_GIVEN),
/* harmony export */   SEND_SEED_DATA_REACT_APP: () => (/* binding */ SEND_SEED_DATA_REACT_APP),
/* harmony export */   STYLE_OVERRIDDEN: () => (/* binding */ STYLE_OVERRIDDEN),
/* harmony export */   USER_IS_LOGGED_IN: () => (/* binding */ USER_IS_LOGGED_IN),
/* harmony export */   USER_IS_LOGGED_OUT: () => (/* binding */ USER_IS_LOGGED_OUT)
/* harmony export */ });
const IFRAME_JS_LOADED = 'IFRAME_JS_LOADED';
const CALLBACK_CALLED = 'CALLBACK_CALLED';
const STYLE_OVERRIDDEN = 'STYLE_OVERRIDDEN';
const PAGE_CHANGED = 'PAGE_CHANGED';
const PAGE_SIZE_GIVEN = 'PAGE_SIZE_GIVEN';
const USER_IS_LOGGED_IN = 'USER_IS_LOGGED_IN';
const USER_IS_LOGGED_OUT = 'USER_IS_LOGGED_OUT';
const ERROR_400_OCCURRED_IN_IFRAME = 'ERROR_400_OCCURRED_IN_IFRAME';
const ERROR_403_OCCURRED_IN_IFRAME = 'ERROR_403_OCCURRED_IN_IFRAME';
const ERROR_404_OCCURRED_IN_IFRAME = 'ERROR_404_OCCURRED_IN_IFRAME';
const ERROR_500_OCCURRED_IN_IFRAME = 'ERROR_500_OCCURRED_IN_IFRAME';
const SEND_SEED_DATA_REACT_APP = 'SEND_SEED_DATA_REACT_APP';

/**
 * [LEGACY] Error posted by error pages. See files in `web/static/javascript/app/iframe`
 */

/***/ }),

/***/ "./javascript/app/common/data/routeIds.ts":
/*!************************************************!*\
  !*** ./javascript/app/common/data/routeIds.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   API_KEY_SEARCH_PARAM: () => (/* binding */ API_KEY_SEARCH_PARAM),
/* harmony export */   BUSINESSES_CITIES: () => (/* binding */ BUSINESSES_CITIES),
/* harmony export */   BUSINESSES_GROUPS: () => (/* binding */ BUSINESSES_GROUPS),
/* harmony export */   BUSINESSES_ORGS: () => (/* binding */ BUSINESSES_ORGS),
/* harmony export */   BUSINESSES_QUERIES: () => (/* binding */ BUSINESSES_QUERIES),
/* harmony export */   BUSINESSES_SELECT_ALL: () => (/* binding */ BUSINESSES_SELECT_ALL),
/* harmony export */   BUSINESS_ID_PARAM: () => (/* binding */ BUSINESS_ID_PARAM),
/* harmony export */   BUSINESS_LIST_PRODUCTS: () => (/* binding */ BUSINESS_LIST_PRODUCTS),
/* harmony export */   BUSINESS_LIST_STATUS: () => (/* binding */ BUSINESS_LIST_STATUS),
/* harmony export */   CONNECTION_TOKEN_SEARCH_PARAM: () => (/* binding */ CONNECTION_TOKEN_SEARCH_PARAM),
/* harmony export */   EXCLUDED_BUSINESSES: () => (/* binding */ EXCLUDED_BUSINESSES),
/* harmony export */   INCLUDED_BUSINESSES: () => (/* binding */ INCLUDED_BUSINESSES),
/* harmony export */   NEXT_PAGE_SEARCH_PARAM: () => (/* binding */ NEXT_PAGE_SEARCH_PARAM),
/* harmony export */   POSTS_DATE_FROM: () => (/* binding */ POSTS_DATE_FROM),
/* harmony export */   POSTS_DATE_TO: () => (/* binding */ POSTS_DATE_TO),
/* harmony export */   POSTS_TOPICS: () => (/* binding */ POSTS_TOPICS),
/* harmony export */   POST_PLATFORMS: () => (/* binding */ POST_PLATFORMS),
/* harmony export */   REPLY_TEMPLATES_LANGUAGES: () => (/* binding */ REPLY_TEMPLATES_LANGUAGES),
/* harmony export */   REVIEWS_COMMENTS: () => (/* binding */ REVIEWS_COMMENTS),
/* harmony export */   REVIEWS_DATE_FROM: () => (/* binding */ REVIEWS_DATE_FROM),
/* harmony export */   REVIEWS_DATE_TO: () => (/* binding */ REVIEWS_DATE_TO),
/* harmony export */   REVIEWS_KEYWORDS: () => (/* binding */ REVIEWS_KEYWORDS),
/* harmony export */   REVIEWS_PLATFORMS: () => (/* binding */ REVIEWS_PLATFORMS),
/* harmony export */   REVIEWS_RATING: () => (/* binding */ REVIEWS_RATING),
/* harmony export */   REVIEWS_TAG: () => (/* binding */ REVIEWS_TAG),
/* harmony export */   REVIEW_ANALYTICS_DATE_FROM: () => (/* binding */ REVIEW_ANALYTICS_DATE_FROM),
/* harmony export */   REVIEW_ANALYTICS_DATE_TO: () => (/* binding */ REVIEW_ANALYTICS_DATE_TO),
/* harmony export */   REVIEW_ANALYTICS_KEYWORDS: () => (/* binding */ REVIEW_ANALYTICS_KEYWORDS),
/* harmony export */   REVIEW_ANALYTICS_TAGS: () => (/* binding */ REVIEW_ANALYTICS_TAGS),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   extractOidcParam: () => (/* binding */ extractOidcParam),
/* harmony export */   extractPathParam: () => (/* binding */ extractPathParam),
/* harmony export */   extractSearchParam: () => (/* binding */ extractSearchParam),
/* harmony export */   testPath: () => (/* binding */ testPath)
/* harmony export */ });
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom */ "./node_modules/@remix-run/router/dist/router.js");
/* harmony import */ var url_search_params__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url-search-params */ "./node_modules/url-search-params/build/url-search-params.node.js");
/* harmony import */ var url_search_params__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(url_search_params__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var app_common_services_sso_getParams__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/common/services/sso/getParams */ "./javascript/app/common/services/sso/getParams.ts");




// TODO: Should properly use react-router-dom instead
/** @deprecated */
const testPath = (pathTemplate, path, exact = false) => !!(0,react_router_dom__WEBPACK_IMPORTED_MODULE_2__.matchPath)({
  path: pathTemplate,
  end: exact
}, path);

// TODO: Should properly use the react-router-dom instead
/** @deprecated */
const extractPathParam = (pathname, pathTemplate, pathParam) => {
  var _match$params;
  const match = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_2__.matchPath)({
    path: pathTemplate
  }, decodeURIComponent(pathname));
  return (match === null || match === void 0 ? void 0 : (_match$params = match.params) === null || _match$params === void 0 ? void 0 : _match$params[pathParam]) || '';
};

// TODO: Should properly use the router instead
/** @deprecated */
const extractSearchParam = paramName => {
  const searchParams = new (url_search_params__WEBPACK_IMPORTED_MODULE_0___default())(window.location.search);
  return searchParams.get(paramName) || '';
};
const extractOidcParam = () => {
  // Handle only PKCE now
  const ssoAlias = extractSearchParam('sso_alias');
  if (!ssoAlias) {
    return null;
  }
  return (0,app_common_services_sso_getParams__WEBPACK_IMPORTED_MODULE_1__.getPKCEParams)();
};

// SEARCH PARAM
const NEXT_PAGE_SEARCH_PARAM = 'next_page';
const CONNECTION_TOKEN_SEARCH_PARAM = 'connection_token';
const API_KEY_SEARCH_PARAM = 'api_key';

// BUSINESS MODAL SEARCH PARAMS
const BUSINESSES_SELECT_ALL = 'select-all';
const INCLUDED_BUSINESSES = 'included';
const EXCLUDED_BUSINESSES = 'excluded';
const BUSINESSES_QUERIES = 'queries';
const BUSINESSES_CITIES = 'cities';
const BUSINESSES_GROUPS = 'groups';
const BUSINESSES_ORGS = 'orgs';

// Constant used by iframe sdk
// in the sdk there is an option 'businessId', if the option is set, the
// sdk will append a get param `?${BUSINESS_ID_PARAM}=${businessId}` each
// time we change the page. It must be equal to INCLUDED_BUSINESSES so
// that the sync with Redux happen. There's still a manual sync in the
// review booster. It was developed first manually without global sync thus
// the extra variable, but I let it as is to track easily iframe related
// parts.
const BUSINESS_ID_PARAM = INCLUDED_BUSINESSES;

// BUSINESS LIST SEARCH PARAMS
const BUSINESS_LIST_STATUS = 'status';
const BUSINESS_LIST_PRODUCTS = 'products';

// POSTS SEARCH PARAMS
const POSTS_DATE_FROM = 'date-from';
const POSTS_DATE_TO = 'date-to';
const POSTS_TOPICS = 'topics';
const POST_PLATFORMS = 'platforms';

// REVIEWS SEARCH PARAMS
const REVIEWS_DATE_FROM = 'date-from';
const REVIEWS_DATE_TO = 'date-to';
const REVIEWS_PLATFORMS = 'platforms';
const REVIEWS_RATING = 'rating';
const REVIEWS_COMMENTS = 'comments';
const REVIEWS_KEYWORDS = 'keywords';
const REVIEWS_TAG = 'tag';

// REVIEW ANALYTICS SEARCH PARAMS
const REVIEW_ANALYTICS_DATE_FROM = 'date-from';
const REVIEW_ANALYTICS_DATE_TO = 'date-to';
const REVIEW_ANALYTICS_KEYWORDS = 'keywords';
const REVIEW_ANALYTICS_TAGS = 'tag';

// REPLY TEMPLATES
const REPLY_TEMPLATES_LANGUAGES = 'languages';

/** @deprecated use react-router */
const getPath = () => document.location.pathname;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getPath);

/***/ }),

/***/ "./javascript/app/common/services/sso/getParams.ts":
/*!*********************************************************!*\
  !*** ./javascript/app/common/services/sso/getParams.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPKCEParams: () => (/* binding */ getPKCEParams)
/* harmony export */ });
/* harmony import */ var app_common_data_routeIds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/common/data/routeIds */ "./javascript/app/common/data/routeIds.ts");

const getPKCEParams = () => {
  const code = (0,app_common_data_routeIds__WEBPACK_IMPORTED_MODULE_0__.extractSearchParam)('code');
  const state = (0,app_common_data_routeIds__WEBPACK_IMPORTED_MODULE_0__.extractSearchParam)('state');
  return {
    code,
    state
  };
};

/***/ }),

/***/ "./javascript/app/common/utils/urls.ts":
/*!*********************************************!*\
  !*** ./javascript/app/common/utils/urls.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extractPartooSubdomain: () => (/* binding */ extractPartooSubdomain),
/* harmony export */   isUrl: () => (/* binding */ isUrl)
/* harmony export */ });
const isUrl = urlString => {
  try {
    const url = new URL(urlString);
    return url.protocol === 'http:' || url.protocol === 'https:' || url.protocol === 'ftp:';
  } catch (error) {
    return false;
  }
};
const PARTOO_APP_PROD_HOSTNAME = 'app.partoo.co';
const PARTOO_ADMIN_PROD_HOSTNAME = 'admin.partoo.co';
const MEDIAPOST_PROD_HOSTNAME = 'app.mavisibiliteweb.fr';
const JSSDK_PROD_HOSTNAME = 'https://jssdk-playground.partoo.co';
const extractPartooSubdomain = () => {
  if ([PARTOO_APP_PROD_HOSTNAME, PARTOO_ADMIN_PROD_HOSTNAME, MEDIAPOST_PROD_HOSTNAME, JSSDK_PROD_HOSTNAME].includes(window.location.hostname)) return '';
  const domainPattern = /(?:app|admin|jssdk-playground)\.([^.]+)\.partoo\.co/i;
  const match = window.location.hostname.match(domainPattern);
  return match && match.length >= 2 ? match[1] : null;
};

/***/ }),

/***/ "./javascript/app/config.ts":
/*!**********************************!*\
  !*** ./javascript/app/config.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ADMIN_API_BASE_URL: () => (/* binding */ ADMIN_API_BASE_URL),
/* harmony export */   APP_API_BASE_URL: () => (/* binding */ APP_API_BASE_URL),
/* harmony export */   BASE_URL: () => (/* binding */ BASE_URL),
/* harmony export */   DEBUG: () => (/* binding */ DEBUG),
/* harmony export */   ENV: () => (/* binding */ ENV),
/* harmony export */   FEEDBACK_MANAGEMENT_BASE_URL: () => (/* binding */ FEEDBACK_MANAGEMENT_BASE_URL),
/* harmony export */   SENTRY_DSN: () => (/* binding */ SENTRY_DSN),
/* harmony export */   STATIC_BASE_URL: () => (/* binding */ STATIC_BASE_URL),
/* harmony export */   WEBSOCKET_LIVE_UPDATES_URL: () => (/* binding */ WEBSOCKET_LIVE_UPDATES_URL),
/* harmony export */   WHATSAPP_APP_ID: () => (/* binding */ WHATSAPP_APP_ID),
/* harmony export */   WHATSAPP_EMBEDDED_SIGNUP_CONFIG_ID: () => (/* binding */ WHATSAPP_EMBEDDED_SIGNUP_CONFIG_ID),
/* harmony export */   getUrlsFromSubdomain: () => (/* binding */ getUrlsFromSubdomain)
/* harmony export */ });
/* harmony import */ var app_common_utils_urls__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/common/utils/urls */ "./javascript/app/common/utils/urls.ts");

const subdomain = (0,app_common_utils_urls__WEBPACK_IMPORTED_MODULE_0__.extractPartooSubdomain)();
const CHECK_IS_SANDBOX = "" === 'sandbox';
const ENV = CHECK_IS_SANDBOX ? 'sandbox' : !subdomain || subdomain === '' ? 'prod' : subdomain;

// Default set to prod urls
const DEFAULT_APP_BASE_URL = 'https://app.partoo.co';
const DEFAULT_ADMIN_BASE_URL = 'https://admin.partoo.co';
const DEFAULT_STATIC_BASE_URL = 'https://static.partoo.co';
const DEFAULT_APP_API_BASE_URL = `${DEFAULT_APP_BASE_URL}/api/v2`;
const DEFAULT_ADMIN_API_BASE_URL = `${DEFAULT_ADMIN_BASE_URL}/api/v2`;
const DEFAULT_SENTRY_DSN = 'https://fd92d2cce66347dcb28ef2d21f031d7c@o956265.ingest.sentry.io/5905624';
const DEFAULT_WEBSOCKET_LIVE_UPDATES_URL = 'wss://websockets.prod.partoo.co';
const DEFAULT_FEEDBACK_MANAGEMENT_BASE_URL = 'https://survey.partoo.co';
let BASE_URL = DEFAULT_APP_BASE_URL;
let STATIC_BASE_URL = DEFAULT_STATIC_BASE_URL;
let APP_API_BASE_URL = DEFAULT_APP_API_BASE_URL;
let ADMIN_API_BASE_URL = DEFAULT_ADMIN_API_BASE_URL;
let SENTRY_DSN = DEFAULT_SENTRY_DSN;
let WEBSOCKET_LIVE_UPDATES_URL = DEFAULT_WEBSOCKET_LIVE_UPDATES_URL;
let FEEDBACK_MANAGEMENT_BASE_URL = DEFAULT_FEEDBACK_MANAGEMENT_BASE_URL;
let WHATSAPP_APP_ID = '539617142869973';
let WHATSAPP_EMBEDDED_SIGNUP_CONFIG_ID = '297841676428960';
const DEBUG = ENV !== 'prod';
const getUrlsFromSubdomain = subdomain => {
  if (!subdomain) return;
  BASE_URL = `https://app.${subdomain}.partoo.co`;
  APP_API_BASE_URL = `https://app.${subdomain}.partoo.co/api/v2`;
  ADMIN_API_BASE_URL = `https://admin.${subdomain}.partoo.co/api/v2`;
  STATIC_BASE_URL = `https://static.${subdomain}.partoo.co`;
  WEBSOCKET_LIVE_UPDATES_URL = `wss://websockets.${subdomain}.partoo.co`;
  FEEDBACK_MANAGEMENT_BASE_URL = `https://survey.${subdomain}.partoo.co`;
};
switch (ENV) {
  case 'prod':
    break;
  case 'dev':
    BASE_URL = `https://app.${subdomain}.partoo.co`;
    APP_API_BASE_URL = `https://app.${subdomain}.partoo.co/api/v2`;
    ADMIN_API_BASE_URL = `https://admin.${subdomain}.partoo.co/api/v2`;
    STATIC_BASE_URL = `https://static.${subdomain}.partoo.co`;
    SENTRY_DSN = '';
    WEBSOCKET_LIVE_UPDATES_URL = 'wss://app.dev.partoo.co/websockets';
    FEEDBACK_MANAGEMENT_BASE_URL = `https://survey.${subdomain}.partoo.co`;
    break;
  case 'sandbox':
    BASE_URL = 'https://app.sandbox.partoo.co';
    APP_API_BASE_URL = 'https://app.sandbox.partoo.co/api/v2';
    ADMIN_API_BASE_URL = 'https://admin.sandbox.partoo.co/api/v2';
    STATIC_BASE_URL = 'https://static.sandbox.partoo.co';
    SENTRY_DSN = '';
    WEBSOCKET_LIVE_UPDATES_URL = 'wss://websockets.sandbox.partoo.co';
    FEEDBACK_MANAGEMENT_BASE_URL = 'https://survey.sandbox.partoo.co';
    break;
  default:
    getUrlsFromSubdomain(subdomain);
    // whatsapp config for staging
    WHATSAPP_APP_ID = '1038640290773644';
    WHATSAPP_EMBEDDED_SIGNUP_CONFIG_ID = '1037525230684636';
    break;
}

/***/ }),

/***/ "./javascript/app/pages/settingsV2/subPages/Team/components/UserManagement/utils/enums.ts":
/*!************************************************************************************************!*\
  !*** ./javascript/app/pages/settingsV2/subPages/Team/components/UserManagement/utils/enums.ts ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Products: () => (/* binding */ Products),
/* harmony export */   USER_ID_CREATE: () => (/* binding */ USER_ID_CREATE),
/* harmony export */   UserListQueryKeys: () => (/* binding */ UserListQueryKeys),
/* harmony export */   UserStatus: () => (/* binding */ UserStatus)
/* harmony export */ });
let UserListQueryKeys = /*#__PURE__*/function (UserListQueryKeys) {
  UserListQueryKeys["QUERY"] = "query";
  UserListQueryKeys["STATUS"] = "status";
  UserListQueryKeys["USER_EDIT"] = "user_edit";
  UserListQueryKeys["USER_DELETE"] = "user_delete";
  UserListQueryKeys["USER_INVITE"] = "user_invite";
  return UserListQueryKeys;
}({});
let UserStatus = /*#__PURE__*/function (UserStatus) {
  UserStatus["ACTIVE"] = "active";
  UserStatus["INVITED"] = "invited";
  return UserStatus;
}({});
let Products = /*#__PURE__*/function (Products) {
  Products["PRESENCE_MANAGEMENT"] = "presence_management";
  Products["REVIEW_MANAGEMENT"] = "review_management";
  Products["REVIEW_BOOSTER"] = "review_booster";
  Products["MESSAGES"] = "business_message";
  return Products;
}({});
const USER_ID_CREATE = 'create';

/***/ }),

/***/ "./javascript/app/routing/routeIds/index.ts":
/*!**************************************************!*\
  !*** ./javascript/app/routing/routeIds/index.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ACCOUNT_PATH_TOKEN: () => (/* binding */ ACCOUNT_PATH_TOKEN),
/* harmony export */   ADD_PATH_TOKEN: () => (/* binding */ ADD_PATH_TOKEN),
/* harmony export */   ANALYTICS_PATH: () => (/* binding */ ANALYTICS_PATH),
/* harmony export */   ANALYTICS_PATH_TOKEN: () => (/* binding */ ANALYTICS_PATH_TOKEN),
/* harmony export */   ANALYTICS_REVIEW_PATH: () => (/* binding */ ANALYTICS_REVIEW_PATH),
/* harmony export */   ANALYTICS_VISIBILITY_PATH: () => (/* binding */ ANALYTICS_VISIBILITY_PATH),
/* harmony export */   API_KEYS_PATH_TOKEN: () => (/* binding */ API_KEYS_PATH_TOKEN),
/* harmony export */   API_KEY_MANAGER_PATH_TOKEN: () => (/* binding */ API_KEY_MANAGER_PATH_TOKEN),
/* harmony export */   AUTO_REPLY_PATH_TOKEN: () => (/* binding */ AUTO_REPLY_PATH_TOKEN),
/* harmony export */   BULK_UPDATE_PATH_TOKEN: () => (/* binding */ BULK_UPDATE_PATH_TOKEN),
/* harmony export */   BUSINESSES_PATH_TOKEN: () => (/* binding */ BUSINESSES_PATH_TOKEN),
/* harmony export */   BUSINESS_ID: () => (/* binding */ BUSINESS_ID),
/* harmony export */   CHATBOTS_PATH_TOKEN: () => (/* binding */ CHATBOTS_PATH_TOKEN),
/* harmony export */   CHATBOT_PATH_TOKEN: () => (/* binding */ CHATBOT_PATH_TOKEN),
/* harmony export */   CHAT_PREFERENCES_PATH_TOKEN: () => (/* binding */ CHAT_PREFERENCES_PATH_TOKEN),
/* harmony export */   COMPONENT_TEST_PATH: () => (/* binding */ COMPONENT_TEST_PATH),
/* harmony export */   CONFIGURATION_PATH_TOKEN: () => (/* binding */ CONFIGURATION_PATH_TOKEN),
/* harmony export */   CONNECTIONS_PATH_TOKEN: () => (/* binding */ CONNECTIONS_PATH_TOKEN),
/* harmony export */   CONNECTION_INVITE_PATH: () => (/* binding */ CONNECTION_INVITE_PATH),
/* harmony export */   CONNECTION_LOGIN_SSO_PATH: () => (/* binding */ CONNECTION_LOGIN_SSO_PATH),
/* harmony export */   CONNECTION_LOST_PASSWORD_PATH: () => (/* binding */ CONNECTION_LOST_PASSWORD_PATH),
/* harmony export */   CONNECTION_PATH: () => (/* binding */ CONNECTION_PATH),
/* harmony export */   CONNECTION_PATH_TOKEN: () => (/* binding */ CONNECTION_PATH_TOKEN),
/* harmony export */   CONNECTION_RESET_PASSWORD_TEMPLATE_PATH: () => (/* binding */ CONNECTION_RESET_PASSWORD_TEMPLATE_PATH),
/* harmony export */   CONVERSATIONS_MESSAGING_PATH: () => (/* binding */ CONVERSATIONS_MESSAGING_PATH),
/* harmony export */   CONVERSATIONS_PATH: () => (/* binding */ CONVERSATIONS_PATH),
/* harmony export */   CONVERSATIONS_REVIEW_MANAGEMENT_PATH: () => (/* binding */ CONVERSATIONS_REVIEW_MANAGEMENT_PATH),
/* harmony export */   CONVERSATIONS_REVIEW_SEND_INVITE_PATH: () => (/* binding */ CONVERSATIONS_REVIEW_SEND_INVITE_PATH),
/* harmony export */   CONVERSATION_STARTERS_PATH_TOKEN: () => (/* binding */ CONVERSATION_STARTERS_PATH_TOKEN),
/* harmony export */   CUSTOMER_EXPERIENCE_CLIENT_REVIEWS_PATH: () => (/* binding */ CUSTOMER_EXPERIENCE_CLIENT_REVIEWS_PATH),
/* harmony export */   CUSTOMER_EXPERIENCE_PATH: () => (/* binding */ CUSTOMER_EXPERIENCE_PATH),
/* harmony export */   CUSTOMER_EXPERIENCE_PATH_TOKEN: () => (/* binding */ CUSTOMER_EXPERIENCE_PATH_TOKEN),
/* harmony export */   CUSTOMER_EXPERIENCE_SEND_INVITE_PATH: () => (/* binding */ CUSTOMER_EXPERIENCE_SEND_INVITE_PATH),
/* harmony export */   CUSTOM_FIELDS_PATH_TOKEN: () => (/* binding */ CUSTOM_FIELDS_PATH_TOKEN),
/* harmony export */   DIFFUSION_PATH_TOKEN: () => (/* binding */ DIFFUSION_PATH_TOKEN),
/* harmony export */   FACEBOOK_OAUTH2_START_PATH: () => (/* binding */ FACEBOOK_OAUTH2_START_PATH),
/* harmony export */   FIELD_PERMISSIONS_PATH_TOKEN: () => (/* binding */ FIELD_PERMISSIONS_PATH_TOKEN),
/* harmony export */   GOOGLE_OAUTH2_START_PATH: () => (/* binding */ GOOGLE_OAUTH2_START_PATH),
/* harmony export */   GOOGLE_VERIFICATIO_PATH_TOKEN: () => (/* binding */ GOOGLE_VERIFICATIO_PATH_TOKEN),
/* harmony export */   GROUPS_SETTINGS_PATH_TOKEN: () => (/* binding */ GROUPS_SETTINGS_PATH_TOKEN),
/* harmony export */   ID_PARAM_TOKEN: () => (/* binding */ ID_PARAM_TOKEN),
/* harmony export */   INTEGRATIONS_PATH_TOKEN: () => (/* binding */ INTEGRATIONS_PATH_TOKEN),
/* harmony export */   INVITE_PATH_TOKEN: () => (/* binding */ INVITE_PATH_TOKEN),
/* harmony export */   INVOICES_PATH_TOKEN: () => (/* binding */ INVOICES_PATH_TOKEN),
/* harmony export */   INVOICE_PATH_TOKEN: () => (/* binding */ INVOICE_PATH_TOKEN),
/* harmony export */   LEGACY_ANALYTICS_PATH: () => (/* binding */ LEGACY_ANALYTICS_PATH),
/* harmony export */   LEGACY_ANALYTICS_REVIEW_PATH: () => (/* binding */ LEGACY_ANALYTICS_REVIEW_PATH),
/* harmony export */   LEGACY_ANALYTICS_VISIBILITY_PATH: () => (/* binding */ LEGACY_ANALYTICS_VISIBILITY_PATH),
/* harmony export */   LEGACY_CONVERSATIONS_MESSAGING_PATH: () => (/* binding */ LEGACY_CONVERSATIONS_MESSAGING_PATH),
/* harmony export */   LEGACY_CONVERSATIONS_PATH: () => (/* binding */ LEGACY_CONVERSATIONS_PATH),
/* harmony export */   LEGACY_CONVERSATIONS_REVIEW_MANAGEMENT_PATH: () => (/* binding */ LEGACY_CONVERSATIONS_REVIEW_MANAGEMENT_PATH),
/* harmony export */   LEGACY_CONVERSATIONS_REVIEW_SEND_INVITE_PATH: () => (/* binding */ LEGACY_CONVERSATIONS_REVIEW_SEND_INVITE_PATH),
/* harmony export */   LEGACY_VISIBILITY_BULK_UPDATE_PATH: () => (/* binding */ LEGACY_VISIBILITY_BULK_UPDATE_PATH),
/* harmony export */   LEGACY_VISIBILITY_DIFFUSION_PATH: () => (/* binding */ LEGACY_VISIBILITY_DIFFUSION_PATH),
/* harmony export */   LEGACY_VISIBILITY_LOCATION_ADD_PATH: () => (/* binding */ LEGACY_VISIBILITY_LOCATION_ADD_PATH),
/* harmony export */   LEGACY_VISIBILITY_LOCATION_EDIT_PATH: () => (/* binding */ LEGACY_VISIBILITY_LOCATION_EDIT_PATH),
/* harmony export */   LEGACY_VISIBILITY_LOCATION_PATH: () => (/* binding */ LEGACY_VISIBILITY_LOCATION_PATH),
/* harmony export */   LEGACY_VISIBILITY_PATH: () => (/* binding */ LEGACY_VISIBILITY_PATH),
/* harmony export */   LEGACY_VISIBILITY_POSTS_PATH: () => (/* binding */ LEGACY_VISIBILITY_POSTS_PATH),
/* harmony export */   LISTINGS_PATH_TOKEN: () => (/* binding */ LISTINGS_PATH_TOKEN),
/* harmony export */   LOCATIONS_PATH_TOKEN: () => (/* binding */ LOCATIONS_PATH_TOKEN),
/* harmony export */   LOG_OUT_PATH: () => (/* binding */ LOG_OUT_PATH),
/* harmony export */   LOST_PASSWORD_PATH_TOKEN: () => (/* binding */ LOST_PASSWORD_PATH_TOKEN),
/* harmony export */   MAIN_PATH_TOKEN: () => (/* binding */ MAIN_PATH_TOKEN),
/* harmony export */   MESSAGES_PATH_TOKEN: () => (/* binding */ MESSAGES_PATH_TOKEN),
/* harmony export */   MESSAGE_REPLY_TEMPLATES_PATH_TOKEN: () => (/* binding */ MESSAGE_REPLY_TEMPLATES_PATH_TOKEN),
/* harmony export */   MESSAGING_PATH_TOKEN: () => (/* binding */ MESSAGING_PATH_TOKEN),
/* harmony export */   MESSAGING_PRIVACY_POLICY_PATH: () => (/* binding */ MESSAGING_PRIVACY_POLICY_PATH),
/* harmony export */   NOTIFICATIONS_PATH_TOKEN: () => (/* binding */ NOTIFICATIONS_PATH_TOKEN),
/* harmony export */   NOT_FOUND_PATH: () => (/* binding */ NOT_FOUND_PATH),
/* harmony export */   PATH_PARAM_TOKEN: () => (/* binding */ PATH_PARAM_TOKEN),
/* harmony export */   PERMISSIONS_PATH_TOKEN: () => (/* binding */ PERMISSIONS_PATH_TOKEN),
/* harmony export */   PLATFORMS_PATH_TOKEN: () => (/* binding */ PLATFORMS_PATH_TOKEN),
/* harmony export */   POSTS_PATH_TOKEN: () => (/* binding */ POSTS_PATH_TOKEN),
/* harmony export */   PRIVACY_MESSAGING_PATH: () => (/* binding */ PRIVACY_MESSAGING_PATH),
/* harmony export */   PRIVACY_PATH: () => (/* binding */ PRIVACY_PATH),
/* harmony export */   PROFILE_PATH_TOKEN: () => (/* binding */ PROFILE_PATH_TOKEN),
/* harmony export */   RANKING_ANALYTICS_PATH: () => (/* binding */ RANKING_ANALYTICS_PATH),
/* harmony export */   RANKING_PATH_TOKEN: () => (/* binding */ RANKING_PATH_TOKEN),
/* harmony export */   REPLY_TEMPLATES_PATH_TOKEN: () => (/* binding */ REPLY_TEMPLATES_PATH_TOKEN),
/* harmony export */   RESET_PASSWORD_PATH_TOKEN: () => (/* binding */ RESET_PASSWORD_PATH_TOKEN),
/* harmony export */   REVIEWS_PATH_TOKEN: () => (/* binding */ REVIEWS_PATH_TOKEN),
/* harmony export */   ROOT_PATH: () => (/* binding */ ROOT_PATH),
/* harmony export */   SEND_INVITE_PATH_TOKEN: () => (/* binding */ SEND_INVITE_PATH_TOKEN),
/* harmony export */   SETTINGS_CHATBOT_PATH: () => (/* binding */ SETTINGS_CHATBOT_PATH),
/* harmony export */   SETTINGS_INTEGRATIONS_API_KEYS_PATHNAME: () => (/* binding */ SETTINGS_INTEGRATIONS_API_KEYS_PATHNAME),
/* harmony export */   SETTINGS_INTEGRATIONS_CUSTOM_FIELDS_PATHNAME: () => (/* binding */ SETTINGS_INTEGRATIONS_CUSTOM_FIELDS_PATHNAME),
/* harmony export */   SETTINGS_INTEGRATIONS_PATHNAME: () => (/* binding */ SETTINGS_INTEGRATIONS_PATHNAME),
/* harmony export */   SETTINGS_MAIN_INVOICES_PATHNAME: () => (/* binding */ SETTINGS_MAIN_INVOICES_PATHNAME),
/* harmony export */   SETTINGS_MAIN_NOTIFICATIONS_PATHNAME: () => (/* binding */ SETTINGS_MAIN_NOTIFICATIONS_PATHNAME),
/* harmony export */   SETTINGS_MAIN_PATHNAME: () => (/* binding */ SETTINGS_MAIN_PATHNAME),
/* harmony export */   SETTINGS_MAIN_PROFILE_PATHNAME: () => (/* binding */ SETTINGS_MAIN_PROFILE_PATHNAME),
/* harmony export */   SETTINGS_MESSAGES_CHATBOTS_PATHNAME: () => (/* binding */ SETTINGS_MESSAGES_CHATBOTS_PATHNAME),
/* harmony export */   SETTINGS_MESSAGES_CHAT_PREFERENCES_PATHNAME: () => (/* binding */ SETTINGS_MESSAGES_CHAT_PREFERENCES_PATHNAME),
/* harmony export */   SETTINGS_MESSAGES_CONVERSATION_STARTERS_PATHNAME: () => (/* binding */ SETTINGS_MESSAGES_CONVERSATION_STARTERS_PATHNAME),
/* harmony export */   SETTINGS_MESSAGES_CONVERSATION_STARTERS_V2_PATHNAME: () => (/* binding */ SETTINGS_MESSAGES_CONVERSATION_STARTERS_V2_PATHNAME),
/* harmony export */   SETTINGS_MESSAGES_PATH: () => (/* binding */ SETTINGS_MESSAGES_PATH),
/* harmony export */   SETTINGS_MESSAGES_PATHNAME: () => (/* binding */ SETTINGS_MESSAGES_PATHNAME),
/* harmony export */   SETTINGS_MESSAGES_PATH_TOKEN: () => (/* binding */ SETTINGS_MESSAGES_PATH_TOKEN),
/* harmony export */   SETTINGS_MESSAGES_REPLY_TEMPLATES_PATHNAME: () => (/* binding */ SETTINGS_MESSAGES_REPLY_TEMPLATES_PATHNAME),
/* harmony export */   SETTINGS_MESSAGES_WHATSAPP_PATHNAME: () => (/* binding */ SETTINGS_MESSAGES_WHATSAPP_PATHNAME),
/* harmony export */   SETTINGS_PATH: () => (/* binding */ SETTINGS_PATH),
/* harmony export */   SETTINGS_PATH_TOKEN: () => (/* binding */ SETTINGS_PATH_TOKEN),
/* harmony export */   SETTINGS_PLATFORMS_CONNECTION_PATHNAME: () => (/* binding */ SETTINGS_PLATFORMS_CONNECTION_PATHNAME),
/* harmony export */   SETTINGS_PLATFORMS_GOOGLE_VERIFICATION_PATHNAME: () => (/* binding */ SETTINGS_PLATFORMS_GOOGLE_VERIFICATION_PATHNAME),
/* harmony export */   SETTINGS_PLATFORMS_PATHNAME: () => (/* binding */ SETTINGS_PLATFORMS_PATHNAME),
/* harmony export */   SETTINGS_REVIEWS_AUTO_REPLY_PATHNAME: () => (/* binding */ SETTINGS_REVIEWS_AUTO_REPLY_PATHNAME),
/* harmony export */   SETTINGS_REVIEWS_AUTO_REPLY_WITHOUT_COMMENT_PATHNAME: () => (/* binding */ SETTINGS_REVIEWS_AUTO_REPLY_WITHOUT_COMMENT_PATHNAME),
/* harmony export */   SETTINGS_REVIEWS_AUTO_REPLY_WITH_COMMENT_PATHNAME: () => (/* binding */ SETTINGS_REVIEWS_AUTO_REPLY_WITH_COMMENT_PATHNAME),
/* harmony export */   SETTINGS_REVIEWS_PATHNAME: () => (/* binding */ SETTINGS_REVIEWS_PATHNAME),
/* harmony export */   SETTINGS_REVIEWS_REPLY_TEMPLATES_PATHNAME: () => (/* binding */ SETTINGS_REVIEWS_REPLY_TEMPLATES_PATHNAME),
/* harmony export */   SETTINGS_TEAM_GROUPS_PATHNAME: () => (/* binding */ SETTINGS_TEAM_GROUPS_PATHNAME),
/* harmony export */   SETTINGS_TEAM_PATHNAME: () => (/* binding */ SETTINGS_TEAM_PATHNAME),
/* harmony export */   SETTINGS_TEAM_PERMISSIONS_PATHNAME: () => (/* binding */ SETTINGS_TEAM_PERMISSIONS_PATHNAME),
/* harmony export */   SETTINGS_TEAM_USERS_PATHNAME: () => (/* binding */ SETTINGS_TEAM_USERS_PATHNAME),
/* harmony export */   SETTINGS_TEAM_USER_ADD_PATHNAME: () => (/* binding */ SETTINGS_TEAM_USER_ADD_PATHNAME),
/* harmony export */   SSO_PATH_TOKEN: () => (/* binding */ SSO_PATH_TOKEN),
/* harmony export */   TEAM_PATH_TOKEN: () => (/* binding */ TEAM_PATH_TOKEN),
/* harmony export */   USERS_PATH_TOKEN: () => (/* binding */ USERS_PATH_TOKEN),
/* harmony export */   V2: () => (/* binding */ V2),
/* harmony export */   VERIFICATION_PATH_TOKEN: () => (/* binding */ VERIFICATION_PATH_TOKEN),
/* harmony export */   VISIBILITY_BULK_UPDATE_PATH: () => (/* binding */ VISIBILITY_BULK_UPDATE_PATH),
/* harmony export */   VISIBILITY_DIFFUSION_PATH: () => (/* binding */ VISIBILITY_DIFFUSION_PATH),
/* harmony export */   VISIBILITY_LOCATION_ADD_PATH: () => (/* binding */ VISIBILITY_LOCATION_ADD_PATH),
/* harmony export */   VISIBILITY_LOCATION_EDIT_PATH: () => (/* binding */ VISIBILITY_LOCATION_EDIT_PATH),
/* harmony export */   VISIBILITY_LOCATION_PATH: () => (/* binding */ VISIBILITY_LOCATION_PATH),
/* harmony export */   VISIBILITY_PATH: () => (/* binding */ VISIBILITY_PATH),
/* harmony export */   VISIBILITY_PATH_TOKEN: () => (/* binding */ VISIBILITY_PATH_TOKEN),
/* harmony export */   VISIBILITY_POSTS_PATH: () => (/* binding */ VISIBILITY_POSTS_PATH),
/* harmony export */   WHATSAPP_PHONE_NUMBER_ID: () => (/* binding */ WHATSAPP_PHONE_NUMBER_ID),
/* harmony export */   WHATSAPP_SETTINGS_PATH_TOKEN: () => (/* binding */ WHATSAPP_SETTINGS_PATH_TOKEN),
/* harmony export */   WITHOUT_COMMENT_PATH_TOKEN: () => (/* binding */ WITHOUT_COMMENT_PATH_TOKEN),
/* harmony export */   WITH_COMMENT_PATH_TOKEN: () => (/* binding */ WITH_COMMENT_PATH_TOKEN)
/* harmony export */ });
/* harmony import */ var app_pages_settingsV2_subPages_Team_components_UserManagement_utils_enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/pages/settingsV2/subPages/Team/components/UserManagement/utils/enums */ "./javascript/app/pages/settingsV2/subPages/Team/components/UserManagement/utils/enums.ts");
/* Path tokens
 */


const LOCATIONS_PATH_TOKEN = 'locations';
const DIFFUSION_PATH_TOKEN = 'diffusion';
const BULK_UPDATE_PATH_TOKEN = 'bulk-update';
const POSTS_PATH_TOKEN = 'posts';
const MESSAGING_PATH_TOKEN = 'messaging';
const CONVERSATION_STARTERS_PATH_TOKEN = 'conversation-starters';
const CHATBOT_PATH_TOKEN = 'chatbots';
const REVIEWS_PATH_TOKEN = 'reviews';
const AUTO_REPLY_PATH_TOKEN = 'auto-reply';
const VISIBILITY_PATH_TOKEN = 'visibility';
const RANKING_PATH_TOKEN = 'ranking';
const SETTINGS_PATH_TOKEN = 'settings';
const SEND_INVITE_PATH_TOKEN = 'send-invite';
const ACCOUNT_PATH_TOKEN = 'account';
const PROFILE_PATH_TOKEN = 'profile';
const NOTIFICATIONS_PATH_TOKEN = 'notifications';
const REPLY_TEMPLATES_PATH_TOKEN = 'reply-templates';
const TEAM_PATH_TOKEN = 'team';
const PERMISSIONS_PATH_TOKEN = 'permissions';
const USERS_PATH_TOKEN = 'users';
const CONFIGURATION_PATH_TOKEN = 'configuration';
const VERIFICATION_PATH_TOKEN = 'google-verification';
const CONNECTION_PATH_TOKEN = 'connection';
const CONNECTIONS_PATH_TOKEN = 'connections';
const CUSTOM_FIELDS_PATH_TOKEN = 'custom-fields';
const GROUPS_SETTINGS_PATH_TOKEN = 'groups';
const API_KEYS_PATH_TOKEN = 'api-keys';
const ANALYTICS_PATH_TOKEN = 'analytics';
const LISTINGS_PATH_TOKEN = 'listings';
const BUSINESSES_PATH_TOKEN = 'businesses';
const FIELD_PERMISSIONS_PATH_TOKEN = 'field-permissions';
const API_KEY_MANAGER_PATH_TOKEN = 'api-key-manager';
const ADD_PATH_TOKEN = 'add';
const INVITE_PATH_TOKEN = 'invite';
const RESET_PASSWORD_PATH_TOKEN = 'reset_password';
const LOST_PASSWORD_PATH_TOKEN = 'lost_password';
const SSO_PATH_TOKEN = 'sso';
const BUSINESS_ID = 'businessId';
const ID_PARAM_TOKEN = 'id';
const PATH_PARAM_TOKEN = 'token';
const INVOICE_PATH_TOKEN = 'invoice';
const INVOICES_PATH_TOKEN = 'invoices';
const WHATSAPP_SETTINGS_PATH_TOKEN = 'whatsapp';
const WHATSAPP_PHONE_NUMBER_ID = 'whatsappPhoneNumberId';
const V2 = 'v2';
const MAIN_PATH_TOKEN = 'main';
const INTEGRATIONS_PATH_TOKEN = 'integrations';
const MESSAGES_PATH_TOKEN = 'messages';
const PLATFORMS_PATH_TOKEN = 'platforms';
const GOOGLE_VERIFICATIO_PATH_TOKEN = 'google-verification';
const CHAT_PREFERENCES_PATH_TOKEN = 'chat-preferences';
const WITHOUT_COMMENT_PATH_TOKEN = 'without-comment';
const WITH_COMMENT_PATH_TOKEN = 'with-comment';
const CHATBOTS_PATH_TOKEN = 'chatbots';
const SETTINGS_MESSAGES_PATH_TOKEN = 'messages';
const MESSAGE_REPLY_TEMPLATES_PATH_TOKEN = 'reply-templates';
const CUSTOMER_EXPERIENCE_PATH_TOKEN = 'customer-experience';

/* Paths
 */

// VISIBILITY
const VISIBILITY_PATH = '/visibility';
const VISIBILITY_LOCATION_PATH = '/visibility/locations'; // locations
const VISIBILITY_LOCATION_ADD_PATH = `${VISIBILITY_LOCATION_PATH}/add`;
const VISIBILITY_LOCATION_EDIT_PATH = `${VISIBILITY_LOCATION_PATH}/:${BUSINESS_ID}`;
const VISIBILITY_BULK_UPDATE_PATH = '/visibility/bulk-update'; // bulk-update
const VISIBILITY_DIFFUSION_PATH = '/visibility/diffusion'; // diffusion
const VISIBILITY_POSTS_PATH = '/visibility/posts'; // posts

// CONVERSATIONS
const CONVERSATIONS_PATH = '/conversations';
const CONVERSATIONS_MESSAGING_PATH = `${CONVERSATIONS_PATH}/messaging`; // messaging
const CONVERSATIONS_REVIEW_MANAGEMENT_PATH = `${CONVERSATIONS_PATH}/reviews`; // reviews
const CONVERSATIONS_REVIEW_SEND_INVITE_PATH = '/conversations/send-invite'; // send-invite

// CUSTOMER EXPERIENCE
const CUSTOMER_EXPERIENCE_PATH = '/customer-experience';
const CUSTOMER_EXPERIENCE_CLIENT_REVIEWS_PATH = `${CUSTOMER_EXPERIENCE_PATH}/reviews`; // reviews & feedback management
const CUSTOMER_EXPERIENCE_SEND_INVITE_PATH = `${CUSTOMER_EXPERIENCE_PATH}/send-invite`; // review booster

// ANALYTICS
const ANALYTICS_PATH = '/analytics';
const ANALYTICS_VISIBILITY_PATH = `${ANALYTICS_PATH}/visibility`; // visibility
const ANALYTICS_REVIEW_PATH = `${ANALYTICS_PATH}/reviews`; // reviews
const RANKING_ANALYTICS_PATH = `${ANALYTICS_PATH}/ranking`;

// SETTINGS
const SETTINGS_PATH = '/settings';

// messaging
const SETTINGS_MESSAGES_PATH = `${SETTINGS_PATH}/messages`;
const SETTINGS_CHATBOT_PATH = `${SETTINGS_MESSAGES_PATH}/chatbots`;

// OTHERS
const ROOT_PATH = '/';
const LOG_OUT_PATH = '/logout';
const NOT_FOUND_PATH = '/404';
const COMPONENT_TEST_PATH = '/component_test';
const CONNECTION_PATH = '/connection';
const CONNECTION_RESET_PASSWORD_TEMPLATE_PATH = `/connection/reset_password/:${PATH_PARAM_TOKEN}`;
const CONNECTION_INVITE_PATH = `/connection/invite/:${PATH_PARAM_TOKEN}`;
const CONNECTION_LOST_PASSWORD_PATH = '/connection/lost_password';
const CONNECTION_LOGIN_SSO_PATH = '/connection/sso';

// OAUTH2
const GOOGLE_OAUTH2_START_PATH = '/oauth2/google/start';
const FACEBOOK_OAUTH2_START_PATH = '/oauth2/facebook/start';

// PRIVACY POLICY
const PRIVACY_PATH = '/privacy';
const PRIVACY_MESSAGING_PATH = `${PRIVACY_PATH}/messaging`;
const MESSAGING_PRIVACY_POLICY_PATH = `${PRIVACY_MESSAGING_PATH}/:id`;

// LEGACY
const LEGACY_VISIBILITY_PATH = '/knowledge';
const LEGACY_VISIBILITY_LOCATION_PATH = '/knowledge/businesses';
const LEGACY_VISIBILITY_LOCATION_ADD_PATH = '/knowledge/businesses/add';
const LEGACY_VISIBILITY_LOCATION_EDIT_PATH = `/knowledge/businesses/:${BUSINESS_ID}`;
const LEGACY_VISIBILITY_BULK_UPDATE_PATH = '/knowledge/bulk_update';
const LEGACY_VISIBILITY_DIFFUSION_PATH = '/presence/listings';
const LEGACY_VISIBILITY_POSTS_PATH = '/knowledge/posts';
const LEGACY_CONVERSATIONS_PATH = '/review';
const LEGACY_CONVERSATIONS_MESSAGING_PATH = '/review/messaging';
const LEGACY_CONVERSATIONS_REVIEW_MANAGEMENT_PATH = '/review/reviews';
const LEGACY_CONVERSATIONS_REVIEW_SEND_INVITE_PATH = '/review/send-invite';
const LEGACY_ANALYTICS_PATH = '/presence';
const LEGACY_ANALYTICS_VISIBILITY_PATH = '/presence/analytics';
const LEGACY_ANALYTICS_REVIEW_PATH = '/review/analytics';

// Messages section
const SETTINGS_MESSAGES_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${MESSAGES_PATH_TOKEN}`;
const SETTINGS_MESSAGES_CHAT_PREFERENCES_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${MESSAGES_PATH_TOKEN}/${CHAT_PREFERENCES_PATH_TOKEN}`;
const SETTINGS_MESSAGES_REPLY_TEMPLATES_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${MESSAGES_PATH_TOKEN}/${REPLY_TEMPLATES_PATH_TOKEN}`;
const SETTINGS_MESSAGES_CONVERSATION_STARTERS_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${MESSAGES_PATH_TOKEN}/${CONVERSATION_STARTERS_PATH_TOKEN}`;
const SETTINGS_MESSAGES_CONVERSATION_STARTERS_V2_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${MESSAGES_PATH_TOKEN}/${CONVERSATION_STARTERS_PATH_TOKEN}/${V2}`;
const SETTINGS_MESSAGES_CHATBOTS_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${MESSAGES_PATH_TOKEN}/${CHATBOTS_PATH_TOKEN}`;
const SETTINGS_MESSAGES_WHATSAPP_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${MESSAGES_PATH_TOKEN}/${WHATSAPP_SETTINGS_PATH_TOKEN}`;

// Main section
const SETTINGS_MAIN_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${MAIN_PATH_TOKEN}`;
const SETTINGS_MAIN_PROFILE_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${MAIN_PATH_TOKEN}/${PROFILE_PATH_TOKEN}`;
const SETTINGS_MAIN_NOTIFICATIONS_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${MAIN_PATH_TOKEN}/${NOTIFICATIONS_PATH_TOKEN}`;
const SETTINGS_MAIN_INVOICES_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${MAIN_PATH_TOKEN}/${INVOICES_PATH_TOKEN}`;

// Team section
const SETTINGS_TEAM_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${TEAM_PATH_TOKEN}`;
const SETTINGS_TEAM_USERS_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${TEAM_PATH_TOKEN}/${USERS_PATH_TOKEN}`;
const SETTINGS_TEAM_USER_ADD_PATHNAME = `${SETTINGS_TEAM_USERS_PATHNAME}?${app_pages_settingsV2_subPages_Team_components_UserManagement_utils_enums__WEBPACK_IMPORTED_MODULE_0__.UserListQueryKeys.USER_EDIT}=${app_pages_settingsV2_subPages_Team_components_UserManagement_utils_enums__WEBPACK_IMPORTED_MODULE_0__.USER_ID_CREATE}`;
const SETTINGS_TEAM_PERMISSIONS_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${TEAM_PATH_TOKEN}/${PERMISSIONS_PATH_TOKEN}`;
const SETTINGS_TEAM_GROUPS_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${TEAM_PATH_TOKEN}/${GROUPS_SETTINGS_PATH_TOKEN}`;

// Reviews section
const SETTINGS_REVIEWS_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${REVIEWS_PATH_TOKEN}`;
const SETTINGS_REVIEWS_REPLY_TEMPLATES_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${REVIEWS_PATH_TOKEN}/${REPLY_TEMPLATES_PATH_TOKEN}`;
const SETTINGS_REVIEWS_AUTO_REPLY_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${REVIEWS_PATH_TOKEN}/${AUTO_REPLY_PATH_TOKEN}`;
const SETTINGS_REVIEWS_AUTO_REPLY_WITHOUT_COMMENT_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${REVIEWS_PATH_TOKEN}/${AUTO_REPLY_PATH_TOKEN}/${WITHOUT_COMMENT_PATH_TOKEN}`;
const SETTINGS_REVIEWS_AUTO_REPLY_WITH_COMMENT_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${REVIEWS_PATH_TOKEN}/${AUTO_REPLY_PATH_TOKEN}/${WITH_COMMENT_PATH_TOKEN}`;

// Platforms section
const SETTINGS_PLATFORMS_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${PLATFORMS_PATH_TOKEN}`;
const SETTINGS_PLATFORMS_CONNECTION_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${PLATFORMS_PATH_TOKEN}/${CONNECTION_PATH_TOKEN}`;
const SETTINGS_PLATFORMS_GOOGLE_VERIFICATION_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${PLATFORMS_PATH_TOKEN}/${GOOGLE_VERIFICATIO_PATH_TOKEN}`;

// Integrations section
const SETTINGS_INTEGRATIONS_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${INTEGRATIONS_PATH_TOKEN}`;
const SETTINGS_INTEGRATIONS_CUSTOM_FIELDS_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${INTEGRATIONS_PATH_TOKEN}/${CUSTOM_FIELDS_PATH_TOKEN}`;
const SETTINGS_INTEGRATIONS_API_KEYS_PATHNAME = `/${SETTINGS_PATH_TOKEN}/${INTEGRATIONS_PATH_TOKEN}/${API_KEYS_PATH_TOKEN}`;

/***/ }),

/***/ "./javascript/sdk/IFrameWrapper.ts":
/*!*****************************************!*\
  !*** ./javascript/sdk/IFrameWrapper.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IFrameWrapper: () => (/* binding */ IFrameWrapper),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var app_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/config */ "./javascript/app/config.ts");
/* harmony import */ var _exceptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exceptions */ "./javascript/sdk/exceptions.ts");
/* harmony import */ var _htmlElements_defaultStyle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./htmlElements/defaultStyle */ "./javascript/sdk/htmlElements/defaultStyle.ts");
/* harmony import */ var _htmlElements_errorDiv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./htmlElements/errorDiv */ "./javascript/sdk/htmlElements/errorDiv.ts");
/* harmony import */ var _htmlElements_iFrame__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./htmlElements/iFrame */ "./javascript/sdk/htmlElements/iFrame.ts");
/* harmony import */ var _htmlElements_loadingDiv__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./htmlElements/loadingDiv */ "./javascript/sdk/htmlElements/loadingDiv.ts");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }






// Height in pixels
const CONTAINER_DEFAULT_HEIGHT = 900;

/**
 * Class responsible for:
 *   - handling the HTML elements inserted by Partoo SDK
 *   - posting JS Message to Partoo App inside the iFrame
 *   - updating URL of the iFrame
 */
class IFrameWrapper {
  constructor() {
    // Iframe containing the Partoo App
    _defineProperty(this, "iFrame", void 0);
    // Div displayed when Partoo App is loading
    _defineProperty(this, "loadingDiv", void 0);
    // Div displayed when the is an error inside Partoo App
    _defineProperty(this, "errorDiv", void 0);
    // Div containing all the HTML elements
    _defineProperty(this, "containerDiv", void 0);
    _defineProperty(this, "containerHeight", CONTAINER_DEFAULT_HEIGHT);
    _defineProperty(this, "heightDifferenceBetweenIFrameAndItsContent", 0);
    /**
     * Insert 3 HTML elements:
     *   - `loadingDiv`, div displayed when Partoo App is loading
     *   - `errorDiv`, div displayed when the is an error inside Partoo App
     *   - `Iframe`, iFrame containing the Partoo App
     * Display the `loadingDiv`
     *
     * @param elementId {string} Id of the div in which we are going to insert the HTML elements
     */
    _defineProperty(this, "insert", elementId => {
      const receivingElement = document.getElementById(elementId);
      if (!receivingElement) {
        // eslint-disable-next-line @typescript-eslint/no-throw-literal
        throw new _exceptions__WEBPACK_IMPORTED_MODULE_1__.InsertException(`There is no div whose id is ${elementId}`);
      }
      receivingElement.innerHTML = _htmlElements_loadingDiv__WEBPACK_IMPORTED_MODULE_5__["default"] + _htmlElements_errorDiv__WEBPACK_IMPORTED_MODULE_3__["default"] + _htmlElements_iFrame__WEBPACK_IMPORTED_MODULE_4__["default"] + _htmlElements_defaultStyle__WEBPACK_IMPORTED_MODULE_2__["default"];
      this.containerDiv = receivingElement;
      this.iFrame = document.getElementById('partoo-iframe');
      this.loadingDiv = document.getElementById('partoo-loading');
      this.errorDiv = document.getElementById('partoo-error');
    });
    /**
     * Resize container div height to match Iframe content height
     *
     * @param height {number} Height of iFrame content
     */
    _defineProperty(this, "resizeContainerToIFrameHeight", height => {
      if (this.containerHeight < height && this.containerHeight - height !== this.heightDifferenceBetweenIFrameAndItsContent) {
        this.heightDifferenceBetweenIFrameAndItsContent = this.containerHeight - height;
        this.containerDiv.style.height = `${height}px`;
        this.containerHeight = height;
      } else {
        this.containerDiv.style.height = `${this.containerHeight}px`;
      }
    });
    /**
     * Update the url attribute of the iFrame
     *
     * @param url {string}
     */
    _defineProperty(this, "updateIframeUrl", url => this.iFrame.setAttribute('src', url));
    /**
     * Hide iFrame & error view & display loading view
     */
    _defineProperty(this, "displayLoadingView", () => {
      this.containerDiv.style.height = '';
      this.iFrame.style.visibility = 'hidden';
      this.errorDiv.style.display = 'none';
      this.loadingDiv.style.display = 'block';
    });
    /**
     * Hide loading & error views & display iFrame
     */
    _defineProperty(this, "displayIframe", () => {
      this.containerHeight = CONTAINER_DEFAULT_HEIGHT;
      this.iFrame.style.visibility = 'visible';
      this.errorDiv.style.display = 'none';
      this.loadingDiv.style.display = 'none';
    });
    /**
     * Hide iframe & loading view & display error view
     */
    _defineProperty(this, "displayErrorView", () => {
      this.containerDiv.style.height = '';
      this.iFrame.style.visibility = 'hidden';
      this.loadingDiv.style.display = 'none';
      this.errorDiv.style.display = 'block';
    });
    /**
     * Checks that iFrame content is not null
     *
     * @returns {boolean}
     */
    _defineProperty(this, "isIframeInserted", () => !!this.iFrame.contentWindow);
    /**
     * Post a JS message to the Partoo React App located inside the iFrame.
     *
     * @param message JsApiMessage
     * @returns {null|*}
     */
    _defineProperty(this, "postMessage", message => {
      var _this$iFrame$contentW;
      if (!this.isIframeInserted()) {
        return null;
      }
      return (_this$iFrame$contentW = this.iFrame.contentWindow) === null || _this$iFrame$contentW === void 0 ? void 0 : _this$iFrame$contentW.postMessage(message, app_config__WEBPACK_IMPORTED_MODULE_0__.BASE_URL);
    });
  }
  /**
   * Remove all the HTML elements contained inside div identifier by `elementId`
   *
   * @param elementId {string}
   */
  static remove(elementId) {
    const element = document.getElementById(elementId);
    if (element) {
      element.innerHTML = '';
    }
  }
}
const iframeWrapper = new IFrameWrapper();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (iframeWrapper);

/***/ }),

/***/ "./javascript/sdk/MessageListener.mappers.ts":
/*!***************************************************!*\
  !*** ./javascript/sdk/MessageListener.mappers.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sagas_actionCreators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sagas/actionCreators */ "./javascript/sdk/sagas/actionCreators.ts");

const mapDispatchToDispatchers = dispatch => ({
  callCallback: (action, inputs) => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_0__.handleCallbackCalled)(action, inputs)),
  styleOverridden: () => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_0__.handleStyleIsOverridden)()),
  handlePageHeight: height => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_0__.handlePageHeight)(height)),
  handlePageChanged: url => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_0__.handlePageChanged)(url)),
  handleJsLoaded: () => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_0__.handleJSHasLoaded)()),
  handleError: errorType => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_0__.handleError)(errorType)),
  handleUserIsLoggedOut: () => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_0__.handleUserIsLoggedOut)()),
  handleUserIsLoggedIn: () => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_0__.handleUserIsLoggedIn)())
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([null, mapDispatchToDispatchers]);

/***/ }),

/***/ "./javascript/sdk/MessageListener.ts":
/*!*******************************************!*\
  !*** ./javascript/sdk/MessageListener.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var app_SDKBridge_messages_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/SDKBridge/messages/types */ "./javascript/app/SDKBridge/messages/types.ts");
/* harmony import */ var _redux_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./redux-sdk */ "./javascript/sdk/redux-sdk.ts");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


/**
 * Class responsible for listening to JS message sent by Partoo App &
 * dispatching Redux action accordingly
 */
class MessageListener extends _redux_sdk__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();
    _defineProperty(this, "eventListener", void 0);
    /**
     * Dispatch Redux action according to JS Message
     *
     * @param data
     * @returns {void|*}
     */
    _defineProperty(this, "dispatchMessage", ({
      data
    }) => {
      switch (data.type) {
        case app_SDKBridge_messages_types__WEBPACK_IMPORTED_MODULE_0__.CALLBACK_CALLED:
          return this.dispatchers.callCallback(data.action, data.inputs);
        case app_SDKBridge_messages_types__WEBPACK_IMPORTED_MODULE_0__.STYLE_OVERRIDDEN:
          return this.dispatchers.styleOverridden();
        case app_SDKBridge_messages_types__WEBPACK_IMPORTED_MODULE_0__.PAGE_SIZE_GIVEN:
          return this.dispatchers.handlePageHeight(data.height);
        case app_SDKBridge_messages_types__WEBPACK_IMPORTED_MODULE_0__.PAGE_CHANGED:
          return this.dispatchers.handlePageChanged(data.url);
        case app_SDKBridge_messages_types__WEBPACK_IMPORTED_MODULE_0__.IFRAME_JS_LOADED:
          return this.dispatchers.handleJsLoaded();
        case app_SDKBridge_messages_types__WEBPACK_IMPORTED_MODULE_0__.USER_IS_LOGGED_IN:
          return this.dispatchers.handleUserIsLoggedIn();
        case app_SDKBridge_messages_types__WEBPACK_IMPORTED_MODULE_0__.USER_IS_LOGGED_OUT:
          return this.dispatchers.handleUserIsLoggedOut();
        case app_SDKBridge_messages_types__WEBPACK_IMPORTED_MODULE_0__.ERROR_400_OCCURRED_IN_IFRAME:
          return this.dispatchers.handleError(400);
        case app_SDKBridge_messages_types__WEBPACK_IMPORTED_MODULE_0__.ERROR_403_OCCURRED_IN_IFRAME:
          return this.dispatchers.handleError(403);
        case app_SDKBridge_messages_types__WEBPACK_IMPORTED_MODULE_0__.ERROR_404_OCCURRED_IN_IFRAME:
          return this.dispatchers.handleError(404);
        case app_SDKBridge_messages_types__WEBPACK_IMPORTED_MODULE_0__.ERROR_500_OCCURRED_IN_IFRAME:
          return this.dispatchers.handleError(500);
        default:
          // eslint-disable-next-line no-console
          return console.warn(' No action configured for message', data);
      }
    });
    _defineProperty(this, "destroyListener", () => {
      window.removeEventListener('message', this.eventListener);
    });
    this.eventListener = message => this.dispatchMessage(message);
    window.addEventListener('message', this.eventListener);
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MessageListener);

/***/ }),

/***/ "./javascript/sdk/PartooSDK.mappers.ts":
/*!*********************************************!*\
  !*** ./javascript/sdk/PartooSDK.mappers.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _reducers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reducers */ "./javascript/sdk/reducers/index.ts");
/* harmony import */ var _reducers_page__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reducers/page */ "./javascript/sdk/reducers/page.ts");
/* harmony import */ var _sagas_actionCreators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sagas/actionCreators */ "./javascript/sdk/sagas/actionCreators.ts");



const mapReduxStateToClassState = state => ({
  isLoggingOut: (0,_reducers__WEBPACK_IMPORTED_MODULE_0__.userStatusSelector)(state) === _reducers_page__WEBPACK_IMPORTED_MODULE_1__.UserStatuses.LOGGING_OUT,
  isLoggingIn: (0,_reducers__WEBPACK_IMPORTED_MODULE_0__.userStatusSelector)(state) === _reducers_page__WEBPACK_IMPORTED_MODULE_1__.UserStatuses.LOGGING_IN
});
const mapDispatchToDispatchers = dispatch => ({
  login: userToken => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_2__.loginUser)(userToken)),
  logout: () => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_2__.logoutUser)()),
  setOptions: options => {
    dispatch((0,_reducers_page__WEBPACK_IMPORTED_MODULE_1__.updateOptions)(options));
    dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_2__.sendDisplayOptions)());
  },
  navigate: (route, seedData, additionalParams) => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_2__.navigateTo)(route, additionalParams, seedData)),
  back: () => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_2__.goBack)()),
  forward: () => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_2__.goForward)()),
  registerCallback: (action, callback) => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_2__.sendRegisteredCallback)(action, callback)),
  unregisterCallback: action => dispatch((0,_sagas_actionCreators__WEBPACK_IMPORTED_MODULE_2__.sendUnregisteredCallback)(action)),
  disableMessaging: () => dispatch((0,_reducers_page__WEBPACK_IMPORTED_MODULE_1__.messagingIsDisabled)())
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([mapReduxStateToClassState, mapDispatchToDispatchers]);

/***/ }),

/***/ "./javascript/sdk/PartooSDK.ts":
/*!*************************************!*\
  !*** ./javascript/sdk/PartooSDK.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isFunction.js");
/* harmony import */ var _exceptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exceptions */ "./javascript/sdk/exceptions.ts");
/* harmony import */ var _IFrameWrapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IFrameWrapper */ "./javascript/sdk/IFrameWrapper.ts");
/* harmony import */ var _redux_sdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./redux-sdk */ "./javascript/sdk/redux-sdk.ts");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }




/** List of actions for which we can define a callback */
const AVAILABLE_ACTIONS = {
  open_business: true,
  subscribe: true,
  business_created: true,
  business_advanced_settings_updated: true,
  business_infos_updated: true,
  business_contact_updated: true,
  business_description_updated: true,
  business_attributes_updated: true,
  business_links_updated: true,
  business_open_hours_updated: true,
  business_more_hours_updated: true,
  business_specific_hours_updated: true,
  business_address_updated: true,
  business_logo_updated: true,
  business_cover_updated: true,
  business_photos_updated: true,
  business_categories_updated: true,
  business_menu_updated: true,
  business_custom_fields_updated: true,
  error: true,
  no_eligible_business_click: true,
  pm_view_go_to_edit_click: true,
  pm_view_go_to_partner_connection_click: true,
  no_business_click: true
};
class PartooSDK extends _redux_sdk__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(messageListener, elementId) {
    super();
    _defineProperty(this, "messageListener", void 0);
    _defineProperty(this, "elementId", void 0);
    _defineProperty(this, "isBeingDestroyed", false);
    _defineProperty(this, "destroyCallback", null);
    /**
     * Set display options for intercom & the app
     * @param options Options
     * */
    _defineProperty(this, "setOptions", options => this.dispatchers.setOptions(options));
    /**
     * Log user inside Partoo Application using either an API key or a connection token
     *  Using an API key for logging is a deprecated behaviour
     *
     * @param userToken string Connection token or API key
     */
    _defineProperty(this, "login", userToken => this.dispatchers.login(userToken));
    /**
     * Go to a given route inside the Partoo App
     *
     * @param route
     * @param seedData
     * @param additionalParams
     */
    _defineProperty(this, "navigate", (route, seedData, additionalParams) => this.dispatchers.navigate(route, seedData, additionalParams));
    /**
     * Go back to the previous page inside Partoo App
     */
    _defineProperty(this, "back", () => this.dispatchers.back());
    /**
     * Go forward to the next page inside Partoo App (if we went back)
     */
    _defineProperty(this, "forward", () => this.dispatchers.forward());
    /**
     * Define a callback for Partoo App action.
     * If the action does not exists it raises NotOverridableException.
     * If the callback given is not a function, it raises NotAFunctionException.
     *
     * @param action string An event that can occur inside Partoo App
     * @param callback Function Callback to trigger when the action occurs
     * @throws NotOverridableException|NotAFunctionException
     */
    _defineProperty(this, "on", (action, callback) => {
      if (!PartooSDK.checkCallbackIsAvailable(action)) {
        // eslint-disable-next-line @typescript-eslint/no-throw-literal
        throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.NotOverridableException(`The given action ${action} is not available.`);
      }
      if (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(callback)) {
        // eslint-disable-next-line @typescript-eslint/no-throw-literal
        throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.NotAFunctionException('The given callback is not a function.');
      }
      this.dispatchers.registerCallback(action, callback);
    });
    /**
     * Cancel a callback for Partoo App action.
     * If the action does not exists it raises NotOverridableException.
     *
     * @param action string An event that can occur inside Partoo App
     * @throws NotOverridableException
     */
    _defineProperty(this, "off", action => {
      if (!PartooSDK.checkCallbackIsAvailable(action)) {
        // eslint-disable-next-line @typescript-eslint/no-throw-literal
        throw new _exceptions__WEBPACK_IMPORTED_MODULE_0__.NotOverridableException(`The given action ${action} is not available.`);
      }
      this.dispatchers.unregisterCallback(action);
    });
    _defineProperty(this, "destroy", (destroyCallback = null) => {
      this.destroyCallback = destroyCallback;
      this.dispatchers.logout();
    });
    this.messageListener = messageListener;
    this.elementId = elementId;
  }
  onStateChange(prevState, newState) {
    if (newState.isLoggingOut) {
      if (!this.isBeingDestroyed) {
        setTimeout(() => {
          this.messageListener.destroyListener();
          this.dispatchers.disableMessaging();
          _IFrameWrapper__WEBPACK_IMPORTED_MODULE_1__.IFrameWrapper.remove(this.elementId);
          // @ts-ignore
          delete this.messageListener;
          // @ts-ignore
          delete this.elementId;
          if (this.destroyCallback) {
            this.destroyCallback();
          }
        }, 200);
        this.isBeingDestroyed = true;
      }
    }
  }
  /**
   * Check if it is possible to define a callback for given action
   *
   * @param action {string} Action name
   * @returns {boolean}
   */
  static checkCallbackIsAvailable(action) {
    return AVAILABLE_ACTIONS[action];
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PartooSDK);

/***/ }),

/***/ "./javascript/sdk/exceptions.ts":
/*!**************************************!*\
  !*** ./javascript/sdk/exceptions.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InsertException: () => (/* binding */ InsertException),
/* harmony export */   NotAFunctionException: () => (/* binding */ NotAFunctionException),
/* harmony export */   NotOverridableException: () => (/* binding */ NotOverridableException),
/* harmony export */   RemoveException: () => (/* binding */ RemoveException),
/* harmony export */   RoutingException: () => (/* binding */ RoutingException),
/* harmony export */   UndefinedCallbackException: () => (/* binding */ UndefinedCallbackException)
/* harmony export */ });
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class PartooException {
  constructor(message) {
    _defineProperty(this, "message", void 0);
    this.message = message;
  }
}
class RoutingException extends PartooException {}
class InsertException extends PartooException {}
class RemoveException extends PartooException {}
class UndefinedCallbackException extends PartooException {}
class NotAFunctionException extends PartooException {}
class NotOverridableException extends PartooException {}

/***/ }),

/***/ "./javascript/sdk/htmlElements/defaultStyle.ts":
/*!*****************************************************!*\
  !*** ./javascript/sdk/htmlElements/defaultStyle.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const defautStyle = `
<style type="text/css">
    @-webkit-keyframes lds-microsoft {
      0% {
        -webkit-transform: rotate(0);
        transform: rotate(0);
      }
      100% {
        -webkit-transform: rotate(360deg);
        transform: rotate(360deg);
      }
    }
    @keyframes lds-microsoft {
      0% {
        -webkit-transform: rotate(0);
        transform: rotate(0);
      }
      100% {
        -webkit-transform: rotate(360deg);
        transform: rotate(360deg);
      }
    }
    #partoo-loading {
        visibility: visible;
        height: 200px;
        padding-top: 30%;
        padding-bottom: 30%;
        padding-left: 40%;
        background-color: white;
    }
    .lds-microsoft {
      position: relative;
      background-color: #00a2e8;
    }
    .partoo-error-container {
      height: 400px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .partoo-error {
      color: red;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-family: Helvetica, Arial, sans-serif;
      font-size: 30px;
      height: 200px;
    }
    .partoo-error-icon {
      margin-bottom: 20px;
    }
    .lds-microsoft div {
      position: absolute;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      -webkit-animation: lds-microsoft 1.5s cubic-bezier(0.5, 0, 0.5, 1) infinite;
      animation: lds-microsoft 1.5s cubic-bezier(0.5, 0, 0.5, 1) infinite;
    }
    .lds-microsoft div:nth-child(0) {
      background: rgb(0, 179, 253);
      top: 134.613px;
      left: 147.535px;
      -webkit-transform-origin: -47.535px -34.613px;
      transform-origin: -47.535px -34.613px;
      -webkit-animation-delay: 0s;
      animation-delay: 0s;
    }
    .lds-microsoft div:nth-child(1) {
      background: rgb(0, 179, 253);
      top: 147.535px;
      left: 134.613px;
      -webkit-transform-origin: -34.613px -47.535px;
      transform-origin: -34.613px -47.535px;
      -webkit-animation-delay: -0.062s;
      animation-delay: -0.062s;
    }
    .lds-microsoft div:nth-child(2) {
      background: rgb(0, 179, 253);
      top: 156.672px;
      left: 118.788px;
      -webkit-transform-origin: -18.788px -56.672px;
      transform-origin: -18.788px -56.672px;
      -webkit-animation-delay: -0.125s;
      animation-delay: -0.125s;
    }
    .lds-microsoft div:nth-child(3) {
      background: rgb(0, 179, 253);
      top: 161.401px;
      left: 101.137px;
      -webkit-transform-origin: -1.137px -61.401px;
      transform-origin: -1.137px -61.401px;
      -webkit-animation-delay: -0.187s;
      animation-delay: -0.187s;
    }
    .lds-microsoft div:nth-child(4) {
      background: rgb(0, 179, 253);
      top: 161.401px;
      left: 82.863px;
      -webkit-transform-origin: 17.137px -61.401px;
      transform-origin: 17.137px -61.401px;
      -webkit-animation-delay: -0.25s;
      animation-delay: -0.25s;
    }
    .lds-microsoft div:nth-child(5) {
      background: rgb(0, 179, 253);
      top: 156.672px;
      left: 65.212px;
      -webkit-transform-origin: 34.788px -56.672px;
      transform-origin: 34.788px -56.672px;
      -webkit-animation-delay: -0.312s;
      animation-delay: -0.312s;
    }
    .lds-microsoft div:nth-child(6) {
      background: rgb(0, 179, 253);
      top: 147.535px;
      left: 49.387px;
      -webkit-transform-origin: 50.613px -47.535px;
      transform-origin: 50.613px -47.535px;
      -webkit-animation-delay: -0.375s;
      animation-delay: -0.375s;
    }
    .lds-microsoft div:nth-child(7) {
      background: rgb(0, 179, 253);
      top: 134.613px;
      left: 36.465px;
      -webkit-transform-origin: 63.535px -34.613px;
      transform-origin: 63.535px -34.613px;
      -webkit-animation-delay: -0.437s;
      animation-delay: -0.437s;
    }
</style>
`;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defautStyle);

/***/ }),

/***/ "./javascript/sdk/htmlElements/errorDiv.ts":
/*!*************************************************!*\
  !*** ./javascript/sdk/htmlElements/errorDiv.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const errorDiv = `<div id="partoo-error" class="partoo-error-container" style="visibility: visible; display: none;">
    <div class="partoo-error" />
      <div class="partoo-error-icon"></div>
      <div>There was an unexpected error</div> 
    </div>
</div>`;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (errorDiv);

/***/ }),

/***/ "./javascript/sdk/htmlElements/iFrame.ts":
/*!***********************************************!*\
  !*** ./javascript/sdk/htmlElements/iFrame.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const iFrame = `<iframe
    style="visibility: hidden;"
    id='partoo-iframe'
    src=''
    width='100%'
    height='100%'
    frameborder='0'
    scrolling="no"
    ></iframe>`;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (iFrame);

/***/ }),

/***/ "./javascript/sdk/htmlElements/loadingDiv.ts":
/*!***************************************************!*\
  !*** ./javascript/sdk/htmlElements/loadingDiv.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const loadingDiv = `<div id="partoo-loading" style="visibility: visible;">
    <div class="lds-microsoft" />
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>
</div>`;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (loadingDiv);

/***/ }),

/***/ "./javascript/sdk/messages/creators/index.ts":
/*!***************************************************!*\
  !*** ./javascript/sdk/messages/creators/index.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPageSize: () => (/* binding */ getPageSize),
/* harmony export */   overrideAction: () => (/* binding */ overrideAction),
/* harmony export */   overrideStyle: () => (/* binding */ overrideStyle),
/* harmony export */   rejectAction: () => (/* binding */ rejectAction),
/* harmony export */   sendSeedData: () => (/* binding */ sendSeedData),
/* harmony export */   setOptions: () => (/* binding */ setOptions),
/* harmony export */   setUpdatePage: () => (/* binding */ setUpdatePage)
/* harmony export */ });
/* harmony import */ var sdk_messages_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sdk/messages/types */ "./javascript/sdk/messages/types/index.ts");
// MESSAGE TYPES

// MESSAGE CREATOR
const overrideAction = action => ({
  type: sdk_messages_types__WEBPACK_IMPORTED_MODULE_0__.OVERRIDE_ACTION,
  action
});
const rejectAction = action => ({
  type: sdk_messages_types__WEBPACK_IMPORTED_MODULE_0__.REJECT_ACTION,
  action
});
const overrideStyle = () => ({
  type: sdk_messages_types__WEBPACK_IMPORTED_MODULE_0__.OVERRIDE_STYLE
});
const getPageSize = () => ({
  type: sdk_messages_types__WEBPACK_IMPORTED_MODULE_0__.GET_PAGE_SIZE
});
const setOptions = options => ({
  type: sdk_messages_types__WEBPACK_IMPORTED_MODULE_0__.SET_OPTIONS,
  options
});
const setUpdatePage = nextUrl => ({
  type: sdk_messages_types__WEBPACK_IMPORTED_MODULE_0__.SET_UPDATE_PAGE,
  nextUrl
});
const sendSeedData = seedData => ({
  type: sdk_messages_types__WEBPACK_IMPORTED_MODULE_0__.SET_SEED_DATA,
  seedData
});

/***/ }),

/***/ "./javascript/sdk/messages/types/index.ts":
/*!************************************************!*\
  !*** ./javascript/sdk/messages/types/index.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GET_PAGE_SIZE: () => (/* binding */ GET_PAGE_SIZE),
/* harmony export */   OVERRIDE_ACTION: () => (/* binding */ OVERRIDE_ACTION),
/* harmony export */   OVERRIDE_STYLE: () => (/* binding */ OVERRIDE_STYLE),
/* harmony export */   REJECT_ACTION: () => (/* binding */ REJECT_ACTION),
/* harmony export */   SET_OPTIONS: () => (/* binding */ SET_OPTIONS),
/* harmony export */   SET_SEED_DATA: () => (/* binding */ SET_SEED_DATA),
/* harmony export */   SET_UPDATE_PAGE: () => (/* binding */ SET_UPDATE_PAGE)
/* harmony export */ });
// MESSAGE TYPES

const OVERRIDE_ACTION = 'OVERRIDE_ACTION';
const REJECT_ACTION = 'REJECT_ACTION';
const OVERRIDE_STYLE = 'OVERRIDE_STYLE';
const SET_OPTIONS = 'SET_OPTIONS';
const GET_PAGE_SIZE = 'GET_PAGE_SIZE';
const SET_UPDATE_PAGE = 'SET_UPDATE_PAGE';
const SET_SEED_DATA = 'SET_SEED_DATA';

// MESSAGE FLOW TYPES

/***/ }),

/***/ "./javascript/sdk/reducers/callbacks.ts":
/*!**********************************************!*\
  !*** ./javascript/sdk/reducers/callbacks.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   actionCallbackSelector: () => (/* binding */ actionCallbackSelector),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   registerCallback: () => (/* binding */ registerCallback)
/* harmony export */ });
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const REGISTER_CALLBACK = 'REGISTER_CALLBACK';
const initialState = {};

// ACTION CREATOR
const registerCallback = (actionName, callback) => ({
  type: REGISTER_CALLBACK,
  actionName,
  callback
});

// REDUCER
const callbacks = (state = initialState, action) => {
  if (action.type === REGISTER_CALLBACK) return _objectSpread(_objectSpread({}, state), {}, {
    [action.actionName]: action.callback
  });
  return state;
};

// SELECTORS
const actionCallbackSelector = (state, actionName) => state[actionName];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (callbacks);

/***/ }),

/***/ "./javascript/sdk/reducers/index.ts":
/*!******************************************!*\
  !*** ./javascript/sdk/reducers/index.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   callbacksSelector: () => (/* binding */ callbacksSelector),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   optionsSelector: () => (/* binding */ optionsSelector),
/* harmony export */   pageSelector: () => (/* binding */ pageSelector),
/* harmony export */   seedDataSelector: () => (/* binding */ seedDataSelector),
/* harmony export */   selectedBusinessIdSelector: () => (/* binding */ selectedBusinessIdSelector),
/* harmony export */   startPageSelector: () => (/* binding */ startPageSelector),
/* harmony export */   urlSelector: () => (/* binding */ urlSelector),
/* harmony export */   userStatusSelector: () => (/* binding */ userStatusSelector)
/* harmony export */ });
/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ "./node_modules/redux/es/index.js");
/* harmony import */ var _callbacks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./callbacks */ "./javascript/sdk/reducers/callbacks.ts");
/* harmony import */ var _page__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./page */ "./javascript/sdk/reducers/page.ts");



const reducers = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)({
  callbacks: _callbacks__WEBPACK_IMPORTED_MODULE_1__["default"],
  page: _page__WEBPACK_IMPORTED_MODULE_2__["default"]
});
const pageSelector = state => state.page;
const callbacksSelector = state => state.callbacks;
const startPageSelector = state => state.page.options.startPage;
const optionsSelector = state => state.page.options;
const seedDataSelector = state => state.page.seedData;
const urlSelector = state => state.page.navigationHistory[state.page.cursor];
const userStatusSelector = ({
  page: {
    userStatus
  }
}) => userStatus;
const selectedBusinessIdSelector = state => state.page.options.selectedBusinessId;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (reducers);

/***/ }),

/***/ "./javascript/sdk/reducers/page.ts":
/*!*****************************************!*\
  !*** ./javascript/sdk/reducers/page.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ENABLE_MESSAGING: () => (/* binding */ ENABLE_MESSAGING),
/* harmony export */   UPDATE_USER_STATUS: () => (/* binding */ UPDATE_USER_STATUS),
/* harmony export */   UserStatuses: () => (/* binding */ UserStatuses),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   goToNextPage: () => (/* binding */ goToNextPage),
/* harmony export */   goToPreviousPage: () => (/* binding */ goToPreviousPage),
/* harmony export */   messagingIsDisabled: () => (/* binding */ messagingIsDisabled),
/* harmony export */   messagingIsEnabled: () => (/* binding */ messagingIsEnabled),
/* harmony export */   resetNavigationHistory: () => (/* binding */ resetNavigationHistory),
/* harmony export */   resetSeedData: () => (/* binding */ resetSeedData),
/* harmony export */   updateOptions: () => (/* binding */ updateOptions),
/* harmony export */   updatePage: () => (/* binding */ updatePage),
/* harmony export */   updateSeedData: () => (/* binding */ updateSeedData),
/* harmony export */   updateUserStatus: () => (/* binding */ updateUserStatus)
/* harmony export */ });
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const ENABLE_MESSAGING = 'ENABLE_MESSAGING';
const DISABLE_MESSAGING = 'DISABLE_MESSAGING';
const UPDATE_OPTIONS = 'UPDATE_OPTIONS';
const UPDATE_PAGE = 'UPDATE_PAGE';
const UPDATE_SEED_DATA = 'UPDATE_SEED_DATA';
const RESET_SEED_DATA = 'RESET_SEED_DATA';
const GO_TO_PREVIOUS_PAGE = 'GO_TO_PREVIOUS_PAGE';
const GO_TO_NEXT_PAGE = 'GO_TO_NEXT_PAGE';
const RESET_NAVIGATION_HISTORY = 'RESET_NAVIGATION_HISTORY';
const UPDATE_USER_STATUS = 'UPDATE_USER_STATUS';
const LOGGED_IN = 'LOGGED_IN';
const LOGGED_OUT = 'LOGGED_OUT';
const LOGGING_IN = 'LOGGING_IN';
const LOGGING_OUT = 'LOGGING_OUT';
const UserStatuses = {
  LOGGED_IN,
  LOGGED_OUT,
  LOGGING_IN,
  LOGGING_OUT
};

// TYPES

const updatePage = url => ({
  url,
  type: UPDATE_PAGE
});
const updateUserStatus = status => ({
  status,
  type: UPDATE_USER_STATUS
});
const goToPreviousPage = () => ({
  type: GO_TO_PREVIOUS_PAGE
});
const goToNextPage = () => ({
  type: GO_TO_NEXT_PAGE
});
const resetNavigationHistory = () => ({
  type: RESET_NAVIGATION_HISTORY
});
const messagingIsEnabled = () => ({
  type: ENABLE_MESSAGING
});
const messagingIsDisabled = () => ({
  type: DISABLE_MESSAGING
});
const updateOptions = options => ({
  type: UPDATE_OPTIONS,
  options
});
const updateSeedData = seedData => ({
  type: UPDATE_SEED_DATA,
  seedData
});
const resetSeedData = () => ({
  type: RESET_SEED_DATA
});
const initialState = {
  cursor: -1,
  navigationHistory: [],
  userStatus: LOGGED_OUT,
  messagingEnabled: false,
  options: {
    startPage: 'businesses',
    startPageAnchorParam: null,
    // Selected businessId option
    selectedBusinessId: null,
    // TODO: Remove because deprecated
    displayUserParams: true,
    // TODO: Remove because deprecated
    // Intercom display option
    displayIntercom: true,
    // App display options
    displayAddButton: true,
    displaySideBar: false,
    displayBusinessListSearch: true,
    displayPartnerConnexionBanner: true,
    displayPresenceManagementDownload: true,
    displayEditBusinessSelector: true,
    displayBusinessModalFilters: true,
    businessFoundBannerText: '',
    style: {
      fontFamilyName: null
    }
  },
  seedData: {}
};
const page = (state = initialState, action) => {
  switch (action.type) {
    case UPDATE_PAGE:
      return _objectSpread(_objectSpread({}, state), {}, {
        navigationHistory: [...state.navigationHistory.slice(0, state.cursor + 1), action.url],
        cursor: state.cursor + 1
      });
    case ENABLE_MESSAGING:
      return _objectSpread(_objectSpread({}, state), {}, {
        messagingEnabled: true
      });
    case DISABLE_MESSAGING:
      return _objectSpread(_objectSpread({}, state), {}, {
        messagingEnabled: false
      });
    case GO_TO_PREVIOUS_PAGE:
      if (state.navigationHistory.length > 0 && state.cursor > 0) {
        return _objectSpread(_objectSpread({}, state), {}, {
          cursor: state.cursor - 1
        });
      }
      console.warn(' Cannot go back'); // eslint-disable-line no-console

      return state;
    case GO_TO_NEXT_PAGE:
      if (state.navigationHistory.length > 0 && state.cursor < state.navigationHistory.length - 1) {
        return _objectSpread(_objectSpread({}, state), {}, {
          cursor: state.cursor + 1
        });
      }
      console.warn(' Cannot go forward'); // eslint-disable-line no-console

      return state;
    case UPDATE_OPTIONS:
      return _objectSpread(_objectSpread({}, state), {}, {
        options: _objectSpread(_objectSpread({}, state.options), action.options)
      });
    case UPDATE_SEED_DATA:
      return _objectSpread(_objectSpread({}, state), {}, {
        seedData: _objectSpread({}, action.seedData)
      });
    case RESET_SEED_DATA:
      return _objectSpread(_objectSpread({}, state), {}, {
        seedData: {}
      });
    case RESET_NAVIGATION_HISTORY:
      return _objectSpread(_objectSpread({}, state), {}, {
        navigationHistory: [],
        cursor: -1
      });
    case UPDATE_USER_STATUS:
      return _objectSpread(_objectSpread({}, state), {}, {
        userStatus: action.status
      });
    default:
      return state;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (page);

/***/ }),

/***/ "./javascript/sdk/redux-sdk.ts":
/*!*************************************!*\
  !*** ./javascript/sdk/redux-sdk.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * `ReduxConnectedClass` class & `connect` function aims at reproducing
 * the behaviour of `Component` class & `connect` in a React-Redux project
 */

/**
 * Class that is connected to a redux store.
 * It has 2 main attributes:
 *    - `state`: Object containing the properties coming from the redux state
 *    - `dispatchers`: Object containing the functions that dispatch redux action to the store
 */
class ReduxConnectedClass {
  constructor() {
    // Previous class state
    _defineProperty(this, "prevState", void 0);
    // Current class state
    _defineProperty(this, "state", void 0);
    // Functions that dispatch redux action
    _defineProperty(this, "dispatchers", void 0);
  }
  /**
   * Update class state & call `onStateChange` callback
   *
   * @param state {S} New class state
   */
  updateState(state) {
    if (this.state) {
      this.prevState = _objectSpread({}, this.state);
    }
    this.state = _objectSpread({}, state);
    this.onStateChange(this.prevState, this.state);
  }

  /**
   * Callback called each time the state is updated.
   *
   * @param prevState {S} Previous state
   * @param state {S} Current state
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars,class-methods-use-this
  onStateChange(prevState, state) {
    /* Empty */
  }

  /**
   * Update dispatchers functions
   *
   * @param dispatchers {D}
   */
  updateDispatchers(dispatchers) {
    this.dispatchers = _objectSpread({}, dispatchers);
  }

  /**
   * Set initial state
   *
   * @param state
   */
  loadInitialState(state) {
    this.state = _objectSpread({}, state);
  }
}
/**
 * Connect a ReduxConnectedClass instance to a Redux store.
 *
 * @param store {Store} The redux store
 * @param instance {ReduxConnectedClass}
 * @param mapReduxStateToClassState {Function|null} Map store state to class state
 * @param mapDispatchToDispatchers {Function|null} Map store dispatch to class dispatchers
 */

const connect = function (store, instance, mapReduxStateToClassState, mapDispatchToDispatchers) {
  // Subscribe for future changes
  store.subscribe(() => {
    const state = store.getState();
    if (mapDispatchToDispatchers) {
      instance.updateDispatchers(mapDispatchToDispatchers(store.dispatch, state));
    }
    if (mapReduxStateToClassState) {
      instance.updateState(mapReduxStateToClassState(state));
    }
  });

  // initial setting
  const state = store.getState();
  if (mapDispatchToDispatchers) {
    instance.updateDispatchers(mapDispatchToDispatchers(store.dispatch, state));
  }
  if (mapReduxStateToClassState) {
    instance.loadInitialState(mapReduxStateToClassState(state));
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ReduxConnectedClass);

/***/ }),

/***/ "./javascript/sdk/sagas/actionCreators.ts":
/*!************************************************!*\
  !*** ./javascript/sdk/sagas/actionCreators.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   goBack: () => (/* binding */ goBack),
/* harmony export */   goForward: () => (/* binding */ goForward),
/* harmony export */   handleCallbackCalled: () => (/* binding */ handleCallbackCalled),
/* harmony export */   handleError: () => (/* binding */ handleError),
/* harmony export */   handleJSHasLoaded: () => (/* binding */ handleJSHasLoaded),
/* harmony export */   handleMessageActions: () => (/* binding */ handleMessageActions),
/* harmony export */   handlePageChanged: () => (/* binding */ handlePageChanged),
/* harmony export */   handlePageHeight: () => (/* binding */ handlePageHeight),
/* harmony export */   handleStyleIsOverridden: () => (/* binding */ handleStyleIsOverridden),
/* harmony export */   handleUserIsLoggedIn: () => (/* binding */ handleUserIsLoggedIn),
/* harmony export */   handleUserIsLoggedOut: () => (/* binding */ handleUserIsLoggedOut),
/* harmony export */   loginUser: () => (/* binding */ loginUser),
/* harmony export */   logoutUser: () => (/* binding */ logoutUser),
/* harmony export */   navigateActions: () => (/* binding */ navigateActions),
/* harmony export */   navigateTo: () => (/* binding */ navigateTo),
/* harmony export */   sendDisplayOptions: () => (/* binding */ sendDisplayOptions),
/* harmony export */   sendGetSizeRequest: () => (/* binding */ sendGetSizeRequest),
/* harmony export */   sendMessageActions: () => (/* binding */ sendMessageActions),
/* harmony export */   sendOverriddenActions: () => (/* binding */ sendOverriddenActions),
/* harmony export */   sendOverrideStyle: () => (/* binding */ sendOverrideStyle),
/* harmony export */   sendRegisteredCallback: () => (/* binding */ sendRegisteredCallback),
/* harmony export */   sendSeedData: () => (/* binding */ sendSeedData),
/* harmony export */   sendUnregisteredCallback: () => (/* binding */ sendUnregisteredCallback),
/* harmony export */   sendUpdatePage: () => (/* binding */ sendUpdatePage)
/* harmony export */ });
/**
 * Handle message actions
 */
// ACTION TYPES -------------------------------------------------------------------------
const HANDLE_USER_LOGGED_OUT_MESSAGE = 'HANDLE_USER_LOGGED_OUT_MESSAGE';
const HANDLE_USER_LOGGED_IN_MESSAGE = 'HANDLE_USER_LOGGED_IN_MESSAGE';
const HANDLE_CALLBACK_CALLED_MESSAGE = 'HANDLE_CALLBACK_CALLED_MESSAGE';
const HANDLE_IFRAME_JS_LOADED_MESSAGE = 'HANDLE_IFRAME_JS_LOADED_MESSAGE';
const HANDLE_PAGE_CHANGED_MESSAGE = 'HANDLE_PAGE_CHANGED_MESSAGE';
const HANDLE_PAGE_HEIGHT_MESSAGE = 'HANDLE_PAGE_HEIGHT_MESSAGE';
const HANDLE_STYLE_IS_OVERRIDDEN_MESSAGE = 'HANDLE_STYLE_IS_OVERRIDDEN_MESSAGE';
const HANDLE_ERROR_MESSAGE = 'HANDLE_ERROR_MESSAGE';

// Flow Types

// ACTION CREATORS ------------------------------------------------------------------------
const handleUserIsLoggedIn = () => ({
  type: HANDLE_USER_LOGGED_IN_MESSAGE
});
const handleUserIsLoggedOut = () => ({
  type: HANDLE_USER_LOGGED_OUT_MESSAGE
});
const handlePageChanged = url => ({
  type: HANDLE_PAGE_CHANGED_MESSAGE,
  url
});
const handleCallbackCalled = (action, inputs) => ({
  type: HANDLE_CALLBACK_CALLED_MESSAGE,
  action,
  inputs
});
const handleJSHasLoaded = () => ({
  type: HANDLE_IFRAME_JS_LOADED_MESSAGE
});
const handlePageHeight = height => ({
  type: HANDLE_PAGE_HEIGHT_MESSAGE,
  height
});
const handleStyleIsOverridden = () => ({
  type: HANDLE_STYLE_IS_OVERRIDDEN_MESSAGE
});
const handleError = errorType => ({
  type: HANDLE_ERROR_MESSAGE,
  errorType
});
const handleMessageActions = {
  HANDLE_USER_LOGGED_OUT_MESSAGE,
  HANDLE_USER_LOGGED_IN_MESSAGE,
  HANDLE_CALLBACK_CALLED_MESSAGE,
  HANDLE_IFRAME_JS_LOADED_MESSAGE,
  HANDLE_PAGE_CHANGED_MESSAGE,
  HANDLE_PAGE_HEIGHT_MESSAGE,
  HANDLE_STYLE_IS_OVERRIDDEN_MESSAGE,
  HANDLE_ERROR_MESSAGE
};

/**
 * Send message actions
 */
// ACTION TYPES -------------------------------------------------------------------------
const SEND_DISPLAY_OPTIONS = 'SEND_DISPLAY_OPTIONS';
const SEND_OVERRIDDEN_ACTIONS = 'SEND_OVERRIDDEN_ACTIONS';
const SEND_GET_SIZE_REQUEST = 'SEND_GET_SIZE_REQUEST';
const SEND_UPDATE_PAGE = 'SEND_UPDATE_PAGE';
const SEND_SEED_DATA = 'SEND_SEED_DATA';
const SEND_OVERRIDE_STYLE = 'SEND_OVERRIDE_STYLE';
const SEND_REGISTERED_CALLBACK = 'SEND_REGISTERED_CALLBACK';
const SEND_UNREGISTERED_CALLBACK = 'SEND_UNREGISTERED_CALLBACK';
// ACTION CREATORS ------------------------------------------------------------------------
const sendDisplayOptions = () => ({
  type: SEND_DISPLAY_OPTIONS
});
const sendGetSizeRequest = () => ({
  type: SEND_GET_SIZE_REQUEST
});
const sendOverriddenActions = () => ({
  type: SEND_OVERRIDDEN_ACTIONS
});
const sendUpdatePage = nextUrl => ({
  type: SEND_UPDATE_PAGE,
  nextUrl
});
const sendSeedData = () => ({
  type: SEND_SEED_DATA
});
const sendOverrideStyle = () => ({
  type: SEND_OVERRIDE_STYLE
});
const sendRegisteredCallback = (action, callback) => ({
  type: SEND_REGISTERED_CALLBACK,
  action,
  callback
});
const sendUnregisteredCallback = action => ({
  type: SEND_UNREGISTERED_CALLBACK,
  action
});
const sendMessageActions = {
  SEND_DISPLAY_OPTIONS,
  SEND_OVERRIDDEN_ACTIONS,
  SEND_GET_SIZE_REQUEST,
  SEND_UPDATE_PAGE,
  SEND_SEED_DATA,
  SEND_OVERRIDE_STYLE,
  SEND_REGISTERED_CALLBACK,
  SEND_UNREGISTERED_CALLBACK
};

/**
 * Navigate actions
 */
// ACTION TYPES -------------------------------------------------------------------------
const LOGIN_USER = 'LOGIN_USER';
const LOGOUT_USER = 'LOGOUT_USER';
const NAVIGATE_TO = 'NAVIGATE_TO';
const GO_BACK = 'GO_BACK';
const GO_FORWARD = 'GO_FORWARD';
// ACTION CREATORS ------------------------------------------------------------------------
const loginUser = tokenOrApiKey => ({
  type: LOGIN_USER,
  tokenOrApiKey
});
const navigateTo = (route, additionalParams = {}, seedData) => ({
  type: NAVIGATE_TO,
  route,
  additionalParams,
  seedData
});
const goBack = () => ({
  type: GO_BACK
});
const goForward = () => ({
  type: GO_FORWARD
});
const logoutUser = () => ({
  type: LOGOUT_USER
});
const navigateActions = {
  LOGIN_USER,
  LOGOUT_USER,
  NAVIGATE_TO,
  GO_BACK,
  GO_FORWARD
};

/***/ }),

/***/ "./javascript/sdk/sagas/handleMessageFromAppSagas.ts":
/*!***********************************************************!*\
  !*** ./javascript/sdk/sagas/handleMessageFromAppSagas.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var redux_saga__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux-saga */ "./node_modules/redux-saga/es/index.js");
/* harmony import */ var redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! redux-saga/effects */ "./node_modules/redux-saga/es/effects.js");
/* harmony import */ var sdk_IFrameWrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sdk/IFrameWrapper */ "./javascript/sdk/IFrameWrapper.ts");
/* harmony import */ var sdk_reducers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! sdk/reducers */ "./javascript/sdk/reducers/index.ts");
/* harmony import */ var sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! sdk/reducers/page */ "./javascript/sdk/reducers/page.ts");
/* harmony import */ var _actionCreators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./actionCreators */ "./javascript/sdk/sagas/actionCreators.ts");







/**
 * Saga called when user was logged Out
 */
const onUserLoggedOutSaga = function* () {
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.put)((0,sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.updateUserStatus)(sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.UserStatuses.LOGGED_OUT));
  sdk_IFrameWrapper__WEBPACK_IMPORTED_MODULE_2__["default"].displayLoadingView();
};

/**
 * Saga called when user successfully logged in
 */
const onUserLoggedInSaga = function* () {
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.put)((0,sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.updateUserStatus)(sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.UserStatuses.LOGGED_IN));
  sdk_IFrameWrapper__WEBPACK_IMPORTED_MODULE_2__["default"].displayIframe();
};

/**
 * Saga called when an HTTP error occurred in Partoo App.
 *
 * @param errorType {number} HTTP error code (400, 404, 500,...)
 */
const onErrorSaga = function* ({
  errorType
}) {
  sdk_IFrameWrapper__WEBPACK_IMPORTED_MODULE_2__["default"].displayErrorView();
  const callbacks = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_3__.callbacksSelector);
  const cb = callbacks.error;
  if (cb) {
    cb(errorType);
  } else {
    // eslint-disable-next-line no-console
    console.warn(`Unexpected error of type ${errorType}`);
  }
};

/**
 * Saga called when the SDK bridge is fully operational
 * in Partoo App (ie. it is possible to post JS message to bridge)
 */
const onIFrameJSHasLoadedSaga = function* () {
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.put)((0,sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.messagingIsEnabled)());
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.put)((0,_actionCreators__WEBPACK_IMPORTED_MODULE_5__.sendOverriddenActions)());
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.put)((0,_actionCreators__WEBPACK_IMPORTED_MODULE_5__.sendDisplayOptions)());
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.put)((0,_actionCreators__WEBPACK_IMPORTED_MODULE_5__.sendOverrideStyle)());
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.put)((0,_actionCreators__WEBPACK_IMPORTED_MODULE_5__.sendGetSizeRequest)());
};

/**
 * Saga triggered when an action, for which a callback has been defined,
 * is triggered in Partoo App.
 *
 * @param action {string} Name of the action
 * @param inputs {Object} Data return by the action.
 */
const onCallbackCalledSaga = function* ({
  action,
  inputs
}) {
  const callbacks = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_3__.callbacksSelector);
  const cb = callbacks[action];
  if (!cb) {
    // eslint-disable-next-line no-console
    console.warn(`No callback defined for ${action}`);
  } else {
    cb(inputs);
  }
};

/**
 * Saga triggered when a JS message containing Partoo App height is received.
 * It adapts the size of the container to this height, wait for 1s and request
 * the Partoo App height again.
 *
 * @param height {number} Partoo App height in pixels
 */
const onPageHeightSaga = function* ({
  height
}) {
  sdk_IFrameWrapper__WEBPACK_IMPORTED_MODULE_2__["default"].resizeContainerToIFrameHeight(height);
  yield (0,redux_saga__WEBPACK_IMPORTED_MODULE_0__.delay)(1000);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.put)((0,_actionCreators__WEBPACK_IMPORTED_MODULE_5__.sendGetSizeRequest)());
};

/**
 * [LEGACY] Saga called when the style has been successfully overridden in Partoo App
 */
const onStyleOverriddenSaga = function* () {
  // eslint-disable-next-line no-console
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.call)(console.log, 'style overridden');
};

/**
 * Saga called when the iFrame URL has changed.
 *
 * @param url {string}
 */
const onPageChangedSaga = function* ({
  url
}) {
  const previousUrl = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_3__.urlSelector);
  if (previousUrl !== url) {
    yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.put)((0,sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.updatePage)(url));
  }
};
const handleMessagesFromAppSaga = function* () {
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_5__.handleMessageActions.HANDLE_USER_LOGGED_OUT_MESSAGE, onUserLoggedOutSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_5__.handleMessageActions.HANDLE_USER_LOGGED_IN_MESSAGE, onUserLoggedInSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_5__.handleMessageActions.HANDLE_CALLBACK_CALLED_MESSAGE, onCallbackCalledSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_5__.handleMessageActions.HANDLE_IFRAME_JS_LOADED_MESSAGE, onIFrameJSHasLoadedSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_5__.handleMessageActions.HANDLE_PAGE_HEIGHT_MESSAGE, onPageHeightSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_5__.handleMessageActions.HANDLE_STYLE_IS_OVERRIDDEN_MESSAGE, onStyleOverriddenSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_5__.handleMessageActions.HANDLE_PAGE_CHANGED_MESSAGE, onPageChangedSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_5__.handleMessageActions.HANDLE_ERROR_MESSAGE, onErrorSaga);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (handleMessagesFromAppSaga);

/***/ }),

/***/ "./javascript/sdk/sagas/navigateSagas.ts":
/*!***********************************************!*\
  !*** ./javascript/sdk/sagas/navigateSagas.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux-saga/effects */ "./node_modules/redux-saga/es/effects.js");
/* harmony import */ var app_routing_routeIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/routing/routeIds */ "./javascript/app/routing/routeIds/index.ts");
/* harmony import */ var sdk_IFrameWrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sdk/IFrameWrapper */ "./javascript/sdk/IFrameWrapper.ts");
/* harmony import */ var sdk_reducers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! sdk/reducers */ "./javascript/sdk/reducers/index.ts");
/* harmony import */ var sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! sdk/reducers/page */ "./javascript/sdk/reducers/page.ts");
/* harmony import */ var sdk_services_navigation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! sdk/services/navigation */ "./javascript/sdk/services/navigation.ts");
/* harmony import */ var _actionCreators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./actionCreators */ "./javascript/sdk/sagas/actionCreators.ts");







/**
 * Saga called to log a user in
 *
 * @param nextPage {string} The page the login should redirect to. Defaults to the startPage.
 * @param tokenOrApiKey {string} Connection Token or API key
 *                               ( login in using an API key is a deprecated behaviour)
 */
const loginSaga = function* ({
  tokenOrApiKey,
  nextPage
}) {
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.put)((0,sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.updateUserStatus)(sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.UserStatuses.LOGGING_IN));
  const page = yield nextPage || (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_3__.startPageSelector);
  const selectedBusinessId = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_3__.selectedBusinessIdSelector);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.put)((0,sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.resetNavigationHistory)());
  const loginUrl = sdk_services_navigation__WEBPACK_IMPORTED_MODULE_5__["default"].generateLoginURL(tokenOrApiKey, page, selectedBusinessId);
  sdk_IFrameWrapper__WEBPACK_IMPORTED_MODULE_2__["default"].updateIframeUrl(loginUrl);
};

/**
 * Saga called to log a user out
 */
const logoutSaga = function* () {
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.put)((0,sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.updateUserStatus)(sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.UserStatuses.LOGGING_OUT));
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.put)((0,sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.resetNavigationHistory)());
  sdk_IFrameWrapper__WEBPACK_IMPORTED_MODULE_2__["default"].updateIframeUrl(sdk_services_navigation__WEBPACK_IMPORTED_MODULE_5__["default"].generateURL(sdk_services_navigation__WEBPACK_IMPORTED_MODULE_5__.LOGOUT_ROUTE));
};

/**
 * Saga to navigate to a given route.
 *
 * @param route {string} Name of the route
 * @param additionalParams {Object}
 * @param seedData {Object}
 */
const navigateToSaga = function* ({
  route,
  additionalParams,
  seedData
}) {
  let userStatus = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_3__.userStatusSelector);

  // If the user is logged out, check for an existing session
  if (userStatus === sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.UserStatuses.LOGGED_OUT) {
    // @ts-ignore
    yield* loginSaga({
      nextPage: route
    });
    userStatus = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_3__.userStatusSelector);
  }

  // If the user is logging in, wait for it to be logged in
  while (userStatus === sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.UserStatuses.LOGGING_IN) {
    yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.take)(sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.UPDATE_USER_STATUS);
    userStatus = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_3__.userStatusSelector);
  }

  // Update seed data
  if (seedData) {
    yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.put)((0,sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.resetSeedData)());
    yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.put)((0,sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.updateSeedData)(seedData));
    yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.put)((0,_actionCreators__WEBPACK_IMPORTED_MODULE_6__.sendSeedData)());
  }
  const currentUrl = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_3__.urlSelector);
  const selectedBusinessId = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_3__.selectedBusinessIdSelector);
  const nextUrl = sdk_services_navigation__WEBPACK_IMPORTED_MODULE_5__["default"].generateURL(route, additionalParams, selectedBusinessId);
  if (currentUrl !== nextUrl) {
    yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.put)((0,sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.updatePage)(nextUrl));
    const nextShortUrl = sdk_services_navigation__WEBPACK_IMPORTED_MODULE_5__["default"].getShortUrlFromFullUrl(nextUrl);
    yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.put)((0,_actionCreators__WEBPACK_IMPORTED_MODULE_6__.sendUpdatePage)(nextShortUrl));
  }
};

/**
 * Saga to go back in navigation history.
 */
const goBackSaga = function* () {
  const currentUrl = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_3__.urlSelector);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.put)((0,sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.goToPreviousPage)());
  const previousUrl = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_3__.urlSelector);
  if (previousUrl.includes(app_routing_routeIds__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_PATH)) return;
  if (currentUrl !== previousUrl) {
    const previousShortUrl = sdk_services_navigation__WEBPACK_IMPORTED_MODULE_5__["default"].getShortUrlFromFullUrl(previousUrl);
    yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.put)((0,_actionCreators__WEBPACK_IMPORTED_MODULE_6__.sendUpdatePage)(previousShortUrl));
  }
};

/**
 * Saga to go forward in navigation history.
 */
const goForwardSaga = function* () {
  const currentUrl = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_3__.urlSelector);
  if (currentUrl.includes(app_routing_routeIds__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_PATH)) {
    yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.put)((0,sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.goToNextPage)());
  }
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.put)((0,sdk_reducers_page__WEBPACK_IMPORTED_MODULE_4__.goToNextPage)());
  const nextUrl = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_3__.urlSelector);
  if (currentUrl !== nextUrl) {
    const nextShortUrl = sdk_services_navigation__WEBPACK_IMPORTED_MODULE_5__["default"].getShortUrlFromFullUrl(nextUrl);
    yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.put)((0,_actionCreators__WEBPACK_IMPORTED_MODULE_6__.sendUpdatePage)(nextShortUrl));
  }
};
const navigationSagas = function* () {
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_6__.navigateActions.LOGIN_USER, loginSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_6__.navigateActions.LOGOUT_USER, logoutSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_6__.navigateActions.NAVIGATE_TO, navigateToSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_6__.navigateActions.GO_BACK, goBackSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_0__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_6__.navigateActions.GO_FORWARD, goForwardSaga);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (navigationSagas);

/***/ }),

/***/ "./javascript/sdk/sagas/sendMessageToAppSagas.ts":
/*!*******************************************************!*\
  !*** ./javascript/sdk/sagas/sendMessageToAppSagas.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   sendDisplayOptionsSaga: () => (/* binding */ sendDisplayOptionsSaga),
/* harmony export */   sendMessage: () => (/* binding */ sendMessage)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isEmpty.js");
/* harmony import */ var redux_saga__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux-saga */ "./node_modules/redux-saga/es/index.js");
/* harmony import */ var redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! redux-saga/effects */ "./node_modules/redux-saga/es/effects.js");
/* harmony import */ var sdk_IFrameWrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sdk/IFrameWrapper */ "./javascript/sdk/IFrameWrapper.ts");
/* harmony import */ var sdk_messages_creators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! sdk/messages/creators */ "./javascript/sdk/messages/creators/index.ts");
/* harmony import */ var sdk_reducers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! sdk/reducers */ "./javascript/sdk/reducers/index.ts");
/* harmony import */ var sdk_reducers_callbacks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! sdk/reducers/callbacks */ "./javascript/sdk/reducers/callbacks.ts");
/* harmony import */ var sdk_reducers_page__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! sdk/reducers/page */ "./javascript/sdk/reducers/page.ts");
/* harmony import */ var _actionCreators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./actionCreators */ "./javascript/sdk/sagas/actionCreators.ts");










/**
 * Saga to send a JS message to Partoo App.
 * Before posting, check that messaging is enabled (i.e. the SDK bridge is ready to receive message)
 *
 * @param message {Object}
 */
const sendMessage = function* (message) {
  let {
    messagingEnabled
  } = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_4__.pageSelector);

  // If messaging is disabled, wait for 4s
  if (!messagingEnabled) {
    yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.race)({
      enable: (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.take)(sdk_reducers_page__WEBPACK_IMPORTED_MODULE_6__.ENABLE_MESSAGING),
      cancel: (0,redux_saga__WEBPACK_IMPORTED_MODULE_0__.delay)(4000)
    });
    ({
      messagingEnabled
    } = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_4__.pageSelector));
  }
  if (messagingEnabled) {
    sdk_IFrameWrapper__WEBPACK_IMPORTED_MODULE_2__["default"].postMessage(message);
  } else {
    // If messaging is not enabled after 4s, log an error.
    // eslint-disable-next-line no-console
    console.error('Messaging not working');
  }
};

/**
 * Saga to send a page size request to Partoo App
 */
const sendGetPageSizeRequestSaga = function* () {
  yield* sendMessage((0,sdk_messages_creators__WEBPACK_IMPORTED_MODULE_3__.getPageSize)());
};

/**
 * Saga to send display options to Partoo App (for Partoo Component)
 */
const sendDisplayOptionsSaga = function* () {
  const options = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_4__.optionsSelector);
  yield* sendMessage((0,sdk_messages_creators__WEBPACK_IMPORTED_MODULE_3__.setOptions)(options));
};

/**
 * Saga to send all the actions for which a callback has been defined
 * This saga is triggered at login time when the user successfully logged in.
 *
 */
const sendOverriddenActionsSaga = function* () {
  const callbacks = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_4__.callbacksSelector);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.all)(Object.keys(callbacks).map(action => (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.fork)(sendMessage, (0,sdk_messages_creators__WEBPACK_IMPORTED_MODULE_3__.overrideAction)(action))));
};

/**
 * Send message to indicate that a callback has been defined for a Partoo App action
 *
 * @param action {string} Partoo app action for which we defined a callback
 * @param callback {Function} Callback to call when the action is triggered
 */
const sendRegisteredCallbackSaga = function* ({
  action,
  callback
}) {
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.put)((0,sdk_reducers_callbacks__WEBPACK_IMPORTED_MODULE_5__.registerCallback)(action, callback));
  yield* sendMessage((0,sdk_messages_creators__WEBPACK_IMPORTED_MODULE_3__.overrideAction)(action));
};

/**
 * Send message to indicate that a callback has been canceled from a Partoo App action
 *
 * @param action {string} Partoo app action for which we canceled a callback
 */
const sendUnregisteredCallbackSaga = function* ({
  action
}) {
  yield* sendMessage((0,sdk_messages_creators__WEBPACK_IMPORTED_MODULE_3__.rejectAction)(action));
};

/**
 * Send next url to display in app
 */
const sendUpdatePageSaga = function* ({
  nextUrl
}) {
  yield* sendMessage((0,sdk_messages_creators__WEBPACK_IMPORTED_MODULE_3__.setUpdatePage)(nextUrl));
};

/**
 * [LEGACY] Send seed data to fill lab form
 */
const sendSeedDataSaga = function* () {
  const seedDada = yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.select)(sdk_reducers__WEBPACK_IMPORTED_MODULE_4__.seedDataSelector);
  if (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(seedDada)) {
    yield* sendMessage((0,sdk_messages_creators__WEBPACK_IMPORTED_MODULE_3__.sendSeedData)(seedDada));
  }
};

/**
 * [LEGACY] Send a message to override style in Partoo App
 */
const sendOverrideStyleSaga = function* () {
  yield* sendMessage((0,sdk_messages_creators__WEBPACK_IMPORTED_MODULE_3__.overrideStyle)());
};
const sendMessageToAppSagas = function* () {
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_7__.sendMessageActions.SEND_DISPLAY_OPTIONS, sendDisplayOptionsSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_7__.sendMessageActions.SEND_OVERRIDDEN_ACTIONS, sendOverriddenActionsSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_7__.sendMessageActions.SEND_UPDATE_PAGE, sendUpdatePageSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_7__.sendMessageActions.SEND_SEED_DATA, sendSeedDataSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_7__.sendMessageActions.SEND_GET_SIZE_REQUEST, sendGetPageSizeRequestSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_7__.sendMessageActions.SEND_OVERRIDE_STYLE, sendOverrideStyleSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_7__.sendMessageActions.SEND_REGISTERED_CALLBACK, sendRegisteredCallbackSaga);
  yield (0,redux_saga_effects__WEBPACK_IMPORTED_MODULE_1__.takeEvery)(_actionCreators__WEBPACK_IMPORTED_MODULE_7__.sendMessageActions.SEND_UNREGISTERED_CALLBACK, sendUnregisteredCallbackSaga);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sendMessageToAppSagas);

/***/ }),

/***/ "./javascript/sdk/services/navigation.ts":
/*!***********************************************!*\
  !*** ./javascript/sdk/services/navigation.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LOGOUT_ROUTE: () => (/* binding */ LOGOUT_ROUTE),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var query_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! query-string */ "./node_modules/query-string/index.js");
/* harmony import */ var app_common_data_routeIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/common/data/routeIds */ "./javascript/app/common/data/routeIds.ts");
/* harmony import */ var app_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/config */ "./javascript/app/config.ts");
/* harmony import */ var app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/routing/routeIds */ "./javascript/app/routing/routeIds/index.ts");
/* harmony import */ var _exceptions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../exceptions */ "./javascript/sdk/exceptions.ts");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }





const LOGOUT_ROUTE = 'logout';
const PRESENCE_MANAGEMENT_ROUTE = 'presenceManagement';
const GOOGLE_POSTS_ROUTE = 'googlePosts';
const POSTS_ROUTE = 'posts';
const ANALYTICS_ROUTE = 'analytics';
const BUSINESS_EDIT_ROUTE = 'business';
const BUSINESS_LIST_ROUTE = 'businesses';
const BUSINESS_CREATE_ROUTE = 'add';
const PARTNER_CONNECTIONS_ROUTE = 'partnerConnections';
const REVIEW_MANAGEMENT_ROUTE = 'reviewManagement';
const REVIEW_ANALYTICS_ROUTE = 'reviewAnalytics';
const REVIEW_BOOSTER_ROUTE = 'reviewBooster';
const MESSAGING_ROUTE = 'messaging';
const BULK_UPDATE_ROUTE = 'bulkUpdate';
const REVIEW_REPLY_TEMPLATE_ROUTE = 'reviewReplyTemplate';
const MESSAGING_REPLY_TEMPLATE_ROUTE = 'messagingReplyTemplate';
const SETTINGS_CONVERSATION_STARTERS_ROUTE = 'conversationStarters';
const SETTINGS_GOOGLE_VERIFICATION_ROUTE = 'googleVerification';
const SETTINGS_CHAT_PREFERENCES_ROUTE = 'chatPreferences';
const SETTINGS_WHATSAPP_ROUTE = 'whatsappSettings';
const FRONTEND_ROUTES = {
  [LOGOUT_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.LOG_OUT_PATH,
  [PRESENCE_MANAGEMENT_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.VISIBILITY_DIFFUSION_PATH,
  [GOOGLE_POSTS_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.VISIBILITY_POSTS_PATH,
  // Cannot remove because used by clients in iframe
  [POSTS_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.VISIBILITY_POSTS_PATH,
  [ANALYTICS_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.ANALYTICS_VISIBILITY_PATH,
  [BUSINESS_EDIT_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.VISIBILITY_LOCATION_PATH,
  // Cannot remove because used by clients in iframe
  [BUSINESS_LIST_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.VISIBILITY_LOCATION_PATH,
  [BUSINESS_CREATE_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.VISIBILITY_LOCATION_ADD_PATH,
  [PARTNER_CONNECTIONS_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.SETTINGS_PLATFORMS_CONNECTION_PATHNAME,
  [REVIEW_MANAGEMENT_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.CONVERSATIONS_REVIEW_MANAGEMENT_PATH,
  [REVIEW_ANALYTICS_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.ANALYTICS_REVIEW_PATH,
  [REVIEW_BOOSTER_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.CONVERSATIONS_REVIEW_SEND_INVITE_PATH,
  [MESSAGING_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.CONVERSATIONS_MESSAGING_PATH,
  [BULK_UPDATE_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.VISIBILITY_BULK_UPDATE_PATH,
  [REVIEW_REPLY_TEMPLATE_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.SETTINGS_REVIEWS_REPLY_TEMPLATES_PATHNAME,
  [MESSAGING_REPLY_TEMPLATE_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.SETTINGS_MESSAGES_REPLY_TEMPLATES_PATHNAME,
  [SETTINGS_CONVERSATION_STARTERS_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.SETTINGS_MESSAGES_CONVERSATION_STARTERS_PATHNAME,
  [SETTINGS_GOOGLE_VERIFICATION_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.SETTINGS_PLATFORMS_GOOGLE_VERIFICATION_PATHNAME,
  [SETTINGS_CHAT_PREFERENCES_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.SETTINGS_MESSAGES_CHAT_PREFERENCES_PATHNAME,
  [SETTINGS_WHATSAPP_ROUTE]: app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.SETTINGS_MESSAGES_WHATSAPP_PATHNAME
};
class NavigationService {
  static generateURL(route, additionalParams = {}, selectedBusinessId = null) {
    if (!FRONTEND_ROUTES[route]) {
      // eslint-disable-next-line @typescript-eslint/no-throw-literal
      throw new _exceptions__WEBPACK_IMPORTED_MODULE_4__.RoutingException(` Route "${route}" not available`);
    }
    if (route == GOOGLE_POSTS_ROUTE) {
      console.warn(' Warning : The route "googlePosts" is deprecated and has been replaced with "posts".');
    }
    let fullPath = `${app_config__WEBPACK_IMPORTED_MODULE_2__.BASE_URL}${FRONTEND_ROUTES[route]}`;
    const queryParameters = {};

    // TODO: Make this behaviour more generic
    if (route === BUSINESS_EDIT_ROUTE) {
      if (additionalParams.businessId) {
        fullPath = `${fullPath}/${additionalParams.businessId}`;
      } else if (selectedBusinessId) {
        // Append to path the selectedBusinessId when on business edit.
        fullPath = `${fullPath}/${selectedBusinessId}`;
      }
    } else if (route === REVIEW_MANAGEMENT_ROUTE) {
      queryParameters.status = additionalParams.status || 'live';
    } else if ([POSTS_ROUTE, GOOGLE_POSTS_ROUTE].includes(route)) {
      queryParameters.status = additionalParams.status || 'all';
    }
    if (selectedBusinessId) {
      queryParameters[app_common_data_routeIds__WEBPACK_IMPORTED_MODULE_1__.BUSINESS_ID_PARAM] = selectedBusinessId;
    }
    if (Object.keys(queryParameters).length !== 0) {
      fullPath = `${fullPath}?${query_string__WEBPACK_IMPORTED_MODULE_0__.stringify(queryParameters)}`;
    }
    return fullPath;
  }
  static getShortUrlFromFullUrl(fullPath) {
    return fullPath.split(app_config__WEBPACK_IMPORTED_MODULE_2__.BASE_URL)[1];
  }
  static generateLoginURL(apiKeyOrConnectionToken, nextRoute, selectedBusinessId = null) {
    let connectionInformation = {};
    if (apiKeyOrConnectionToken) {
      const isConnectionToken = apiKeyOrConnectionToken.startsWith('\\x');
      connectionInformation = isConnectionToken ? {
        connection_token: apiKeyOrConnectionToken
      } : {
        api_key: apiKeyOrConnectionToken
      };
      if (!isConnectionToken) {
        // eslint-disable-next-line no-console
        console.warn(' Using api key to log users is deprecated. ' + 'This method will stop working on June 15th 2021.' + 'You should be using connection token instead. ' + 'See https://developers.partoo.co/rest_api/v2/#tag/Connection-Tokens');
      }
    }
    if (!FRONTEND_ROUTES[nextRoute]) {
      // eslint-disable-next-line @typescript-eslint/no-throw-literal
      throw new _exceptions__WEBPACK_IMPORTED_MODULE_4__.RoutingException(` Route "${nextRoute}" not available`);
    }
    let nextPage = FRONTEND_ROUTES[nextRoute];
    if (selectedBusinessId && nextRoute === BUSINESS_EDIT_ROUTE) {
      // Handle selectedBusinessId as path upon login (taking parameter from init).
      nextPage = `${FRONTEND_ROUTES[nextRoute]}/${selectedBusinessId}`;
    } else if (selectedBusinessId) {
      nextPage = `${FRONTEND_ROUTES[nextRoute]}?${app_common_data_routeIds__WEBPACK_IMPORTED_MODULE_1__.BUSINESS_ID_PARAM}=${selectedBusinessId}`;
    }
    const queryParams = query_string__WEBPACK_IMPORTED_MODULE_0__.stringify(_objectSpread(_objectSpread({}, connectionInformation), {}, {
      [app_common_data_routeIds__WEBPACK_IMPORTED_MODULE_1__.NEXT_PAGE_SEARCH_PARAM]: nextPage
    }));

    // BASE_URL is defined in the webpack config
    return `${app_config__WEBPACK_IMPORTED_MODULE_2__.BASE_URL}${app_routing_routeIds__WEBPACK_IMPORTED_MODULE_3__.CONNECTION_PATH}?${queryParams}`;
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NavigationService);

/***/ }),

/***/ "./node_modules/decode-uri-component/index.js":
/*!****************************************************!*\
  !*** ./node_modules/decode-uri-component/index.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return [decodeURIComponent(components.join(''))];
	} catch (err) {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	var left = components.slice(0, split);
	var right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
	try {
		return decodeURIComponent(input);
	} catch (err) {
		var tokens = input.match(singleMatcher) || [];

		for (var i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher) || [];
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	var replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD'
	};

	var match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch (err) {
			var result = decode(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	var entries = Object.keys(replaceMap);

	for (var i = 0; i < entries.length; i++) {
		// Replace all decoded components
		var key = entries[i];
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

module.exports = function (encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		encodedURI = encodedURI.replace(/\+/g, ' ');

		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch (err) {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
};


/***/ }),

/***/ "./node_modules/filter-obj/index.js":
/*!******************************************!*\
  !*** ./node_modules/filter-obj/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";

module.exports = function (obj, predicate) {
	var ret = {};
	var keys = Object.keys(obj);
	var isArr = Array.isArray(predicate);

	for (var i = 0; i < keys.length; i++) {
		var key = keys[i];
		var val = obj[key];

		if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
			ret[key] = val;
		}
	}

	return ret;
};


/***/ }),

/***/ "./node_modules/query-string/index.js":
/*!********************************************!*\
  !*** ./node_modules/query-string/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const strictUriEncode = __webpack_require__(/*! strict-uri-encode */ "./node_modules/strict-uri-encode/index.js");
const decodeComponent = __webpack_require__(/*! decode-uri-component */ "./node_modules/decode-uri-component/index.js");
const splitOnFirst = __webpack_require__(/*! split-on-first */ "./node_modules/split-on-first/index.js");
const filterObject = __webpack_require__(/*! filter-obj */ "./node_modules/filter-obj/index.js");

const isNullOrUndefined = value => value === null || value === undefined;

const encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');

function encoderForArrayFormat(options) {
	switch (options.arrayFormat) {
		case 'index':
			return key => (result, value) => {
				const index = result.length;

				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[', index, ']'].join('')];
				}

				return [
					...result,
					[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
				];
			};

		case 'bracket':
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[]'].join('')];
				}

				return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
			};

		case 'colon-list-separator':
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), ':list='].join('')];
				}

				return [...result, [encode(key, options), ':list=', encode(value, options)].join('')];
			};

		case 'comma':
		case 'separator':
		case 'bracket-separator': {
			const keyValueSep = options.arrayFormat === 'bracket-separator' ?
				'[]=' :
				'=';

			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				// Translate null to an empty string so that it doesn't serialize as 'null'
				value = value === null ? '' : value;

				if (result.length === 0) {
					return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
				}

				return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
			};
		}

		default:
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, encode(key, options)];
				}

				return [...result, [encode(key, options), '=', encode(value, options)].join('')];
			};
	}
}

function parserForArrayFormat(options) {
	let result;

	switch (options.arrayFormat) {
		case 'index':
			return (key, value, accumulator) => {
				result = /\[(\d*)\]$/.exec(key);

				key = key.replace(/\[\d*\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return (key, value, accumulator) => {
				result = /(\[\])$/.exec(key);
				key = key.replace(/\[\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		case 'colon-list-separator':
			return (key, value, accumulator) => {
				result = /(:list)$/.exec(key);
				key = key.replace(/:list$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		case 'comma':
		case 'separator':
			return (key, value, accumulator) => {
				const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
				const isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
				value = isEncodedArray ? decode(value, options) : value;
				const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
				accumulator[key] = newValue;
			};

		case 'bracket-separator':
			return (key, value, accumulator) => {
				const isArray = /(\[\])$/.test(key);
				key = key.replace(/\[\]$/, '');

				if (!isArray) {
					accumulator[key] = value ? decode(value, options) : value;
					return;
				}

				const arrayValue = value === null ?
					[] :
					value.split(options.arrayFormatSeparator).map(item => decode(item, options));

				if (accumulator[key] === undefined) {
					accumulator[key] = arrayValue;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], arrayValue);
			};

		default:
			return (key, value, accumulator) => {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function validateArrayFormatSeparator(value) {
	if (typeof value !== 'string' || value.length !== 1) {
		throw new TypeError('arrayFormatSeparator must be single character string');
	}
}

function encode(value, options) {
	if (options.encode) {
		return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function decode(value, options) {
	if (options.decode) {
		return decodeComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	}

	if (typeof input === 'object') {
		return keysSorter(Object.keys(input))
			.sort((a, b) => Number(a) - Number(b))
			.map(key => input[key]);
	}

	return input;
}

function removeHash(input) {
	const hashStart = input.indexOf('#');
	if (hashStart !== -1) {
		input = input.slice(0, hashStart);
	}

	return input;
}

function getHash(url) {
	let hash = '';
	const hashStart = url.indexOf('#');
	if (hashStart !== -1) {
		hash = url.slice(hashStart);
	}

	return hash;
}

function extract(input) {
	input = removeHash(input);
	const queryStart = input.indexOf('?');
	if (queryStart === -1) {
		return '';
	}

	return input.slice(queryStart + 1);
}

function parseValue(value, options) {
	if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
		value = Number(value);
	} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
		value = value.toLowerCase() === 'true';
	}

	return value;
}

function parse(query, options) {
	options = Object.assign({
		decode: true,
		sort: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ',',
		parseNumbers: false,
		parseBooleans: false
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const formatter = parserForArrayFormat(options);

	// Create an object with no prototype
	const ret = Object.create(null);

	if (typeof query !== 'string') {
		return ret;
	}

	query = query.trim().replace(/^[?#&]/, '');

	if (!query) {
		return ret;
	}

	for (const param of query.split('&')) {
		if (param === '') {
			continue;
		}

		let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');

		// Missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);
		formatter(decode(key, options), value, ret);
	}

	for (const key of Object.keys(ret)) {
		const value = ret[key];
		if (typeof value === 'object' && value !== null) {
			for (const k of Object.keys(value)) {
				value[k] = parseValue(value[k], options);
			}
		} else {
			ret[key] = parseValue(value, options);
		}
	}

	if (options.sort === false) {
		return ret;
	}

	return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
		const value = ret[key];
		if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
			// Sort object keys, not values
			result[key] = keysSorter(value);
		} else {
			result[key] = value;
		}

		return result;
	}, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = (object, options) => {
	if (!object) {
		return '';
	}

	options = Object.assign({
		encode: true,
		strict: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ','
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const shouldFilter = key => (
		(options.skipNull && isNullOrUndefined(object[key])) ||
		(options.skipEmptyString && object[key] === '')
	);

	const formatter = encoderForArrayFormat(options);

	const objectCopy = {};

	for (const key of Object.keys(object)) {
		if (!shouldFilter(key)) {
			objectCopy[key] = object[key];
		}
	}

	const keys = Object.keys(objectCopy);

	if (options.sort !== false) {
		keys.sort(options.sort);
	}

	return keys.map(key => {
		const value = object[key];

		if (value === undefined) {
			return '';
		}

		if (value === null) {
			return encode(key, options);
		}

		if (Array.isArray(value)) {
			if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
				return encode(key, options) + '[]';
			}

			return value
				.reduce(formatter(key), [])
				.join('&');
		}

		return encode(key, options) + '=' + encode(value, options);
	}).filter(x => x.length > 0).join('&');
};

exports.parseUrl = (url, options) => {
	options = Object.assign({
		decode: true
	}, options);

	const [url_, hash] = splitOnFirst(url, '#');

	return Object.assign(
		{
			url: url_.split('?')[0] || '',
			query: parse(extract(url), options)
		},
		options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
	);
};

exports.stringifyUrl = (object, options) => {
	options = Object.assign({
		encode: true,
		strict: true,
		[encodeFragmentIdentifier]: true
	}, options);

	const url = removeHash(object.url).split('?')[0] || '';
	const queryFromUrl = exports.extract(object.url);
	const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

	const query = Object.assign(parsedQueryFromUrl, object.query);
	let queryString = exports.stringify(query, options);
	if (queryString) {
		queryString = `?${queryString}`;
	}

	let hash = getHash(object.url);
	if (object.fragmentIdentifier) {
		hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
	}

	return `${url}${queryString}${hash}`;
};

exports.pick = (input, filter, options) => {
	options = Object.assign({
		parseFragmentIdentifier: true,
		[encodeFragmentIdentifier]: false
	}, options);

	const {url, query, fragmentIdentifier} = exports.parseUrl(input, options);
	return exports.stringifyUrl({
		url,
		query: filterObject(query, filter),
		fragmentIdentifier
	}, options);
};

exports.exclude = (input, filter, options) => {
	const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);

	return exports.pick(input, exclusionFilter, options);
};


/***/ }),

/***/ "./node_modules/redux-saga/es/effects.js":
/*!***********************************************!*\
  !*** ./node_modules/redux-saga/es/effects.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   actionChannel: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.actionChannel),
/* harmony export */   all: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.all),
/* harmony export */   apply: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.apply),
/* harmony export */   call: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.call),
/* harmony export */   cancel: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.cancel),
/* harmony export */   cancelled: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.cancelled),
/* harmony export */   cps: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.cps),
/* harmony export */   flush: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.flush),
/* harmony export */   fork: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.fork),
/* harmony export */   getContext: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.getContext),
/* harmony export */   join: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.join),
/* harmony export */   put: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.put),
/* harmony export */   race: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.race),
/* harmony export */   select: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.select),
/* harmony export */   setContext: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.setContext),
/* harmony export */   spawn: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.spawn),
/* harmony export */   take: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.take),
/* harmony export */   takeEvery: () => (/* reexport safe */ _internal_io_helpers__WEBPACK_IMPORTED_MODULE_1__.takeEvery),
/* harmony export */   takeLatest: () => (/* reexport safe */ _internal_io_helpers__WEBPACK_IMPORTED_MODULE_1__.takeLatest),
/* harmony export */   takem: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_0__.takem),
/* harmony export */   throttle: () => (/* reexport safe */ _internal_io_helpers__WEBPACK_IMPORTED_MODULE_1__.throttle)
/* harmony export */ });
/* harmony import */ var _internal_io__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/io */ "./node_modules/redux-saga/es/internal/io.js");
/* harmony import */ var _internal_io_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/io-helpers */ "./node_modules/redux-saga/es/internal/io-helpers.js");




/***/ }),

/***/ "./node_modules/redux-saga/es/index.js":
/*!*********************************************!*\
  !*** ./node_modules/redux-saga/es/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CANCEL: () => (/* reexport safe */ _internal_utils__WEBPACK_IMPORTED_MODULE_5__.CANCEL),
/* harmony export */   END: () => (/* reexport safe */ _internal_channel__WEBPACK_IMPORTED_MODULE_2__.END),
/* harmony export */   buffers: () => (/* reexport safe */ _internal_buffers__WEBPACK_IMPORTED_MODULE_3__.buffers),
/* harmony export */   channel: () => (/* reexport safe */ _internal_channel__WEBPACK_IMPORTED_MODULE_2__.channel),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   delay: () => (/* reexport safe */ _internal_utils__WEBPACK_IMPORTED_MODULE_5__.delay),
/* harmony export */   detach: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_6__.detach),
/* harmony export */   effects: () => (/* reexport module object */ _effects__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   eventChannel: () => (/* reexport safe */ _internal_channel__WEBPACK_IMPORTED_MODULE_2__.eventChannel),
/* harmony export */   runSaga: () => (/* reexport safe */ _internal_runSaga__WEBPACK_IMPORTED_MODULE_1__.runSaga),
/* harmony export */   takeEvery: () => (/* reexport safe */ _internal_sagaHelpers__WEBPACK_IMPORTED_MODULE_4__.takeEvery),
/* harmony export */   takeLatest: () => (/* reexport safe */ _internal_sagaHelpers__WEBPACK_IMPORTED_MODULE_4__.takeLatest),
/* harmony export */   throttle: () => (/* reexport safe */ _internal_sagaHelpers__WEBPACK_IMPORTED_MODULE_4__.throttle),
/* harmony export */   utils: () => (/* reexport module object */ _utils__WEBPACK_IMPORTED_MODULE_8__)
/* harmony export */ });
/* harmony import */ var _internal_middleware__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/middleware */ "./node_modules/redux-saga/es/internal/middleware.js");
/* harmony import */ var _internal_runSaga__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/runSaga */ "./node_modules/redux-saga/es/internal/runSaga.js");
/* harmony import */ var _internal_channel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/channel */ "./node_modules/redux-saga/es/internal/channel.js");
/* harmony import */ var _internal_buffers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/buffers */ "./node_modules/redux-saga/es/internal/buffers.js");
/* harmony import */ var _internal_sagaHelpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/sagaHelpers */ "./node_modules/redux-saga/es/internal/sagaHelpers/index.js");
/* harmony import */ var _internal_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./internal/utils */ "./node_modules/redux-saga/es/internal/utils.js");
/* harmony import */ var _internal_io__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./internal/io */ "./node_modules/redux-saga/es/internal/io.js");
/* harmony import */ var _effects__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./effects */ "./node_modules/redux-saga/es/effects.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils */ "./node_modules/redux-saga/es/utils.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_internal_middleware__WEBPACK_IMPORTED_MODULE_0__["default"]);













/***/ }),

/***/ "./node_modules/redux-saga/es/internal/buffers.js":
/*!********************************************************!*\
  !*** ./node_modules/redux-saga/es/internal/buffers.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BUFFER_OVERFLOW: () => (/* binding */ BUFFER_OVERFLOW),
/* harmony export */   buffers: () => (/* binding */ buffers)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/redux-saga/es/internal/utils.js");


var BUFFER_OVERFLOW = "Channel's Buffer overflow!";

var ON_OVERFLOW_THROW = 1;
var ON_OVERFLOW_DROP = 2;
var ON_OVERFLOW_SLIDE = 3;
var ON_OVERFLOW_EXPAND = 4;

var zeroBuffer = { isEmpty: _utils__WEBPACK_IMPORTED_MODULE_0__.kTrue, put: _utils__WEBPACK_IMPORTED_MODULE_0__.noop, take: _utils__WEBPACK_IMPORTED_MODULE_0__.noop };

function ringBuffer() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
  var overflowAction = arguments[1];

  var arr = new Array(limit);
  var length = 0;
  var pushIndex = 0;
  var popIndex = 0;

  var push = function push(it) {
    arr[pushIndex] = it;
    pushIndex = (pushIndex + 1) % limit;
    length++;
  };

  var take = function take() {
    if (length != 0) {
      var it = arr[popIndex];
      arr[popIndex] = null;
      length--;
      popIndex = (popIndex + 1) % limit;
      return it;
    }
  };

  var flush = function flush() {
    var items = [];
    while (length) {
      items.push(take());
    }
    return items;
  };

  return {
    isEmpty: function isEmpty() {
      return length == 0;
    },
    put: function put(it) {
      if (length < limit) {
        push(it);
      } else {
        var doubledLimit = void 0;
        switch (overflowAction) {
          case ON_OVERFLOW_THROW:
            throw new Error(BUFFER_OVERFLOW);
          case ON_OVERFLOW_SLIDE:
            arr[pushIndex] = it;
            pushIndex = (pushIndex + 1) % limit;
            popIndex = pushIndex;
            break;
          case ON_OVERFLOW_EXPAND:
            doubledLimit = 2 * limit;

            arr = flush();

            length = arr.length;
            pushIndex = arr.length;
            popIndex = 0;

            arr.length = doubledLimit;
            limit = doubledLimit;

            push(it);
            break;
          default:
          // DROP
        }
      }
    },
    take: take,
    flush: flush
  };
}

var buffers = {
  none: function none() {
    return zeroBuffer;
  },
  fixed: function fixed(limit) {
    return ringBuffer(limit, ON_OVERFLOW_THROW);
  },
  dropping: function dropping(limit) {
    return ringBuffer(limit, ON_OVERFLOW_DROP);
  },
  sliding: function sliding(limit) {
    return ringBuffer(limit, ON_OVERFLOW_SLIDE);
  },
  expanding: function expanding(initialSize) {
    return ringBuffer(initialSize, ON_OVERFLOW_EXPAND);
  }
};

/***/ }),

/***/ "./node_modules/redux-saga/es/internal/channel.js":
/*!********************************************************!*\
  !*** ./node_modules/redux-saga/es/internal/channel.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   END: () => (/* binding */ END),
/* harmony export */   INVALID_BUFFER: () => (/* binding */ INVALID_BUFFER),
/* harmony export */   UNDEFINED_INPUT_ERROR: () => (/* binding */ UNDEFINED_INPUT_ERROR),
/* harmony export */   channel: () => (/* binding */ channel),
/* harmony export */   emitter: () => (/* binding */ emitter),
/* harmony export */   eventChannel: () => (/* binding */ eventChannel),
/* harmony export */   isEnd: () => (/* binding */ isEnd),
/* harmony export */   stdChannel: () => (/* binding */ stdChannel)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/redux-saga/es/internal/utils.js");
/* harmony import */ var _buffers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffers */ "./node_modules/redux-saga/es/internal/buffers.js");
/* harmony import */ var _scheduler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scheduler */ "./node_modules/redux-saga/es/internal/scheduler.js");
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





var CHANNEL_END_TYPE = '@@redux-saga/CHANNEL_END';
var END = { type: CHANNEL_END_TYPE };
var isEnd = function isEnd(a) {
  return a && a.type === CHANNEL_END_TYPE;
};

function emitter() {
  var subscribers = [];

  function subscribe(sub) {
    subscribers.push(sub);
    return function () {
      return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.remove)(subscribers, sub);
    };
  }

  function emit(item) {
    var arr = subscribers.slice();
    for (var i = 0, len = arr.length; i < len; i++) {
      arr[i](item);
    }
  }

  return {
    subscribe: subscribe,
    emit: emit
  };
}

var INVALID_BUFFER = 'invalid buffer passed to channel factory function';
var UNDEFINED_INPUT_ERROR = 'Saga was provided with an undefined action';

if (true) {
  UNDEFINED_INPUT_ERROR += '\nHints:\n    - check that your Action Creator returns a non-undefined value\n    - if the Saga was started using runSaga, check that your subscribe source provides the action to its listeners\n  ';
}

function channel() {
  var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _buffers__WEBPACK_IMPORTED_MODULE_1__.buffers.fixed();

  var closed = false;
  var takers = [];

  (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(buffer, _utils__WEBPACK_IMPORTED_MODULE_0__.is.buffer, INVALID_BUFFER);

  function checkForbiddenStates() {
    if (closed && takers.length) {
      throw (0,_utils__WEBPACK_IMPORTED_MODULE_0__.internalErr)('Cannot have a closed channel with pending takers');
    }
    if (takers.length && !buffer.isEmpty()) {
      throw (0,_utils__WEBPACK_IMPORTED_MODULE_0__.internalErr)('Cannot have pending takers with non empty buffer');
    }
  }

  function put(input) {
    checkForbiddenStates();
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(input, _utils__WEBPACK_IMPORTED_MODULE_0__.is.notUndef, UNDEFINED_INPUT_ERROR);
    if (closed) {
      return;
    }
    if (!takers.length) {
      return buffer.put(input);
    }
    for (var i = 0; i < takers.length; i++) {
      var cb = takers[i];
      if (!cb[_utils__WEBPACK_IMPORTED_MODULE_0__.MATCH] || cb[_utils__WEBPACK_IMPORTED_MODULE_0__.MATCH](input)) {
        takers.splice(i, 1);
        return cb(input);
      }
    }
  }

  function take(cb) {
    checkForbiddenStates();
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(cb, _utils__WEBPACK_IMPORTED_MODULE_0__.is.func, "channel.take's callback must be a function");

    if (closed && buffer.isEmpty()) {
      cb(END);
    } else if (!buffer.isEmpty()) {
      cb(buffer.take());
    } else {
      takers.push(cb);
      cb.cancel = function () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.remove)(takers, cb);
      };
    }
  }

  function flush(cb) {
    checkForbiddenStates(); // TODO: check if some new state should be forbidden now
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(cb, _utils__WEBPACK_IMPORTED_MODULE_0__.is.func, "channel.flush' callback must be a function");
    if (closed && buffer.isEmpty()) {
      cb(END);
      return;
    }
    cb(buffer.flush());
  }

  function close() {
    checkForbiddenStates();
    if (!closed) {
      closed = true;
      if (takers.length) {
        var arr = takers;
        takers = [];
        for (var i = 0, len = arr.length; i < len; i++) {
          arr[i](END);
        }
      }
    }
  }

  return {
    take: take,
    put: put,
    flush: flush,
    close: close,
    get __takers__() {
      return takers;
    },
    get __closed__() {
      return closed;
    }
  };
}

function eventChannel(subscribe) {
  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _buffers__WEBPACK_IMPORTED_MODULE_1__.buffers.none();
  var matcher = arguments[2];

  /**
    should be if(typeof matcher !== undefined) instead?
    see PR #273 for a background discussion
  **/
  if (arguments.length > 2) {
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(matcher, _utils__WEBPACK_IMPORTED_MODULE_0__.is.func, 'Invalid match function passed to eventChannel');
  }

  var chan = channel(buffer);
  var close = function close() {
    if (!chan.__closed__) {
      if (unsubscribe) {
        unsubscribe();
      }
      chan.close();
    }
  };
  var unsubscribe = subscribe(function (input) {
    if (isEnd(input)) {
      close();
      return;
    }
    if (matcher && !matcher(input)) {
      return;
    }
    chan.put(input);
  });
  if (chan.__closed__) {
    unsubscribe();
  }

  if (!_utils__WEBPACK_IMPORTED_MODULE_0__.is.func(unsubscribe)) {
    throw new Error('in eventChannel: subscribe should return a function to unsubscribe');
  }

  return {
    take: chan.take,
    flush: chan.flush,
    close: close
  };
}

function stdChannel(subscribe) {
  var chan = eventChannel(function (cb) {
    return subscribe(function (input) {
      if (input[_utils__WEBPACK_IMPORTED_MODULE_0__.SAGA_ACTION]) {
        cb(input);
        return;
      }
      (0,_scheduler__WEBPACK_IMPORTED_MODULE_2__.asap)(function () {
        return cb(input);
      });
    });
  });

  return _extends({}, chan, {
    take: function take(cb, matcher) {
      if (arguments.length > 1) {
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(matcher, _utils__WEBPACK_IMPORTED_MODULE_0__.is.func, "channel.take's matcher argument must be a function");
        cb[_utils__WEBPACK_IMPORTED_MODULE_0__.MATCH] = matcher;
      }
      chan.take(cb);
    }
  });
}

/***/ }),

/***/ "./node_modules/redux-saga/es/internal/io-helpers.js":
/*!***********************************************************!*\
  !*** ./node_modules/redux-saga/es/internal/io-helpers.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   takeEvery: () => (/* binding */ takeEvery),
/* harmony export */   takeLatest: () => (/* binding */ takeLatest),
/* harmony export */   throttle: () => (/* binding */ throttle)
/* harmony export */ });
/* harmony import */ var _io__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./io */ "./node_modules/redux-saga/es/internal/io.js");
/* harmony import */ var _sagaHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sagaHelpers */ "./node_modules/redux-saga/es/internal/sagaHelpers/index.js");



function takeEvery(patternOrChannel, worker) {
  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  return _io__WEBPACK_IMPORTED_MODULE_0__.fork.apply(undefined, [_sagaHelpers__WEBPACK_IMPORTED_MODULE_1__.takeEveryHelper, patternOrChannel, worker].concat(args));
}

function takeLatest(patternOrChannel, worker) {
  for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }

  return _io__WEBPACK_IMPORTED_MODULE_0__.fork.apply(undefined, [_sagaHelpers__WEBPACK_IMPORTED_MODULE_1__.takeLatestHelper, patternOrChannel, worker].concat(args));
}

function throttle(ms, pattern, worker) {
  for (var _len3 = arguments.length, args = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
    args[_key3 - 3] = arguments[_key3];
  }

  return _io__WEBPACK_IMPORTED_MODULE_0__.fork.apply(undefined, [_sagaHelpers__WEBPACK_IMPORTED_MODULE_1__.throttleHelper, ms, pattern, worker].concat(args));
}

/***/ }),

/***/ "./node_modules/redux-saga/es/internal/io.js":
/*!***************************************************!*\
  !*** ./node_modules/redux-saga/es/internal/io.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   actionChannel: () => (/* binding */ actionChannel),
/* harmony export */   all: () => (/* binding */ all),
/* harmony export */   apply: () => (/* binding */ apply),
/* harmony export */   asEffect: () => (/* binding */ asEffect),
/* harmony export */   call: () => (/* binding */ call),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   cancelled: () => (/* binding */ cancelled),
/* harmony export */   cps: () => (/* binding */ cps),
/* harmony export */   detach: () => (/* binding */ detach),
/* harmony export */   flush: () => (/* binding */ flush),
/* harmony export */   fork: () => (/* binding */ fork),
/* harmony export */   getContext: () => (/* binding */ getContext),
/* harmony export */   join: () => (/* binding */ join),
/* harmony export */   put: () => (/* binding */ put),
/* harmony export */   race: () => (/* binding */ race),
/* harmony export */   select: () => (/* binding */ select),
/* harmony export */   setContext: () => (/* binding */ setContext),
/* harmony export */   spawn: () => (/* binding */ spawn),
/* harmony export */   take: () => (/* binding */ take),
/* harmony export */   takem: () => (/* binding */ takem)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/redux-saga/es/internal/utils.js");


var IO = /*#__PURE__*/(0,_utils__WEBPACK_IMPORTED_MODULE_0__.sym)('IO');
var TAKE = 'TAKE';
var PUT = 'PUT';
var ALL = 'ALL';
var RACE = 'RACE';
var CALL = 'CALL';
var CPS = 'CPS';
var FORK = 'FORK';
var JOIN = 'JOIN';
var CANCEL = 'CANCEL';
var SELECT = 'SELECT';
var ACTION_CHANNEL = 'ACTION_CHANNEL';
var CANCELLED = 'CANCELLED';
var FLUSH = 'FLUSH';
var GET_CONTEXT = 'GET_CONTEXT';
var SET_CONTEXT = 'SET_CONTEXT';

var TEST_HINT = '\n(HINT: if you are getting this errors in tests, consider using createMockTask from redux-saga/utils)';

var effect = function effect(type, payload) {
  var _ref;

  return _ref = {}, _ref[IO] = true, _ref[type] = payload, _ref;
};

var detach = function detach(eff) {
  (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(asEffect.fork(eff), _utils__WEBPACK_IMPORTED_MODULE_0__.is.object, 'detach(eff): argument must be a fork effect');
  eff[FORK].detached = true;
  return eff;
};

function take() {
  var patternOrChannel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '*';

  if (arguments.length) {
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(arguments[0], _utils__WEBPACK_IMPORTED_MODULE_0__.is.notUndef, 'take(patternOrChannel): patternOrChannel is undefined');
  }
  if (_utils__WEBPACK_IMPORTED_MODULE_0__.is.pattern(patternOrChannel)) {
    return effect(TAKE, { pattern: patternOrChannel });
  }
  if (_utils__WEBPACK_IMPORTED_MODULE_0__.is.channel(patternOrChannel)) {
    return effect(TAKE, { channel: patternOrChannel });
  }
  throw new Error('take(patternOrChannel): argument ' + String(patternOrChannel) + ' is not valid channel or a valid pattern');
}

take.maybe = function () {
  var eff = take.apply(undefined, arguments);
  eff[TAKE].maybe = true;
  return eff;
};

var takem = /*#__PURE__*/(0,_utils__WEBPACK_IMPORTED_MODULE_0__.deprecate)(take.maybe, /*#__PURE__*/(0,_utils__WEBPACK_IMPORTED_MODULE_0__.updateIncentive)('takem', 'take.maybe'));

function put(channel, action) {
  if (arguments.length > 1) {
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(channel, _utils__WEBPACK_IMPORTED_MODULE_0__.is.notUndef, 'put(channel, action): argument channel is undefined');
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(channel, _utils__WEBPACK_IMPORTED_MODULE_0__.is.channel, 'put(channel, action): argument ' + channel + ' is not a valid channel');
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(action, _utils__WEBPACK_IMPORTED_MODULE_0__.is.notUndef, 'put(channel, action): argument action is undefined');
  } else {
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(channel, _utils__WEBPACK_IMPORTED_MODULE_0__.is.notUndef, 'put(action): argument action is undefined');
    action = channel;
    channel = null;
  }
  return effect(PUT, { channel: channel, action: action });
}

put.resolve = function () {
  var eff = put.apply(undefined, arguments);
  eff[PUT].resolve = true;
  return eff;
};

put.sync = /*#__PURE__*/(0,_utils__WEBPACK_IMPORTED_MODULE_0__.deprecate)(put.resolve, /*#__PURE__*/(0,_utils__WEBPACK_IMPORTED_MODULE_0__.updateIncentive)('put.sync', 'put.resolve'));

function all(effects) {
  return effect(ALL, effects);
}

function race(effects) {
  return effect(RACE, effects);
}

function getFnCallDesc(meth, fn, args) {
  (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(fn, _utils__WEBPACK_IMPORTED_MODULE_0__.is.notUndef, meth + ': argument fn is undefined');

  var context = null;
  if (_utils__WEBPACK_IMPORTED_MODULE_0__.is.array(fn)) {
    var _fn = fn;
    context = _fn[0];
    fn = _fn[1];
  } else if (fn.fn) {
    var _fn2 = fn;
    context = _fn2.context;
    fn = _fn2.fn;
  }
  if (context && _utils__WEBPACK_IMPORTED_MODULE_0__.is.string(fn) && _utils__WEBPACK_IMPORTED_MODULE_0__.is.func(context[fn])) {
    fn = context[fn];
  }
  (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(fn, _utils__WEBPACK_IMPORTED_MODULE_0__.is.func, meth + ': argument ' + fn + ' is not a function');

  return { context: context, fn: fn, args: args };
}

function call(fn) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return effect(CALL, getFnCallDesc('call', fn, args));
}

function apply(context, fn) {
  var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  return effect(CALL, getFnCallDesc('apply', { context: context, fn: fn }, args));
}

function cps(fn) {
  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  return effect(CPS, getFnCallDesc('cps', fn, args));
}

function fork(fn) {
  for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return effect(FORK, getFnCallDesc('fork', fn, args));
}

function spawn(fn) {
  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }

  return detach(fork.apply(undefined, [fn].concat(args)));
}

function join() {
  for (var _len5 = arguments.length, tasks = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    tasks[_key5] = arguments[_key5];
  }

  if (tasks.length > 1) {
    return all(tasks.map(function (t) {
      return join(t);
    }));
  }
  var task = tasks[0];
  (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(task, _utils__WEBPACK_IMPORTED_MODULE_0__.is.notUndef, 'join(task): argument task is undefined');
  (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(task, _utils__WEBPACK_IMPORTED_MODULE_0__.is.task, 'join(task): argument ' + task + ' is not a valid Task object ' + TEST_HINT);
  return effect(JOIN, task);
}

function cancel() {
  for (var _len6 = arguments.length, tasks = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    tasks[_key6] = arguments[_key6];
  }

  if (tasks.length > 1) {
    return all(tasks.map(function (t) {
      return cancel(t);
    }));
  }
  var task = tasks[0];
  if (tasks.length === 1) {
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(task, _utils__WEBPACK_IMPORTED_MODULE_0__.is.notUndef, 'cancel(task): argument task is undefined');
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(task, _utils__WEBPACK_IMPORTED_MODULE_0__.is.task, 'cancel(task): argument ' + task + ' is not a valid Task object ' + TEST_HINT);
  }
  return effect(CANCEL, task || _utils__WEBPACK_IMPORTED_MODULE_0__.SELF_CANCELLATION);
}

function select(selector) {
  for (var _len7 = arguments.length, args = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
    args[_key7 - 1] = arguments[_key7];
  }

  if (arguments.length === 0) {
    selector = _utils__WEBPACK_IMPORTED_MODULE_0__.ident;
  } else {
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(selector, _utils__WEBPACK_IMPORTED_MODULE_0__.is.notUndef, 'select(selector,[...]): argument selector is undefined');
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(selector, _utils__WEBPACK_IMPORTED_MODULE_0__.is.func, 'select(selector,[...]): argument ' + selector + ' is not a function');
  }
  return effect(SELECT, { selector: selector, args: args });
}

/**
  channel(pattern, [buffer])    => creates an event channel for store actions
**/
function actionChannel(pattern, buffer) {
  (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(pattern, _utils__WEBPACK_IMPORTED_MODULE_0__.is.notUndef, 'actionChannel(pattern,...): argument pattern is undefined');
  if (arguments.length > 1) {
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(buffer, _utils__WEBPACK_IMPORTED_MODULE_0__.is.notUndef, 'actionChannel(pattern, buffer): argument buffer is undefined');
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(buffer, _utils__WEBPACK_IMPORTED_MODULE_0__.is.buffer, 'actionChannel(pattern, buffer): argument ' + buffer + ' is not a valid buffer');
  }
  return effect(ACTION_CHANNEL, { pattern: pattern, buffer: buffer });
}

function cancelled() {
  return effect(CANCELLED, {});
}

function flush(channel) {
  (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(channel, _utils__WEBPACK_IMPORTED_MODULE_0__.is.channel, 'flush(channel): argument ' + channel + ' is not valid channel');
  return effect(FLUSH, channel);
}

function getContext(prop) {
  (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(prop, _utils__WEBPACK_IMPORTED_MODULE_0__.is.string, 'getContext(prop): argument ' + prop + ' is not a string');
  return effect(GET_CONTEXT, prop);
}

function setContext(props) {
  (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(props, _utils__WEBPACK_IMPORTED_MODULE_0__.is.object, (0,_utils__WEBPACK_IMPORTED_MODULE_0__.createSetContextWarning)(null, props));
  return effect(SET_CONTEXT, props);
}

var createAsEffectType = function createAsEffectType(type) {
  return function (effect) {
    return effect && effect[IO] && effect[type];
  };
};

var asEffect = {
  take: /*#__PURE__*/createAsEffectType(TAKE),
  put: /*#__PURE__*/createAsEffectType(PUT),
  all: /*#__PURE__*/createAsEffectType(ALL),
  race: /*#__PURE__*/createAsEffectType(RACE),
  call: /*#__PURE__*/createAsEffectType(CALL),
  cps: /*#__PURE__*/createAsEffectType(CPS),
  fork: /*#__PURE__*/createAsEffectType(FORK),
  join: /*#__PURE__*/createAsEffectType(JOIN),
  cancel: /*#__PURE__*/createAsEffectType(CANCEL),
  select: /*#__PURE__*/createAsEffectType(SELECT),
  actionChannel: /*#__PURE__*/createAsEffectType(ACTION_CHANNEL),
  cancelled: /*#__PURE__*/createAsEffectType(CANCELLED),
  flush: /*#__PURE__*/createAsEffectType(FLUSH),
  getContext: /*#__PURE__*/createAsEffectType(GET_CONTEXT),
  setContext: /*#__PURE__*/createAsEffectType(SET_CONTEXT)
};

/***/ }),

/***/ "./node_modules/redux-saga/es/internal/middleware.js":
/*!***********************************************************!*\
  !*** ./node_modules/redux-saga/es/internal/middleware.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sagaMiddlewareFactory)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/redux-saga/es/internal/utils.js");
/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./channel */ "./node_modules/redux-saga/es/internal/channel.js");
/* harmony import */ var _runSaga__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runSaga */ "./node_modules/redux-saga/es/internal/runSaga.js");
function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






function sagaMiddlewareFactory() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _ref$context = _ref.context,
      context = _ref$context === undefined ? {} : _ref$context,
      options = _objectWithoutProperties(_ref, ['context']);

  var sagaMonitor = options.sagaMonitor,
      logger = options.logger,
      onError = options.onError;


  if (_utils__WEBPACK_IMPORTED_MODULE_0__.is.func(options)) {
    if (false) {} else {
      throw new Error('You passed a function to the Saga middleware. You are likely trying to start a        Saga by directly passing it to the middleware. This is no longer possible starting from 0.10.0.        To run a Saga, you must do it dynamically AFTER mounting the middleware into the store.\n        Example:\n          import createSagaMiddleware from \'redux-saga\'\n          ... other imports\n\n          const sagaMiddleware = createSagaMiddleware()\n          const store = createStore(reducer, applyMiddleware(sagaMiddleware))\n          sagaMiddleware.run(saga, ...args)\n      ');
    }
  }

  if (logger && !_utils__WEBPACK_IMPORTED_MODULE_0__.is.func(logger)) {
    throw new Error('`options.logger` passed to the Saga middleware is not a function!');
  }

  if ( true && options.onerror) {
    throw new Error('`options.onerror` was removed. Use `options.onError` instead.');
  }

  if (onError && !_utils__WEBPACK_IMPORTED_MODULE_0__.is.func(onError)) {
    throw new Error('`options.onError` passed to the Saga middleware is not a function!');
  }

  if (options.emitter && !_utils__WEBPACK_IMPORTED_MODULE_0__.is.func(options.emitter)) {
    throw new Error('`options.emitter` passed to the Saga middleware is not a function!');
  }

  function sagaMiddleware(_ref2) {
    var getState = _ref2.getState,
        dispatch = _ref2.dispatch;

    var sagaEmitter = (0,_channel__WEBPACK_IMPORTED_MODULE_1__.emitter)();
    sagaEmitter.emit = (options.emitter || _utils__WEBPACK_IMPORTED_MODULE_0__.ident)(sagaEmitter.emit);

    sagaMiddleware.run = _runSaga__WEBPACK_IMPORTED_MODULE_2__.runSaga.bind(null, {
      context: context,
      subscribe: sagaEmitter.subscribe,
      dispatch: dispatch,
      getState: getState,
      sagaMonitor: sagaMonitor,
      logger: logger,
      onError: onError
    });

    return function (next) {
      return function (action) {
        if (sagaMonitor && sagaMonitor.actionDispatched) {
          sagaMonitor.actionDispatched(action);
        }
        var result = next(action); // hit reducers
        sagaEmitter.emit(action);
        return result;
      };
    };
  }

  sagaMiddleware.run = function () {
    throw new Error('Before running a Saga, you must mount the Saga middleware on the Store using applyMiddleware');
  };

  sagaMiddleware.setContext = function (props) {
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(props, _utils__WEBPACK_IMPORTED_MODULE_0__.is.object, (0,_utils__WEBPACK_IMPORTED_MODULE_0__.createSetContextWarning)('sagaMiddleware', props));
    _utils__WEBPACK_IMPORTED_MODULE_0__.object.assign(context, props);
  };

  return sagaMiddleware;
}

/***/ }),

/***/ "./node_modules/redux-saga/es/internal/proc.js":
/*!*****************************************************!*\
  !*** ./node_modules/redux-saga/es/internal/proc.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CHANNEL_END: () => (/* binding */ CHANNEL_END),
/* harmony export */   NOT_ITERATOR_ERROR: () => (/* binding */ NOT_ITERATOR_ERROR),
/* harmony export */   TASK_CANCEL: () => (/* binding */ TASK_CANCEL),
/* harmony export */   "default": () => (/* binding */ proc)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/redux-saga/es/internal/utils.js");
/* harmony import */ var _scheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scheduler */ "./node_modules/redux-saga/es/internal/scheduler.js");
/* harmony import */ var _io__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./io */ "./node_modules/redux-saga/es/internal/io.js");
/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./channel */ "./node_modules/redux-saga/es/internal/channel.js");
/* harmony import */ var _buffers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./buffers */ "./node_modules/redux-saga/es/internal/buffers.js");
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineEnumerableProperties(obj, descs) { for (var key in descs) { var desc = descs[key]; desc.configurable = desc.enumerable = true; if ("value" in desc) desc.writable = true; Object.defineProperty(obj, key, desc); } return obj; }







var NOT_ITERATOR_ERROR = 'proc first argument (Saga function result) must be an iterator';

var CHANNEL_END = {
  toString: function toString() {
    return '@@redux-saga/CHANNEL_END';
  }
};
var TASK_CANCEL = {
  toString: function toString() {
    return '@@redux-saga/TASK_CANCEL';
  }
};

var matchers = {
  wildcard: function wildcard() {
    return _utils__WEBPACK_IMPORTED_MODULE_0__.kTrue;
  },
  default: function _default(pattern) {
    return (typeof pattern === 'undefined' ? 'undefined' : _typeof(pattern)) === 'symbol' ? function (input) {
      return input.type === pattern;
    } : function (input) {
      return input.type === String(pattern);
    };
  },
  array: function array(patterns) {
    return function (input) {
      return patterns.some(function (p) {
        return matcher(p)(input);
      });
    };
  },
  predicate: function predicate(_predicate) {
    return function (input) {
      return _predicate(input);
    };
  }
};

function matcher(pattern) {
  // prettier-ignore
  return (pattern === '*' ? matchers.wildcard : _utils__WEBPACK_IMPORTED_MODULE_0__.is.array(pattern) ? matchers.array : _utils__WEBPACK_IMPORTED_MODULE_0__.is.stringableFunc(pattern) ? matchers.default : _utils__WEBPACK_IMPORTED_MODULE_0__.is.func(pattern) ? matchers.predicate : matchers.default)(pattern);
}

/**
  Used to track a parent task and its forks
  In the new fork model, forked tasks are attached by default to their parent
  We model this using the concept of Parent task && main Task
  main task is the main flow of the current Generator, the parent tasks is the
  aggregation of the main tasks + all its forked tasks.
  Thus the whole model represents an execution tree with multiple branches (vs the
  linear execution tree in sequential (non parallel) programming)

  A parent tasks has the following semantics
  - It completes if all its forks either complete or all cancelled
  - If it's cancelled, all forks are cancelled as well
  - It aborts if any uncaught error bubbles up from forks
  - If it completes, the return value is the one returned by the main task
**/
function forkQueue(name, mainTask, cb) {
  var tasks = [],
      result = void 0,
      completed = false;
  addTask(mainTask);

  function abort(err) {
    cancelAll();
    cb(err, true);
  }

  function addTask(task) {
    tasks.push(task);
    task.cont = function (res, isErr) {
      if (completed) {
        return;
      }

      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.remove)(tasks, task);
      task.cont = _utils__WEBPACK_IMPORTED_MODULE_0__.noop;
      if (isErr) {
        abort(res);
      } else {
        if (task === mainTask) {
          result = res;
        }
        if (!tasks.length) {
          completed = true;
          cb(result);
        }
      }
    };
    // task.cont.cancel = task.cancel
  }

  function cancelAll() {
    if (completed) {
      return;
    }
    completed = true;
    tasks.forEach(function (t) {
      t.cont = _utils__WEBPACK_IMPORTED_MODULE_0__.noop;
      t.cancel();
    });
    tasks = [];
  }

  return {
    addTask: addTask,
    cancelAll: cancelAll,
    abort: abort,
    getTasks: function getTasks() {
      return tasks;
    },
    taskNames: function taskNames() {
      return tasks.map(function (t) {
        return t.name;
      });
    }
  };
}

function createTaskIterator(_ref) {
  var context = _ref.context,
      fn = _ref.fn,
      args = _ref.args;

  if (_utils__WEBPACK_IMPORTED_MODULE_0__.is.iterator(fn)) {
    return fn;
  }

  // catch synchronous failures; see #152 and #441
  var result = void 0,
      error = void 0;
  try {
    result = fn.apply(context, args);
  } catch (err) {
    error = err;
  }

  // i.e. a generator function returns an iterator
  if (_utils__WEBPACK_IMPORTED_MODULE_0__.is.iterator(result)) {
    return result;
  }

  // do not bubble up synchronous failures for detached forks
  // instead create a failed task. See #152 and #441
  return error ? (0,_utils__WEBPACK_IMPORTED_MODULE_0__.makeIterator)(function () {
    throw error;
  }) : (0,_utils__WEBPACK_IMPORTED_MODULE_0__.makeIterator)(function () {
    var pc = void 0;
    var eff = { done: false, value: result };
    var ret = function ret(value) {
      return { done: true, value: value };
    };
    return function (arg) {
      if (!pc) {
        pc = true;
        return eff;
      } else {
        return ret(arg);
      }
    };
  }());
}

var wrapHelper = function wrapHelper(helper) {
  return { fn: helper };
};

function proc(iterator) {
  var subscribe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
    return _utils__WEBPACK_IMPORTED_MODULE_0__.noop;
  };
  var dispatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _utils__WEBPACK_IMPORTED_MODULE_0__.noop;
  var getState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _utils__WEBPACK_IMPORTED_MODULE_0__.noop;
  var parentContext = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
  var parentEffectId = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var name = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'anonymous';
  var cont = arguments[8];

  (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(iterator, _utils__WEBPACK_IMPORTED_MODULE_0__.is.iterator, NOT_ITERATOR_ERROR);

  var effectsString = '[...effects]';
  var runParallelEffect = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.deprecate)(runAllEffect, (0,_utils__WEBPACK_IMPORTED_MODULE_0__.updateIncentive)(effectsString, 'all(' + effectsString + ')'));

  var sagaMonitor = options.sagaMonitor,
      logger = options.logger,
      onError = options.onError;

  var log = logger || _utils__WEBPACK_IMPORTED_MODULE_0__.log;
  var logError = function logError(err) {
    var message = err.sagaStack;

    if (!message && err.stack) {
      message = err.stack.split('\n')[0].indexOf(err.message) !== -1 ? err.stack : 'Error: ' + err.message + '\n' + err.stack;
    }

    log('error', 'uncaught at ' + name, message || err.message || err);
  };
  var stdChannel = (0,_channel__WEBPACK_IMPORTED_MODULE_3__.stdChannel)(subscribe);
  var taskContext = Object.create(parentContext);
  /**
    Tracks the current effect cancellation
    Each time the generator progresses. calling runEffect will set a new value
    on it. It allows propagating cancellation to child effects
  **/
  next.cancel = _utils__WEBPACK_IMPORTED_MODULE_0__.noop;

  /**
    Creates a new task descriptor for this generator, We'll also create a main task
    to track the main flow (besides other forked tasks)
  **/
  var task = newTask(parentEffectId, name, iterator, cont);
  var mainTask = { name: name, cancel: cancelMain, isRunning: true };
  var taskQueue = forkQueue(name, mainTask, end);

  /**
    cancellation of the main task. We'll simply resume the Generator with a Cancel
  **/
  function cancelMain() {
    if (mainTask.isRunning && !mainTask.isCancelled) {
      mainTask.isCancelled = true;
      next(TASK_CANCEL);
    }
  }

  /**
    This may be called by a parent generator to trigger/propagate cancellation
    cancel all pending tasks (including the main task), then end the current task.
     Cancellation propagates down to the whole execution tree holded by this Parent task
    It's also propagated to all joiners of this task and their execution tree/joiners
     Cancellation is noop for terminated/Cancelled tasks tasks
  **/
  function cancel() {
    /**
      We need to check both Running and Cancelled status
      Tasks can be Cancelled but still Running
    **/
    if (iterator._isRunning && !iterator._isCancelled) {
      iterator._isCancelled = true;
      taskQueue.cancelAll();
      /**
        Ending with a Never result will propagate the Cancellation to all joiners
      **/
      end(TASK_CANCEL);
    }
  }
  /**
    attaches cancellation logic to this task's continuation
    this will permit cancellation to propagate down the call chain
  **/
  cont && (cont.cancel = cancel);

  // tracks the running status
  iterator._isRunning = true;

  // kicks up the generator
  next();

  // then return the task descriptor to the caller
  return task;

  /**
    This is the generator driver
    It's a recursive async/continuation function which calls itself
    until the generator terminates or throws
  **/
  function next(arg, isErr) {
    // Preventive measure. If we end up here, then there is really something wrong
    if (!mainTask.isRunning) {
      throw new Error('Trying to resume an already finished generator');
    }

    try {
      var result = void 0;
      if (isErr) {
        result = iterator.throw(arg);
      } else if (arg === TASK_CANCEL) {
        /**
          getting TASK_CANCEL automatically cancels the main task
          We can get this value here
           - By cancelling the parent task manually
          - By joining a Cancelled task
        **/
        mainTask.isCancelled = true;
        /**
          Cancels the current effect; this will propagate the cancellation down to any called tasks
        **/
        next.cancel();
        /**
          If this Generator has a `return` method then invokes it
          This will jump to the finally block
        **/
        result = _utils__WEBPACK_IMPORTED_MODULE_0__.is.func(iterator.return) ? iterator.return(TASK_CANCEL) : { done: true, value: TASK_CANCEL };
      } else if (arg === CHANNEL_END) {
        // We get CHANNEL_END by taking from a channel that ended using `take` (and not `takem` used to trap End of channels)
        result = _utils__WEBPACK_IMPORTED_MODULE_0__.is.func(iterator.return) ? iterator.return() : { done: true };
      } else {
        result = iterator.next(arg);
      }

      if (!result.done) {
        runEffect(result.value, parentEffectId, '', next);
      } else {
        /**
          This Generator has ended, terminate the main task and notify the fork queue
        **/
        mainTask.isMainRunning = false;
        mainTask.cont && mainTask.cont(result.value);
      }
    } catch (error) {
      if (mainTask.isCancelled) {
        logError(error);
      }
      mainTask.isMainRunning = false;
      mainTask.cont(error, true);
    }
  }

  function end(result, isErr) {
    iterator._isRunning = false;
    stdChannel.close();
    if (!isErr) {
      iterator._result = result;
      iterator._deferredEnd && iterator._deferredEnd.resolve(result);
    } else {
      if (result instanceof Error) {
        Object.defineProperty(result, 'sagaStack', {
          value: 'at ' + name + ' \n ' + (result.sagaStack || result.stack),
          configurable: true
        });
      }
      if (!task.cont) {
        if (result instanceof Error && onError) {
          onError(result);
        } else {
          logError(result);
        }
      }
      iterator._error = result;
      iterator._isAborted = true;
      iterator._deferredEnd && iterator._deferredEnd.reject(result);
    }
    task.cont && task.cont(result, isErr);
    task.joiners.forEach(function (j) {
      return j.cb(result, isErr);
    });
    task.joiners = null;
  }

  function runEffect(effect, parentEffectId) {
    var label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var cb = arguments[3];

    var effectId = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.uid)();
    sagaMonitor && sagaMonitor.effectTriggered({ effectId: effectId, parentEffectId: parentEffectId, label: label, effect: effect });

    /**
      completion callback and cancel callback are mutually exclusive
      We can't cancel an already completed effect
      And We can't complete an already cancelled effectId
    **/
    var effectSettled = void 0;

    // Completion callback passed to the appropriate effect runner
    function currCb(res, isErr) {
      if (effectSettled) {
        return;
      }

      effectSettled = true;
      cb.cancel = _utils__WEBPACK_IMPORTED_MODULE_0__.noop; // defensive measure
      if (sagaMonitor) {
        isErr ? sagaMonitor.effectRejected(effectId, res) : sagaMonitor.effectResolved(effectId, res);
      }
      cb(res, isErr);
    }
    // tracks down the current cancel
    currCb.cancel = _utils__WEBPACK_IMPORTED_MODULE_0__.noop;

    // setup cancellation logic on the parent cb
    cb.cancel = function () {
      // prevents cancelling an already completed effect
      if (effectSettled) {
        return;
      }

      effectSettled = true;
      /**
        propagates cancel downward
        catch uncaught cancellations errors; since we can no longer call the completion
        callback, log errors raised during cancellations into the console
      **/
      try {
        currCb.cancel();
      } catch (err) {
        logError(err);
      }
      currCb.cancel = _utils__WEBPACK_IMPORTED_MODULE_0__.noop; // defensive measure

      sagaMonitor && sagaMonitor.effectCancelled(effectId);
    };

    /**
      each effect runner must attach its own logic of cancellation to the provided callback
      it allows this generator to propagate cancellation downward.
       ATTENTION! effect runners must setup the cancel logic by setting cb.cancel = [cancelMethod]
      And the setup must occur before calling the callback
       This is a sort of inversion of control: called async functions are responsible
      for completing the flow by calling the provided continuation; while caller functions
      are responsible for aborting the current flow by calling the attached cancel function
       Library users can attach their own cancellation logic to promises by defining a
      promise[CANCEL] method in their returned promises
      ATTENTION! calling cancel must have no effect on an already completed or cancelled effect
    **/
    var data = void 0;
    // prettier-ignore
    return (
      // Non declarative effect
      _utils__WEBPACK_IMPORTED_MODULE_0__.is.promise(effect) ? resolvePromise(effect, currCb) : _utils__WEBPACK_IMPORTED_MODULE_0__.is.helper(effect) ? runForkEffect(wrapHelper(effect), effectId, currCb) : _utils__WEBPACK_IMPORTED_MODULE_0__.is.iterator(effect) ? resolveIterator(effect, effectId, name, currCb)

      // declarative effects
      : _utils__WEBPACK_IMPORTED_MODULE_0__.is.array(effect) ? runParallelEffect(effect, effectId, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.take(effect)) ? runTakeEffect(data, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.put(effect)) ? runPutEffect(data, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.all(effect)) ? runAllEffect(data, effectId, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.race(effect)) ? runRaceEffect(data, effectId, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.call(effect)) ? runCallEffect(data, effectId, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.cps(effect)) ? runCPSEffect(data, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.fork(effect)) ? runForkEffect(data, effectId, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.join(effect)) ? runJoinEffect(data, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.cancel(effect)) ? runCancelEffect(data, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.select(effect)) ? runSelectEffect(data, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.actionChannel(effect)) ? runChannelEffect(data, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.flush(effect)) ? runFlushEffect(data, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.cancelled(effect)) ? runCancelledEffect(data, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.getContext(effect)) ? runGetContextEffect(data, currCb) : (data = _io__WEBPACK_IMPORTED_MODULE_2__.asEffect.setContext(effect)) ? runSetContextEffect(data, currCb) : /* anything else returned as is */currCb(effect)
    );
  }

  function resolvePromise(promise, cb) {
    var cancelPromise = promise[_utils__WEBPACK_IMPORTED_MODULE_0__.CANCEL];
    if (_utils__WEBPACK_IMPORTED_MODULE_0__.is.func(cancelPromise)) {
      cb.cancel = cancelPromise;
    } else if (_utils__WEBPACK_IMPORTED_MODULE_0__.is.func(promise.abort)) {
      cb.cancel = function () {
        return promise.abort();
      };
      // TODO: add support for the fetch API, whenever they get around to
      // adding cancel support
    }
    promise.then(cb, function (error) {
      return cb(error, true);
    });
  }

  function resolveIterator(iterator, effectId, name, cb) {
    proc(iterator, subscribe, dispatch, getState, taskContext, options, effectId, name, cb);
  }

  function runTakeEffect(_ref2, cb) {
    var channel = _ref2.channel,
        pattern = _ref2.pattern,
        maybe = _ref2.maybe;

    channel = channel || stdChannel;
    var takeCb = function takeCb(inp) {
      return inp instanceof Error ? cb(inp, true) : (0,_channel__WEBPACK_IMPORTED_MODULE_3__.isEnd)(inp) && !maybe ? cb(CHANNEL_END) : cb(inp);
    };
    try {
      channel.take(takeCb, matcher(pattern));
    } catch (err) {
      return cb(err, true);
    }
    cb.cancel = takeCb.cancel;
  }

  function runPutEffect(_ref3, cb) {
    var channel = _ref3.channel,
        action = _ref3.action,
        resolve = _ref3.resolve;

    /**
      Schedule the put in case another saga is holding a lock.
      The put will be executed atomically. ie nested puts will execute after
      this put has terminated.
    **/
    (0,_scheduler__WEBPACK_IMPORTED_MODULE_1__.asap)(function () {
      var result = void 0;
      try {
        result = (channel ? channel.put : dispatch)(action);
      } catch (error) {
        // If we have a channel or `put.resolve` was used then bubble up the error.
        if (channel || resolve) return cb(error, true);
        logError(error);
      }

      if (resolve && _utils__WEBPACK_IMPORTED_MODULE_0__.is.promise(result)) {
        resolvePromise(result, cb);
      } else {
        return cb(result);
      }
    });
    // Put effects are non cancellables
  }

  function runCallEffect(_ref4, effectId, cb) {
    var context = _ref4.context,
        fn = _ref4.fn,
        args = _ref4.args;

    var result = void 0;
    // catch synchronous failures; see #152
    try {
      result = fn.apply(context, args);
    } catch (error) {
      return cb(error, true);
    }
    return _utils__WEBPACK_IMPORTED_MODULE_0__.is.promise(result) ? resolvePromise(result, cb) : _utils__WEBPACK_IMPORTED_MODULE_0__.is.iterator(result) ? resolveIterator(result, effectId, fn.name, cb) : cb(result);
  }

  function runCPSEffect(_ref5, cb) {
    var context = _ref5.context,
        fn = _ref5.fn,
        args = _ref5.args;

    // CPS (ie node style functions) can define their own cancellation logic
    // by setting cancel field on the cb

    // catch synchronous failures; see #152
    try {
      var cpsCb = function cpsCb(err, res) {
        return _utils__WEBPACK_IMPORTED_MODULE_0__.is.undef(err) ? cb(res) : cb(err, true);
      };
      fn.apply(context, args.concat(cpsCb));
      if (cpsCb.cancel) {
        cb.cancel = function () {
          return cpsCb.cancel();
        };
      }
    } catch (error) {
      return cb(error, true);
    }
  }

  function runForkEffect(_ref6, effectId, cb) {
    var context = _ref6.context,
        fn = _ref6.fn,
        args = _ref6.args,
        detached = _ref6.detached;

    var taskIterator = createTaskIterator({ context: context, fn: fn, args: args });

    try {
      (0,_scheduler__WEBPACK_IMPORTED_MODULE_1__.suspend)();
      var _task = proc(taskIterator, subscribe, dispatch, getState, taskContext, options, effectId, fn.name, detached ? null : _utils__WEBPACK_IMPORTED_MODULE_0__.noop);

      if (detached) {
        cb(_task);
      } else {
        if (taskIterator._isRunning) {
          taskQueue.addTask(_task);
          cb(_task);
        } else if (taskIterator._error) {
          taskQueue.abort(taskIterator._error);
        } else {
          cb(_task);
        }
      }
    } finally {
      (0,_scheduler__WEBPACK_IMPORTED_MODULE_1__.flush)();
    }
    // Fork effects are non cancellables
  }

  function runJoinEffect(t, cb) {
    if (t.isRunning()) {
      var joiner = { task: task, cb: cb };
      cb.cancel = function () {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.remove)(t.joiners, joiner);
      };
      t.joiners.push(joiner);
    } else {
      t.isAborted() ? cb(t.error(), true) : cb(t.result());
    }
  }

  function runCancelEffect(taskToCancel, cb) {
    if (taskToCancel === _utils__WEBPACK_IMPORTED_MODULE_0__.SELF_CANCELLATION) {
      taskToCancel = task;
    }
    if (taskToCancel.isRunning()) {
      taskToCancel.cancel();
    }
    cb();
    // cancel effects are non cancellables
  }

  function runAllEffect(effects, effectId, cb) {
    var keys = Object.keys(effects);

    if (!keys.length) {
      return cb(_utils__WEBPACK_IMPORTED_MODULE_0__.is.array(effects) ? [] : {});
    }

    var completedCount = 0;
    var completed = void 0;
    var results = {};
    var childCbs = {};

    function checkEffectEnd() {
      if (completedCount === keys.length) {
        completed = true;
        cb(_utils__WEBPACK_IMPORTED_MODULE_0__.is.array(effects) ? _utils__WEBPACK_IMPORTED_MODULE_0__.array.from(_extends({}, results, { length: keys.length })) : results);
      }
    }

    keys.forEach(function (key) {
      var chCbAtKey = function chCbAtKey(res, isErr) {
        if (completed) {
          return;
        }
        if (isErr || (0,_channel__WEBPACK_IMPORTED_MODULE_3__.isEnd)(res) || res === CHANNEL_END || res === TASK_CANCEL) {
          cb.cancel();
          cb(res, isErr);
        } else {
          results[key] = res;
          completedCount++;
          checkEffectEnd();
        }
      };
      chCbAtKey.cancel = _utils__WEBPACK_IMPORTED_MODULE_0__.noop;
      childCbs[key] = chCbAtKey;
    });

    cb.cancel = function () {
      if (!completed) {
        completed = true;
        keys.forEach(function (key) {
          return childCbs[key].cancel();
        });
      }
    };

    keys.forEach(function (key) {
      return runEffect(effects[key], effectId, key, childCbs[key]);
    });
  }

  function runRaceEffect(effects, effectId, cb) {
    var completed = void 0;
    var keys = Object.keys(effects);
    var childCbs = {};

    keys.forEach(function (key) {
      var chCbAtKey = function chCbAtKey(res, isErr) {
        if (completed) {
          return;
        }

        if (isErr) {
          // Race Auto cancellation
          cb.cancel();
          cb(res, true);
        } else if (!(0,_channel__WEBPACK_IMPORTED_MODULE_3__.isEnd)(res) && res !== CHANNEL_END && res !== TASK_CANCEL) {
          var _response;

          cb.cancel();
          completed = true;
          var response = (_response = {}, _response[key] = res, _response);
          cb(_utils__WEBPACK_IMPORTED_MODULE_0__.is.array(effects) ? [].slice.call(_extends({}, response, { length: keys.length })) : response);
        }
      };
      chCbAtKey.cancel = _utils__WEBPACK_IMPORTED_MODULE_0__.noop;
      childCbs[key] = chCbAtKey;
    });

    cb.cancel = function () {
      // prevents unnecessary cancellation
      if (!completed) {
        completed = true;
        keys.forEach(function (key) {
          return childCbs[key].cancel();
        });
      }
    };
    keys.forEach(function (key) {
      if (completed) {
        return;
      }
      runEffect(effects[key], effectId, key, childCbs[key]);
    });
  }

  function runSelectEffect(_ref7, cb) {
    var selector = _ref7.selector,
        args = _ref7.args;

    try {
      var state = selector.apply(undefined, [getState()].concat(args));
      cb(state);
    } catch (error) {
      cb(error, true);
    }
  }

  function runChannelEffect(_ref8, cb) {
    var pattern = _ref8.pattern,
        buffer = _ref8.buffer;

    var match = matcher(pattern);
    match.pattern = pattern;
    cb((0,_channel__WEBPACK_IMPORTED_MODULE_3__.eventChannel)(subscribe, buffer || _buffers__WEBPACK_IMPORTED_MODULE_4__.buffers.fixed(), match));
  }

  function runCancelledEffect(data, cb) {
    cb(!!mainTask.isCancelled);
  }

  function runFlushEffect(channel, cb) {
    channel.flush(cb);
  }

  function runGetContextEffect(prop, cb) {
    cb(taskContext[prop]);
  }

  function runSetContextEffect(props, cb) {
    _utils__WEBPACK_IMPORTED_MODULE_0__.object.assign(taskContext, props);
    cb();
  }

  function newTask(id, name, iterator, cont) {
    var _done, _ref9, _mutatorMap;

    iterator._deferredEnd = null;
    return _ref9 = {}, _ref9[_utils__WEBPACK_IMPORTED_MODULE_0__.TASK] = true, _ref9.id = id, _ref9.name = name, _done = 'done', _mutatorMap = {}, _mutatorMap[_done] = _mutatorMap[_done] || {}, _mutatorMap[_done].get = function () {
      if (iterator._deferredEnd) {
        return iterator._deferredEnd.promise;
      } else {
        var def = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.deferred)();
        iterator._deferredEnd = def;
        if (!iterator._isRunning) {
          iterator._error ? def.reject(iterator._error) : def.resolve(iterator._result);
        }
        return def.promise;
      }
    }, _ref9.cont = cont, _ref9.joiners = [], _ref9.cancel = cancel, _ref9.isRunning = function isRunning() {
      return iterator._isRunning;
    }, _ref9.isCancelled = function isCancelled() {
      return iterator._isCancelled;
    }, _ref9.isAborted = function isAborted() {
      return iterator._isAborted;
    }, _ref9.result = function result() {
      return iterator._result;
    }, _ref9.error = function error() {
      return iterator._error;
    }, _ref9.setContext = function setContext(props) {
      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(props, _utils__WEBPACK_IMPORTED_MODULE_0__.is.object, (0,_utils__WEBPACK_IMPORTED_MODULE_0__.createSetContextWarning)('task', props));
      _utils__WEBPACK_IMPORTED_MODULE_0__.object.assign(taskContext, props);
    }, _defineEnumerableProperties(_ref9, _mutatorMap), _ref9;
  }
}

/***/ }),

/***/ "./node_modules/redux-saga/es/internal/runSaga.js":
/*!********************************************************!*\
  !*** ./node_modules/redux-saga/es/internal/runSaga.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   runSaga: () => (/* binding */ runSaga)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/redux-saga/es/internal/utils.js");
/* harmony import */ var _proc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./proc */ "./node_modules/redux-saga/es/internal/proc.js");



var RUN_SAGA_SIGNATURE = 'runSaga(storeInterface, saga, ...args)';
var NON_GENERATOR_ERR = RUN_SAGA_SIGNATURE + ': saga argument must be a Generator function!';

function runSaga(storeInterface, saga) {
  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var iterator = void 0;

  if (_utils__WEBPACK_IMPORTED_MODULE_0__.is.iterator(storeInterface)) {
    if (true) {
      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.log)('warn', 'runSaga(iterator, storeInterface) has been deprecated in favor of ' + RUN_SAGA_SIGNATURE);
    }
    iterator = storeInterface;
    storeInterface = saga;
  } else {
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(saga, _utils__WEBPACK_IMPORTED_MODULE_0__.is.func, NON_GENERATOR_ERR);
    iterator = saga.apply(undefined, args);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.check)(iterator, _utils__WEBPACK_IMPORTED_MODULE_0__.is.iterator, NON_GENERATOR_ERR);
  }

  var _storeInterface = storeInterface,
      subscribe = _storeInterface.subscribe,
      dispatch = _storeInterface.dispatch,
      getState = _storeInterface.getState,
      context = _storeInterface.context,
      sagaMonitor = _storeInterface.sagaMonitor,
      logger = _storeInterface.logger,
      onError = _storeInterface.onError;


  var effectId = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.uid)();

  if (sagaMonitor) {
    // monitors are expected to have a certain interface, let's fill-in any missing ones
    sagaMonitor.effectTriggered = sagaMonitor.effectTriggered || _utils__WEBPACK_IMPORTED_MODULE_0__.noop;
    sagaMonitor.effectResolved = sagaMonitor.effectResolved || _utils__WEBPACK_IMPORTED_MODULE_0__.noop;
    sagaMonitor.effectRejected = sagaMonitor.effectRejected || _utils__WEBPACK_IMPORTED_MODULE_0__.noop;
    sagaMonitor.effectCancelled = sagaMonitor.effectCancelled || _utils__WEBPACK_IMPORTED_MODULE_0__.noop;
    sagaMonitor.actionDispatched = sagaMonitor.actionDispatched || _utils__WEBPACK_IMPORTED_MODULE_0__.noop;

    sagaMonitor.effectTriggered({ effectId: effectId, root: true, parentEffectId: 0, effect: { root: true, saga: saga, args: args } });
  }

  var task = (0,_proc__WEBPACK_IMPORTED_MODULE_1__["default"])(iterator, subscribe, (0,_utils__WEBPACK_IMPORTED_MODULE_0__.wrapSagaDispatch)(dispatch), getState, context, { sagaMonitor: sagaMonitor, logger: logger, onError: onError }, effectId, saga.name);

  if (sagaMonitor) {
    sagaMonitor.effectResolved(effectId, task);
  }

  return task;
}

/***/ }),

/***/ "./node_modules/redux-saga/es/internal/sagaHelpers/fsmIterator.js":
/*!************************************************************************!*\
  !*** ./node_modules/redux-saga/es/internal/sagaHelpers/fsmIterator.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fsmIterator),
/* harmony export */   qEnd: () => (/* binding */ qEnd),
/* harmony export */   safeName: () => (/* binding */ safeName)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/redux-saga/es/internal/utils.js");


var done = { done: true, value: undefined };
var qEnd = {};

function safeName(patternOrChannel) {
  if (_utils__WEBPACK_IMPORTED_MODULE_0__.is.channel(patternOrChannel)) {
    return 'channel';
  } else if (Array.isArray(patternOrChannel)) {
    return String(patternOrChannel.map(function (entry) {
      return String(entry);
    }));
  } else {
    return String(patternOrChannel);
  }
}

function fsmIterator(fsm, q0) {
  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'iterator';

  var updateState = void 0,
      qNext = q0;

  function next(arg, error) {
    if (qNext === qEnd) {
      return done;
    }

    if (error) {
      qNext = qEnd;
      throw error;
    } else {
      updateState && updateState(arg);

      var _fsm$qNext = fsm[qNext](),
          q = _fsm$qNext[0],
          output = _fsm$qNext[1],
          _updateState = _fsm$qNext[2];

      qNext = q;
      updateState = _updateState;
      return qNext === qEnd ? done : output;
    }
  }

  return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.makeIterator)(next, function (error) {
    return next(null, error);
  }, name, true);
}

/***/ }),

/***/ "./node_modules/redux-saga/es/internal/sagaHelpers/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/redux-saga/es/internal/sagaHelpers/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   takeEvery: () => (/* binding */ takeEvery),
/* harmony export */   takeEveryHelper: () => (/* reexport safe */ _takeEvery__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   takeLatest: () => (/* binding */ takeLatest),
/* harmony export */   takeLatestHelper: () => (/* reexport safe */ _takeLatest__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   throttle: () => (/* binding */ throttle),
/* harmony export */   throttleHelper: () => (/* reexport safe */ _throttle__WEBPACK_IMPORTED_MODULE_2__["default"])
/* harmony export */ });
/* harmony import */ var _takeEvery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./takeEvery */ "./node_modules/redux-saga/es/internal/sagaHelpers/takeEvery.js");
/* harmony import */ var _takeLatest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./takeLatest */ "./node_modules/redux-saga/es/internal/sagaHelpers/takeLatest.js");
/* harmony import */ var _throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./throttle */ "./node_modules/redux-saga/es/internal/sagaHelpers/throttle.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./node_modules/redux-saga/es/internal/utils.js");






var deprecationWarning = function deprecationWarning(helperName) {
  return 'import { ' + helperName + ' } from \'redux-saga\' has been deprecated in favor of import { ' + helperName + ' } from \'redux-saga/effects\'.\nThe latter will not work with yield*, as helper effects are wrapped automatically for you in fork effect.\nTherefore yield ' + helperName + ' will return task descriptor to your saga and execute next lines of code.';
};

var takeEvery = /*#__PURE__*/(0,_utils__WEBPACK_IMPORTED_MODULE_3__.deprecate)(_takeEvery__WEBPACK_IMPORTED_MODULE_0__["default"], /*#__PURE__*/deprecationWarning('takeEvery'));
var takeLatest = /*#__PURE__*/(0,_utils__WEBPACK_IMPORTED_MODULE_3__.deprecate)(_takeLatest__WEBPACK_IMPORTED_MODULE_1__["default"], /*#__PURE__*/deprecationWarning('takeLatest'));
var throttle = /*#__PURE__*/(0,_utils__WEBPACK_IMPORTED_MODULE_3__.deprecate)(_throttle__WEBPACK_IMPORTED_MODULE_2__["default"], /*#__PURE__*/deprecationWarning('throttle'));



/***/ }),

/***/ "./node_modules/redux-saga/es/internal/sagaHelpers/takeEvery.js":
/*!**********************************************************************!*\
  !*** ./node_modules/redux-saga/es/internal/sagaHelpers/takeEvery.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ takeEvery)
/* harmony export */ });
/* harmony import */ var _fsmIterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fsmIterator */ "./node_modules/redux-saga/es/internal/sagaHelpers/fsmIterator.js");
/* harmony import */ var _io__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../io */ "./node_modules/redux-saga/es/internal/io.js");
/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../channel */ "./node_modules/redux-saga/es/internal/channel.js");




function takeEvery(patternOrChannel, worker) {
  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var yTake = { done: false, value: (0,_io__WEBPACK_IMPORTED_MODULE_1__.take)(patternOrChannel) };
  var yFork = function yFork(ac) {
    return { done: false, value: _io__WEBPACK_IMPORTED_MODULE_1__.fork.apply(undefined, [worker].concat(args, [ac])) };
  };

  var action = void 0,
      setAction = function setAction(ac) {
    return action = ac;
  };

  return (0,_fsmIterator__WEBPACK_IMPORTED_MODULE_0__["default"])({
    q1: function q1() {
      return ['q2', yTake, setAction];
    },
    q2: function q2() {
      return action === _channel__WEBPACK_IMPORTED_MODULE_2__.END ? [_fsmIterator__WEBPACK_IMPORTED_MODULE_0__.qEnd] : ['q1', yFork(action)];
    }
  }, 'q1', 'takeEvery(' + (0,_fsmIterator__WEBPACK_IMPORTED_MODULE_0__.safeName)(patternOrChannel) + ', ' + worker.name + ')');
}

/***/ }),

/***/ "./node_modules/redux-saga/es/internal/sagaHelpers/takeLatest.js":
/*!***********************************************************************!*\
  !*** ./node_modules/redux-saga/es/internal/sagaHelpers/takeLatest.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ takeLatest)
/* harmony export */ });
/* harmony import */ var _fsmIterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fsmIterator */ "./node_modules/redux-saga/es/internal/sagaHelpers/fsmIterator.js");
/* harmony import */ var _io__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../io */ "./node_modules/redux-saga/es/internal/io.js");
/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../channel */ "./node_modules/redux-saga/es/internal/channel.js");




function takeLatest(patternOrChannel, worker) {
  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var yTake = { done: false, value: (0,_io__WEBPACK_IMPORTED_MODULE_1__.take)(patternOrChannel) };
  var yFork = function yFork(ac) {
    return { done: false, value: _io__WEBPACK_IMPORTED_MODULE_1__.fork.apply(undefined, [worker].concat(args, [ac])) };
  };
  var yCancel = function yCancel(task) {
    return { done: false, value: (0,_io__WEBPACK_IMPORTED_MODULE_1__.cancel)(task) };
  };

  var task = void 0,
      action = void 0;
  var setTask = function setTask(t) {
    return task = t;
  };
  var setAction = function setAction(ac) {
    return action = ac;
  };

  return (0,_fsmIterator__WEBPACK_IMPORTED_MODULE_0__["default"])({
    q1: function q1() {
      return ['q2', yTake, setAction];
    },
    q2: function q2() {
      return action === _channel__WEBPACK_IMPORTED_MODULE_2__.END ? [_fsmIterator__WEBPACK_IMPORTED_MODULE_0__.qEnd] : task ? ['q3', yCancel(task)] : ['q1', yFork(action), setTask];
    },
    q3: function q3() {
      return ['q1', yFork(action), setTask];
    }
  }, 'q1', 'takeLatest(' + (0,_fsmIterator__WEBPACK_IMPORTED_MODULE_0__.safeName)(patternOrChannel) + ', ' + worker.name + ')');
}

/***/ }),

/***/ "./node_modules/redux-saga/es/internal/sagaHelpers/throttle.js":
/*!*********************************************************************!*\
  !*** ./node_modules/redux-saga/es/internal/sagaHelpers/throttle.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ throttle)
/* harmony export */ });
/* harmony import */ var _fsmIterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fsmIterator */ "./node_modules/redux-saga/es/internal/sagaHelpers/fsmIterator.js");
/* harmony import */ var _io__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../io */ "./node_modules/redux-saga/es/internal/io.js");
/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../channel */ "./node_modules/redux-saga/es/internal/channel.js");
/* harmony import */ var _buffers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../buffers */ "./node_modules/redux-saga/es/internal/buffers.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "./node_modules/redux-saga/es/internal/utils.js");






function throttle(delayLength, pattern, worker) {
  for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    args[_key - 3] = arguments[_key];
  }

  var action = void 0,
      channel = void 0;

  var yActionChannel = { done: false, value: (0,_io__WEBPACK_IMPORTED_MODULE_1__.actionChannel)(pattern, _buffers__WEBPACK_IMPORTED_MODULE_3__.buffers.sliding(1)) };
  var yTake = function yTake() {
    return { done: false, value: (0,_io__WEBPACK_IMPORTED_MODULE_1__.take)(channel) };
  };
  var yFork = function yFork(ac) {
    return { done: false, value: _io__WEBPACK_IMPORTED_MODULE_1__.fork.apply(undefined, [worker].concat(args, [ac])) };
  };
  var yDelay = { done: false, value: (0,_io__WEBPACK_IMPORTED_MODULE_1__.call)(_utils__WEBPACK_IMPORTED_MODULE_4__.delay, delayLength) };

  var setAction = function setAction(ac) {
    return action = ac;
  };
  var setChannel = function setChannel(ch) {
    return channel = ch;
  };

  return (0,_fsmIterator__WEBPACK_IMPORTED_MODULE_0__["default"])({
    q1: function q1() {
      return ['q2', yActionChannel, setChannel];
    },
    q2: function q2() {
      return ['q3', yTake(), setAction];
    },
    q3: function q3() {
      return action === _channel__WEBPACK_IMPORTED_MODULE_2__.END ? [_fsmIterator__WEBPACK_IMPORTED_MODULE_0__.qEnd] : ['q4', yFork(action)];
    },
    q4: function q4() {
      return ['q2', yDelay];
    }
  }, 'q1', 'throttle(' + (0,_fsmIterator__WEBPACK_IMPORTED_MODULE_0__.safeName)(pattern) + ', ' + worker.name + ')');
}

/***/ }),

/***/ "./node_modules/redux-saga/es/internal/scheduler.js":
/*!**********************************************************!*\
  !*** ./node_modules/redux-saga/es/internal/scheduler.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asap: () => (/* binding */ asap),
/* harmony export */   flush: () => (/* binding */ flush),
/* harmony export */   suspend: () => (/* binding */ suspend)
/* harmony export */ });
var queue = [];
/**
  Variable to hold a counting semaphore
  - Incrementing adds a lock and puts the scheduler in a `suspended` state (if it's not
    already suspended)
  - Decrementing releases a lock. Zero locks puts the scheduler in a `released` state. This
    triggers flushing the queued tasks.
**/
var semaphore = 0;

/**
  Executes a task 'atomically'. Tasks scheduled during this execution will be queued
  and flushed after this task has finished (assuming the scheduler endup in a released
  state).
**/
function exec(task) {
  try {
    suspend();
    task();
  } finally {
    release();
  }
}

/**
  Executes or queues a task depending on the state of the scheduler (`suspended` or `released`)
**/
function asap(task) {
  queue.push(task);

  if (!semaphore) {
    suspend();
    flush();
  }
}

/**
  Puts the scheduler in a `suspended` state. Scheduled tasks will be queued until the
  scheduler is released.
**/
function suspend() {
  semaphore++;
}

/**
  Puts the scheduler in a `released` state.
**/
function release() {
  semaphore--;
}

/**
  Releases the current lock. Executes all queued tasks if the scheduler is in the released state.
**/
function flush() {
  release();

  var task = void 0;
  while (!semaphore && (task = queue.shift()) !== undefined) {
    exec(task);
  }
}

/***/ }),

/***/ "./node_modules/redux-saga/es/internal/utils.js":
/*!******************************************************!*\
  !*** ./node_modules/redux-saga/es/internal/utils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CANCEL: () => (/* binding */ CANCEL),
/* harmony export */   HELPER: () => (/* binding */ HELPER),
/* harmony export */   MATCH: () => (/* binding */ MATCH),
/* harmony export */   SAGA_ACTION: () => (/* binding */ SAGA_ACTION),
/* harmony export */   SELF_CANCELLATION: () => (/* binding */ SELF_CANCELLATION),
/* harmony export */   TASK: () => (/* binding */ TASK),
/* harmony export */   array: () => (/* binding */ array),
/* harmony export */   arrayOfDeffered: () => (/* binding */ arrayOfDeffered),
/* harmony export */   autoInc: () => (/* binding */ autoInc),
/* harmony export */   check: () => (/* binding */ check),
/* harmony export */   cloneableGenerator: () => (/* binding */ cloneableGenerator),
/* harmony export */   createMockTask: () => (/* binding */ createMockTask),
/* harmony export */   createSetContextWarning: () => (/* binding */ createSetContextWarning),
/* harmony export */   deferred: () => (/* binding */ deferred),
/* harmony export */   delay: () => (/* binding */ delay),
/* harmony export */   deprecate: () => (/* binding */ deprecate),
/* harmony export */   hasOwn: () => (/* binding */ hasOwn),
/* harmony export */   ident: () => (/* binding */ ident),
/* harmony export */   internalErr: () => (/* binding */ internalErr),
/* harmony export */   is: () => (/* binding */ is),
/* harmony export */   kFalse: () => (/* binding */ kFalse),
/* harmony export */   kTrue: () => (/* binding */ kTrue),
/* harmony export */   konst: () => (/* binding */ konst),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   makeIterator: () => (/* binding */ makeIterator),
/* harmony export */   noop: () => (/* binding */ noop),
/* harmony export */   object: () => (/* binding */ object),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   sym: () => (/* binding */ sym),
/* harmony export */   uid: () => (/* binding */ uid),
/* harmony export */   updateIncentive: () => (/* binding */ updateIncentive),
/* harmony export */   wrapSagaDispatch: () => (/* binding */ wrapSagaDispatch)
/* harmony export */ });
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var sym = function sym(id) {
  return '@@redux-saga/' + id;
};

var TASK = /*#__PURE__*/sym('TASK');
var HELPER = /*#__PURE__*/sym('HELPER');
var MATCH = /*#__PURE__*/sym('MATCH');
var CANCEL = /*#__PURE__*/sym('CANCEL_PROMISE');
var SAGA_ACTION = /*#__PURE__*/sym('SAGA_ACTION');
var SELF_CANCELLATION = /*#__PURE__*/sym('SELF_CANCELLATION');
var konst = function konst(v) {
  return function () {
    return v;
  };
};
var kTrue = /*#__PURE__*/konst(true);
var kFalse = /*#__PURE__*/konst(false);
var noop = function noop() {};
var ident = function ident(v) {
  return v;
};

function check(value, predicate, error) {
  if (!predicate(value)) {
    log('error', 'uncaught at check', error);
    throw new Error(error);
  }
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(object, property) {
  return is.notUndef(object) && hasOwnProperty.call(object, property);
}

var is = {
  undef: function undef(v) {
    return v === null || v === undefined;
  },
  notUndef: function notUndef(v) {
    return v !== null && v !== undefined;
  },
  func: function func(f) {
    return typeof f === 'function';
  },
  number: function number(n) {
    return typeof n === 'number';
  },
  string: function string(s) {
    return typeof s === 'string';
  },
  array: Array.isArray,
  object: function object(obj) {
    return obj && !is.array(obj) && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
  },
  promise: function promise(p) {
    return p && is.func(p.then);
  },
  iterator: function iterator(it) {
    return it && is.func(it.next) && is.func(it.throw);
  },
  iterable: function iterable(it) {
    return it && is.func(Symbol) ? is.func(it[Symbol.iterator]) : is.array(it);
  },
  task: function task(t) {
    return t && t[TASK];
  },
  observable: function observable(ob) {
    return ob && is.func(ob.subscribe);
  },
  buffer: function buffer(buf) {
    return buf && is.func(buf.isEmpty) && is.func(buf.take) && is.func(buf.put);
  },
  pattern: function pattern(pat) {
    return pat && (is.string(pat) || (typeof pat === 'undefined' ? 'undefined' : _typeof(pat)) === 'symbol' || is.func(pat) || is.array(pat));
  },
  channel: function channel(ch) {
    return ch && is.func(ch.take) && is.func(ch.close);
  },
  helper: function helper(it) {
    return it && it[HELPER];
  },
  stringableFunc: function stringableFunc(f) {
    return is.func(f) && hasOwn(f, 'toString');
  }
};

var object = {
  assign: function assign(target, source) {
    for (var i in source) {
      if (hasOwn(source, i)) {
        target[i] = source[i];
      }
    }
  }
};

function remove(array, item) {
  var index = array.indexOf(item);
  if (index >= 0) {
    array.splice(index, 1);
  }
}

var array = {
  from: function from(obj) {
    var arr = Array(obj.length);
    for (var i in obj) {
      if (hasOwn(obj, i)) {
        arr[i] = obj[i];
      }
    }
    return arr;
  }
};

function deferred() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var def = _extends({}, props);
  var promise = new Promise(function (resolve, reject) {
    def.resolve = resolve;
    def.reject = reject;
  });
  def.promise = promise;
  return def;
}

function arrayOfDeffered(length) {
  var arr = [];
  for (var i = 0; i < length; i++) {
    arr.push(deferred());
  }
  return arr;
}

function delay(ms) {
  var val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  var timeoutId = void 0;
  var promise = new Promise(function (resolve) {
    timeoutId = setTimeout(function () {
      return resolve(val);
    }, ms);
  });

  promise[CANCEL] = function () {
    return clearTimeout(timeoutId);
  };

  return promise;
}

function createMockTask() {
  var _ref;

  var running = true;
  var _result = void 0,
      _error = void 0;

  return _ref = {}, _ref[TASK] = true, _ref.isRunning = function isRunning() {
    return running;
  }, _ref.result = function result() {
    return _result;
  }, _ref.error = function error() {
    return _error;
  }, _ref.setRunning = function setRunning(b) {
    return running = b;
  }, _ref.setResult = function setResult(r) {
    return _result = r;
  }, _ref.setError = function setError(e) {
    return _error = e;
  }, _ref;
}

function autoInc() {
  var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  return function () {
    return ++seed;
  };
}

var uid = /*#__PURE__*/autoInc();

var kThrow = function kThrow(err) {
  throw err;
};
var kReturn = function kReturn(value) {
  return { value: value, done: true };
};
function makeIterator(next) {
  var thro = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : kThrow;
  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var isHelper = arguments[3];

  var iterator = { name: name, next: next, throw: thro, return: kReturn };

  if (isHelper) {
    iterator[HELPER] = true;
  }
  if (typeof Symbol !== 'undefined') {
    iterator[Symbol.iterator] = function () {
      return iterator;
    };
  }
  return iterator;
}

/**
  Print error in a useful way whether in a browser environment
  (with expandable error stack traces), or in a node.js environment
  (text-only log output)
 **/
function log(level, message) {
  var error = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  /*eslint-disable no-console*/
  if (typeof window === 'undefined') {
    console.log('redux-saga ' + level + ': ' + message + '\n' + (error && error.stack || error));
  } else {
    console[level](message, error);
  }
}

function deprecate(fn, deprecationWarning) {
  return function () {
    if (true) log('warn', deprecationWarning);
    return fn.apply(undefined, arguments);
  };
}

var updateIncentive = function updateIncentive(deprecated, preferred) {
  return deprecated + ' has been deprecated in favor of ' + preferred + ', please update your code';
};

var internalErr = function internalErr(err) {
  return new Error('\n  redux-saga: Error checking hooks detected an inconsistent state. This is likely a bug\n  in redux-saga code and not yours. Thanks for reporting this in the project\'s github repo.\n  Error: ' + err + '\n');
};

var createSetContextWarning = function createSetContextWarning(ctx, props) {
  return (ctx ? ctx + '.' : '') + 'setContext(props): argument ' + props + ' is not a plain object';
};

var wrapSagaDispatch = function wrapSagaDispatch(dispatch) {
  return function (action) {
    return dispatch(Object.defineProperty(action, SAGA_ACTION, { value: true }));
  };
};

var cloneableGenerator = function cloneableGenerator(generatorFunc) {
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var history = [];
    var gen = generatorFunc.apply(undefined, args);
    return {
      next: function next(arg) {
        history.push(arg);
        return gen.next(arg);
      },
      clone: function clone() {
        var clonedGen = cloneableGenerator(generatorFunc).apply(undefined, args);
        history.forEach(function (arg) {
          return clonedGen.next(arg);
        });
        return clonedGen;
      },
      return: function _return(value) {
        return gen.return(value);
      },
      throw: function _throw(exception) {
        return gen.throw(exception);
      }
    };
  };
};

/***/ }),

/***/ "./node_modules/redux-saga/es/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/redux-saga/es/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CHANNEL_END: () => (/* reexport safe */ _internal_proc__WEBPACK_IMPORTED_MODULE_2__.CHANNEL_END),
/* harmony export */   SAGA_ACTION: () => (/* reexport safe */ _internal_utils__WEBPACK_IMPORTED_MODULE_0__.SAGA_ACTION),
/* harmony export */   TASK: () => (/* reexport safe */ _internal_utils__WEBPACK_IMPORTED_MODULE_0__.TASK),
/* harmony export */   arrayOfDeffered: () => (/* reexport safe */ _internal_utils__WEBPACK_IMPORTED_MODULE_0__.arrayOfDeffered),
/* harmony export */   asEffect: () => (/* reexport safe */ _internal_io__WEBPACK_IMPORTED_MODULE_1__.asEffect),
/* harmony export */   cloneableGenerator: () => (/* reexport safe */ _internal_utils__WEBPACK_IMPORTED_MODULE_0__.cloneableGenerator),
/* harmony export */   createMockTask: () => (/* reexport safe */ _internal_utils__WEBPACK_IMPORTED_MODULE_0__.createMockTask),
/* harmony export */   deferred: () => (/* reexport safe */ _internal_utils__WEBPACK_IMPORTED_MODULE_0__.deferred),
/* harmony export */   is: () => (/* reexport safe */ _internal_utils__WEBPACK_IMPORTED_MODULE_0__.is),
/* harmony export */   noop: () => (/* reexport safe */ _internal_utils__WEBPACK_IMPORTED_MODULE_0__.noop)
/* harmony export */ });
/* harmony import */ var _internal_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/utils */ "./node_modules/redux-saga/es/internal/utils.js");
/* harmony import */ var _internal_io__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/io */ "./node_modules/redux-saga/es/internal/io.js");
/* harmony import */ var _internal_proc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/proc */ "./node_modules/redux-saga/es/internal/proc.js");




/***/ }),

/***/ "./node_modules/redux/es/applyMiddleware.js":
/*!**************************************************!*\
  !*** ./node_modules/redux/es/applyMiddleware.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ applyMiddleware)
/* harmony export */ });
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compose */ "./node_modules/redux/es/compose.js");
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore(reducer, preloadedState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = _compose__WEBPACK_IMPORTED_MODULE_0__["default"].apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/***/ }),

/***/ "./node_modules/redux/es/bindActionCreators.js":
/*!*****************************************************!*\
  !*** ./node_modules/redux/es/bindActionCreators.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ bindActionCreators)
/* harmony export */ });
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(undefined, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}

/***/ }),

/***/ "./node_modules/redux/es/combineReducers.js":
/*!**************************************************!*\
  !*** ./node_modules/redux/es/combineReducers.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ combineReducers)
/* harmony export */ });
/* harmony import */ var _createStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createStore */ "./node_modules/redux/es/createStore.js");
/* harmony import */ var lodash_es_isPlainObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es/isPlainObject */ "./node_modules/lodash-es/isPlainObject.js");
/* harmony import */ var _utils_warning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/warning */ "./node_modules/redux/es/utils/warning.js");




function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === _createStore__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!(0,lodash_es_isPlainObject__WEBPACK_IMPORTED_MODULE_2__["default"])(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });

  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: _createStore__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (true) {
      if (typeof reducers[key] === 'undefined') {
        (0,_utils_warning__WEBPACK_IMPORTED_MODULE_1__["default"])('No reducer provided for key "' + key + '"');
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  var unexpectedKeyCache = void 0;
  if (true) {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError = void 0;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments[1];

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (true) {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        (0,_utils_warning__WEBPACK_IMPORTED_MODULE_1__["default"])(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}

/***/ }),

/***/ "./node_modules/redux/es/compose.js":
/*!******************************************!*\
  !*** ./node_modules/redux/es/compose.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ compose)
/* harmony export */ });
/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(undefined, arguments));
    };
  });
}

/***/ }),

/***/ "./node_modules/redux/es/createStore.js":
/*!**********************************************!*\
  !*** ./node_modules/redux/es/createStore.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActionTypes: () => (/* binding */ ActionTypes),
/* harmony export */   "default": () => (/* binding */ createStore)
/* harmony export */ });
/* harmony import */ var lodash_es_isPlainObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es/isPlainObject */ "./node_modules/lodash-es/isPlainObject.js");
/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! symbol-observable */ "./node_modules/symbol-observable/es/index.js");



/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = {
  INIT: '@@redux/INIT'

  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */
};function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!(0,lodash_es_isPlainObject__WEBPACK_IMPORTED_MODULE_1__["default"])(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["default"]] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["default"]] = observable, _ref2;
}

/***/ }),

/***/ "./node_modules/redux/es/index.js":
/*!****************************************!*\
  !*** ./node_modules/redux/es/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyMiddleware: () => (/* reexport safe */ _applyMiddleware__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   bindActionCreators: () => (/* reexport safe */ _bindActionCreators__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   combineReducers: () => (/* reexport safe */ _combineReducers__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   compose: () => (/* reexport safe */ _compose__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   createStore: () => (/* reexport safe */ _createStore__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _createStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createStore */ "./node_modules/redux/es/createStore.js");
/* harmony import */ var _combineReducers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./combineReducers */ "./node_modules/redux/es/combineReducers.js");
/* harmony import */ var _bindActionCreators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bindActionCreators */ "./node_modules/redux/es/bindActionCreators.js");
/* harmony import */ var _applyMiddleware__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./applyMiddleware */ "./node_modules/redux/es/applyMiddleware.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./compose */ "./node_modules/redux/es/compose.js");
/* harmony import */ var _utils_warning__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/warning */ "./node_modules/redux/es/utils/warning.js");







/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if ( true && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  (0,_utils_warning__WEBPACK_IMPORTED_MODULE_5__["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}



/***/ }),

/***/ "./node_modules/redux/es/utils/warning.js":
/*!************************************************!*\
  !*** ./node_modules/redux/es/utils/warning.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ warning)
/* harmony export */ });
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; };
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) });

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
  defineProperty(
    GeneratorFunctionPrototype,
    "constructor",
    { value: GeneratorFunction, configurable: true }
  );
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    defineProperty(this, "_invoke", { value: enqueue });
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per GeneratorResume behavior specified since ES2015:
        // ES2015 spec, step 3: https://262.ecma-international.org/6.0/#sec-generatorresume
        // Latest spec, step 2: https://tc39.es/ecma262/#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method;
    var method = delegate.iterator[methodName];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method, or a missing .next method, always terminate the
      // yield* loop.
      context.delegate = null;

      // Note: ["return"] must be used for ES3 parsing compatibility.
      if (methodName === "throw" && delegate.iterator["return"]) {
        // If the delegate iterator has a return method, give it a
        // chance to clean up.
        context.method = "return";
        context.arg = undefined;
        maybeInvokeDelegate(delegate, context);

        if (context.method === "throw") {
          // If maybeInvokeDelegate(context) changed context.method from
          // "return" to "throw", let that override the TypeError below.
          return ContinueSentinel;
        }
      }
      if (methodName !== "return") {
        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a '" + methodName + "' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(val) {
    var object = Object(val);
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable != null) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    throw new TypeError(typeof iterable + " is not iterable");
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ "./node_modules/split-on-first/index.js":
/*!**********************************************!*\
  !*** ./node_modules/split-on-first/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";


module.exports = (string, separator) => {
	if (!(typeof string === 'string' && typeof separator === 'string')) {
		throw new TypeError('Expected the arguments to be of type `string`');
	}

	if (separator === '') {
		return [string];
	}

	const separatorIndex = string.indexOf(separator);

	if (separatorIndex === -1) {
		return [string];
	}

	return [
		string.slice(0, separatorIndex),
		string.slice(separatorIndex + separator.length)
	];
};


/***/ }),

/***/ "./node_modules/strict-uri-encode/index.js":
/*!*************************************************!*\
  !*** ./node_modules/strict-uri-encode/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";

module.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);


/***/ }),

/***/ "./node_modules/symbol-observable/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/symbol-observable/es/index.js ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ "./node_modules/symbol-observable/es/ponyfill.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* global window */


var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof __webpack_require__.g !== 'undefined') {
  root = __webpack_require__.g;
} else if (true) {
  root = module;
} else {}

var result = (0,_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__["default"])(root);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (result);


/***/ }),

/***/ "./node_modules/symbol-observable/es/ponyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/symbol-observable/es/ponyfill.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ symbolObservablePonyfill)
/* harmony export */ });
function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};


/***/ }),

/***/ "./node_modules/url-search-params/build/url-search-params.node.js":
/*!************************************************************************!*\
  !*** ./node_modules/url-search-params/build/url-search-params.node.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
Copyright (C) 2015-2017 Andrea Giammarchi - @WebReflection

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/


function URLSearchParams(query) {
  var
    index, key, value,
    pairs, i, length,
    dict = Object.create(null)
  ;
  this[secret] = dict;
  if (!query) return;
  if (typeof query === 'string') {
    if (query.charAt(0) === '?') {
      query = query.slice(1);
    }
    for (
      pairs = query.split('&'),
      i = 0,
      length = pairs.length; i < length; i++
    ) {
      value = pairs[i];
      index = value.indexOf('=');
      if (-1 < index) {
        appendTo(
          dict,
          decode(value.slice(0, index)),
          decode(value.slice(index + 1))
        );
      } else if (value.length){
        appendTo(
          dict,
          decode(value),
          ''
        );
      }
    }
  } else {
    if (isArray(query)) {
      for (
        i = 0,
        length = query.length; i < length; i++
      ) {
        value = query[i];
        appendTo(dict, value[0], value[1]);
      }
    } else if (query.forEach) {
      query.forEach(addEach, dict);
    } else {
      for (key in query) {
         appendTo(dict, key, query[key]);
      }
    }
  }
}

var
  isArray = Array.isArray,
  URLSearchParamsProto = URLSearchParams.prototype,
  find = /[!'\(\)~]|%20|%00/g,
  plus = /\+/g,
  replace = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  },
  replacer = function (match) {
    return replace[match];
  },
  secret = '__URLSearchParams__:' + Math.random()
;

function addEach(value, key) {
  /* jshint validthis:true */
  appendTo(this, key, value);
}

function appendTo(dict, name, value) {
  var res = isArray(value) ? value.join(',') : value;
  if (name in dict)
    dict[name].push(res);
  else
    dict[name] = [res];
}

function decode(str) {
  return decodeURIComponent(str.replace(plus, ' '));
}

function encode(str) {
  return encodeURIComponent(str).replace(find, replacer);
}

URLSearchParamsProto.append = function append(name, value) {
  appendTo(this[secret], name, value);
};

URLSearchParamsProto.delete = function del(name) {
  delete this[secret][name];
};

URLSearchParamsProto.get = function get(name) {
  var dict = this[secret];
  return name in dict ? dict[name][0] : null;
};

URLSearchParamsProto.getAll = function getAll(name) {
  var dict = this[secret];
  return name in dict ? dict[name].slice(0) : [];
};

URLSearchParamsProto.has = function has(name) {
  return name in this[secret];
};

URLSearchParamsProto.set = function set(name, value) {
  this[secret][name] = ['' + value];
};

URLSearchParamsProto.forEach = function forEach(callback, thisArg) {
  var dict = this[secret];
  Object.getOwnPropertyNames(dict).forEach(function(name) {
    dict[name].forEach(function(value) {
      callback.call(thisArg, value, name, this);
    }, this);
  }, this);
};

/*
URLSearchParamsProto.toBody = function() {
  return new Blob(
    [this.toString()],
    {type: 'application/x-www-form-urlencoded'}
  );
};
*/

URLSearchParamsProto.toJSON = function toJSON() {
  return {};
};

URLSearchParamsProto.toString = function toString() {
  var dict = this[secret], query = [], i, key, name, value;
  for (key in dict) {
    name = encode(key);
    for (
      i = 0,
      value = dict[key];
      i < value.length; i++
    ) {
      query.push(name + '=' + encode(value[i]));
    }
  }
  return query.join('&');
};

URLSearchParams = (module.exports = __webpack_require__.g.URLSearchParams || URLSearchParams);

(function (URLSearchParamsProto) {

  var iterable = (function () {
    try {
      return !!Symbol.iterator;
    } catch(error) {
      return false;
    }
  }());

  // mostly related to issue #24
  if (!('forEach' in URLSearchParamsProto)) {
    URLSearchParamsProto.forEach = function forEach(callback, thisArg) {
      var names = Object.create(null);
      this.toString()
          .replace(/=[\s\S]*?(?:&|$)/g, '=')
          .split('=')
          .forEach(function (name) {
            if (!name.length || name in names) return;
            (names[name] = this.getAll(name)).forEach(function(value) {
              callback.call(thisArg, value, name, this);
            }, this);
          }, this);
    };
  }

  if (!('keys' in URLSearchParamsProto)) {
    URLSearchParamsProto.keys = function keys() {
      var items = [];
      this.forEach(function(value, name) { items.push(name); });
      var iterator = {
        next: function() {
          var value = items.shift();
          return {done: value === undefined, value: value};
        }
      };

      if (iterable) {
        iterator[Symbol.iterator] = function() {
          return iterator;
        };
      }

      return iterator;
    };
  }

  if (!('values' in URLSearchParamsProto)) {
    URLSearchParamsProto.values = function values() {
      var items = [];
      this.forEach(function(value) { items.push(value); });
      var iterator = {
        next: function() {
          var value = items.shift();
          return {done: value === undefined, value: value};
        }
      };

      if (iterable) {
        iterator[Symbol.iterator] = function() {
          return iterator;
        };
      }

      return iterator;
    };
  }

  if (!('entries' in URLSearchParamsProto)) {
    URLSearchParamsProto.entries = function entries() {
      var items = [];
      this.forEach(function(value, name) { items.push([name, value]); });
      var iterator = {
        next: function() {
          var value = items.shift();
          return {done: value === undefined, value: value};
        }
      };

      if (iterable) {
        iterator[Symbol.iterator] = function() {
          return iterator;
        };
      }

      return iterator;
    };
  }

  if (iterable && !(Symbol.iterator in URLSearchParamsProto)) {
    URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;
  }

  if (!('sort' in URLSearchParamsProto)) {
    URLSearchParamsProto.sort = function sort() {
      var
        entries = this.entries(),
        entry = entries.next(),
        done = entry.done,
        keys = [],
        values = Object.create(null),
        i, key, value
      ;
      while (!done) {
        value = entry.value;
        key = value[0];
        keys.push(key);
        if (!(key in values)) {
          values[key] = [];
        }
        values[key].push(value[1]);
        entry = entries.next();
        done = entry.done;
      }
      // not the champion in efficiency
      // but these two bits just do the job
      keys.sort();
      for (i = 0; i < keys.length; i++) {
        this.delete(keys[i]);
      }
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        this.append(key, values[key].shift());
      }
    };
  }

}(URLSearchParams.prototype));


/***/ }),

/***/ "./node_modules/lodash-es/_DataView.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_DataView.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");



/* Built-in method references that are verified to be native. */
var DataView = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'DataView');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataView);


/***/ }),

/***/ "./node_modules/lodash-es/_Map.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/_Map.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");



/* Built-in method references that are verified to be native. */
var Map = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'Map');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Map);


/***/ }),

/***/ "./node_modules/lodash-es/_Promise.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_Promise.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");



/* Built-in method references that are verified to be native. */
var Promise = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'Promise');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Promise);


/***/ }),

/***/ "./node_modules/lodash-es/_Set.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/_Set.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");



/* Built-in method references that are verified to be native. */
var Set = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'Set');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Set);


/***/ }),

/***/ "./node_modules/lodash-es/_Symbol.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/_Symbol.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");


/** Built-in value references. */
var Symbol = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Symbol;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Symbol);


/***/ }),

/***/ "./node_modules/lodash-es/_WeakMap.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_WeakMap.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");



/* Built-in method references that are verified to be native. */
var WeakMap = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'WeakMap');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WeakMap);


/***/ }),

/***/ "./node_modules/lodash-es/_baseGetTag.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseGetTag.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");
/* harmony import */ var _getRawTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getRawTag.js */ "./node_modules/lodash-es/_getRawTag.js");
/* harmony import */ var _objectToString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_objectToString.js */ "./node_modules/lodash-es/_objectToString.js");




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? (0,_getRawTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)
    : (0,_objectToString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseGetTag);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIsArguments.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsArguments.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");



/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == argsTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsArguments);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIsNative.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsNative.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/lodash-es/isFunction.js");
/* harmony import */ var _isMasked_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isMasked.js */ "./node_modules/lodash-es/_isMasked.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var _toSource_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_toSource.js */ "./node_modules/lodash-es/_toSource.js");





/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) || (0,_isMasked_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
    return false;
  }
  var pattern = (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) ? reIsNative : reIsHostCtor;
  return pattern.test((0,_toSource_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsNative);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIsTypedArray.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsTypedArray.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _isLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isLength.js */ "./node_modules/lodash-es/isLength.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");




/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) &&
    (0,_isLength_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value.length) && !!typedArrayTags[(0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value)];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsTypedArray);


/***/ }),

/***/ "./node_modules/lodash-es/_baseKeys.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseKeys.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isPrototype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isPrototype.js */ "./node_modules/lodash-es/_isPrototype.js");
/* harmony import */ var _nativeKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_nativeKeys.js */ "./node_modules/lodash-es/_nativeKeys.js");



/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!(0,_isPrototype_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
    return (0,_nativeKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseKeys);


/***/ }),

/***/ "./node_modules/lodash-es/_baseUnary.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseUnary.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseUnary);


/***/ }),

/***/ "./node_modules/lodash-es/_coreJsData.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_coreJsData.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");


/** Used to detect overreaching core-js shims. */
var coreJsData = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"]['__core-js_shared__'];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (coreJsData);


/***/ }),

/***/ "./node_modules/lodash-es/_freeGlobal.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_freeGlobal.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (freeGlobal);


/***/ }),

/***/ "./node_modules/lodash-es/_getNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_getNative.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsNative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIsNative.js */ "./node_modules/lodash-es/_baseIsNative.js");
/* harmony import */ var _getValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getValue.js */ "./node_modules/lodash-es/_getValue.js");



/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = (0,_getValue_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, key);
  return (0,_baseIsNative_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) ? value : undefined;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getNative);


/***/ }),

/***/ "./node_modules/lodash-es/_getPrototype.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_getPrototype.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _overArg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_overArg.js */ "./node_modules/lodash-es/_overArg.js");


/** Built-in value references. */
var getPrototype = (0,_overArg_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object.getPrototypeOf, Object);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getPrototype);


/***/ }),

/***/ "./node_modules/lodash-es/_getRawTag.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_getRawTag.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getRawTag);


/***/ }),

/***/ "./node_modules/lodash-es/_getTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/_getTag.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DataView_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_DataView.js */ "./node_modules/lodash-es/_DataView.js");
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_Map.js */ "./node_modules/lodash-es/_Map.js");
/* harmony import */ var _Promise_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_Promise.js */ "./node_modules/lodash-es/_Promise.js");
/* harmony import */ var _Set_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_Set.js */ "./node_modules/lodash-es/_Set.js");
/* harmony import */ var _WeakMap_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_WeakMap.js */ "./node_modules/lodash-es/_WeakMap.js");
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _toSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_toSource.js */ "./node_modules/lodash-es/_toSource.js");








/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_DataView_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
    mapCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_Map_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
    promiseCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_Promise_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
    setCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_Set_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
    weakMapCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_WeakMap_js__WEBPACK_IMPORTED_MODULE_5__["default"]);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = _baseGetTag_js__WEBPACK_IMPORTED_MODULE_6__["default"];

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((_DataView_js__WEBPACK_IMPORTED_MODULE_1__["default"] && getTag(new _DataView_js__WEBPACK_IMPORTED_MODULE_1__["default"](new ArrayBuffer(1))) != dataViewTag) ||
    (_Map_js__WEBPACK_IMPORTED_MODULE_2__["default"] && getTag(new _Map_js__WEBPACK_IMPORTED_MODULE_2__["default"]) != mapTag) ||
    (_Promise_js__WEBPACK_IMPORTED_MODULE_3__["default"] && getTag(_Promise_js__WEBPACK_IMPORTED_MODULE_3__["default"].resolve()) != promiseTag) ||
    (_Set_js__WEBPACK_IMPORTED_MODULE_4__["default"] && getTag(new _Set_js__WEBPACK_IMPORTED_MODULE_4__["default"]) != setTag) ||
    (_WeakMap_js__WEBPACK_IMPORTED_MODULE_5__["default"] && getTag(new _WeakMap_js__WEBPACK_IMPORTED_MODULE_5__["default"]) != weakMapTag)) {
  getTag = function(value) {
    var result = (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_6__["default"])(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getTag);


/***/ }),

/***/ "./node_modules/lodash-es/_getValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_getValue.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getValue);


/***/ }),

/***/ "./node_modules/lodash-es/_isMasked.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_isMasked.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _coreJsData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_coreJsData.js */ "./node_modules/lodash-es/_coreJsData.js");


/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData_js__WEBPACK_IMPORTED_MODULE_0__["default"] && _coreJsData_js__WEBPACK_IMPORTED_MODULE_0__["default"].keys && _coreJsData_js__WEBPACK_IMPORTED_MODULE_0__["default"].keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isMasked);


/***/ }),

/***/ "./node_modules/lodash-es/_isPrototype.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_isPrototype.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isPrototype);


/***/ }),

/***/ "./node_modules/lodash-es/_nativeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_nativeKeys.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _overArg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_overArg.js */ "./node_modules/lodash-es/_overArg.js");


/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = (0,_overArg_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object.keys, Object);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nativeKeys);


/***/ }),

/***/ "./node_modules/lodash-es/_nodeUtil.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_nodeUtil.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_freeGlobal.js */ "./node_modules/lodash-es/_freeGlobal.js");


/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__["default"].process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nodeUtil);


/***/ }),

/***/ "./node_modules/lodash-es/_objectToString.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_objectToString.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (objectToString);


/***/ }),

/***/ "./node_modules/lodash-es/_overArg.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_overArg.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (overArg);


/***/ }),

/***/ "./node_modules/lodash-es/_root.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/_root.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_freeGlobal.js */ "./node_modules/lodash-es/_freeGlobal.js");


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__["default"] || freeSelf || Function('return this')();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (root);


/***/ }),

/***/ "./node_modules/lodash-es/_toSource.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_toSource.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toSource);


/***/ }),

/***/ "./node_modules/lodash-es/isArguments.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/isArguments.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIsArguments.js */ "./node_modules/lodash-es/_baseIsArguments.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");



/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = (0,_baseIsArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function() { return arguments; }()) ? _baseIsArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"] : function(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArguments);


/***/ }),

/***/ "./node_modules/lodash-es/isArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/isArray.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArray);


/***/ }),

/***/ "./node_modules/lodash-es/isArrayLike.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/isArrayLike.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/lodash-es/isFunction.js");
/* harmony import */ var _isLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isLength.js */ "./node_modules/lodash-es/isLength.js");



/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && (0,_isLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.length) && !(0,_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArrayLike);


/***/ }),

/***/ "./node_modules/lodash-es/isBuffer.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isBuffer.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");
/* harmony import */ var _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stubFalse.js */ "./node_modules/lodash-es/stubFalse.js");



/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isBuffer);


/***/ }),

/***/ "./node_modules/lodash-es/isEmpty.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/isEmpty.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseKeys_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_baseKeys.js */ "./node_modules/lodash-es/_baseKeys.js");
/* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_getTag.js */ "./node_modules/lodash-es/_getTag.js");
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/lodash-es/isArguments.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js");
/* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isBuffer.js */ "./node_modules/lodash-es/isBuffer.js");
/* harmony import */ var _isPrototype_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_isPrototype.js */ "./node_modules/lodash-es/_isPrototype.js");
/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isTypedArray.js */ "./node_modules/lodash-es/isTypedArray.js");









/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if ((0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) &&
      ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        (0,_isBuffer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) || (0,_isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value) || (0,_isArguments_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value))) {
    return !value.length;
  }
  var tag = (0,_getTag_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if ((0,_isPrototype_js__WEBPACK_IMPORTED_MODULE_6__["default"])(value)) {
    return !(0,_baseKeys_js__WEBPACK_IMPORTED_MODULE_7__["default"])(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isEmpty);


/***/ }),

/***/ "./node_modules/lodash-es/isFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/isFunction.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");



/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isFunction);


/***/ }),

/***/ "./node_modules/lodash-es/isLength.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isLength.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isLength);


/***/ }),

/***/ "./node_modules/lodash-es/isObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isObject.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isObject);


/***/ }),

/***/ "./node_modules/lodash-es/isObjectLike.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/isObjectLike.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isObjectLike);


/***/ }),

/***/ "./node_modules/lodash-es/isPlainObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/isPlainObject.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _getPrototype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getPrototype.js */ "./node_modules/lodash-es/_getPrototype.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");




/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!(0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) || (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) != objectTag) {
    return false;
  }
  var proto = (0,_getPrototype_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isPlainObject);


/***/ }),

/***/ "./node_modules/lodash-es/isTypedArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/isTypedArray.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsTypedArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIsTypedArray.js */ "./node_modules/lodash-es/_baseIsTypedArray.js");
/* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseUnary.js */ "./node_modules/lodash-es/_baseUnary.js");
/* harmony import */ var _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nodeUtil.js */ "./node_modules/lodash-es/_nodeUtil.js");




/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"] && _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"].isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? (0,_baseUnary_js__WEBPACK_IMPORTED_MODULE_1__["default"])(nodeIsTypedArray) : _baseIsTypedArray_js__WEBPACK_IMPORTED_MODULE_2__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isTypedArray);


/***/ }),

/***/ "./node_modules/lodash-es/stubFalse.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/stubFalse.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stubFalse);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*********************************!*\
  !*** ./javascript/sdk/index.ts ***!
  \*********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   init: () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! redux */ "./node_modules/redux/es/index.js");
/* harmony import */ var redux_saga__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! redux-saga */ "./node_modules/redux-saga/es/index.js");
/* harmony import */ var app_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/config */ "./javascript/app/config.ts");
/* harmony import */ var _IFrameWrapper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./IFrameWrapper */ "./javascript/sdk/IFrameWrapper.ts");
/* harmony import */ var _MessageListener__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MessageListener */ "./javascript/sdk/MessageListener.ts");
/* harmony import */ var _MessageListener_mappers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MessageListener.mappers */ "./javascript/sdk/MessageListener.mappers.ts");
/* harmony import */ var _PartooSDK__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PartooSDK */ "./javascript/sdk/PartooSDK.ts");
/* harmony import */ var _PartooSDK_mappers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PartooSDK.mappers */ "./javascript/sdk/PartooSDK.mappers.ts");
/* harmony import */ var _reducers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./reducers */ "./javascript/sdk/reducers/index.ts");
/* harmony import */ var _reducers_page__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./reducers/page */ "./javascript/sdk/reducers/page.ts");
/* harmony import */ var _redux_sdk__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./redux-sdk */ "./javascript/sdk/redux-sdk.ts");
/* harmony import */ var _sagas_handleMessageFromAppSagas__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./sagas/handleMessageFromAppSagas */ "./javascript/sdk/sagas/handleMessageFromAppSagas.ts");
/* harmony import */ var _sagas_navigateSagas__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./sagas/navigateSagas */ "./javascript/sdk/sagas/navigateSagas.ts");
/* harmony import */ var _sagas_sendMessageToAppSagas__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./sagas/sendMessageToAppSagas */ "./javascript/sdk/sagas/sendMessageToAppSagas.ts");















/**
 * Create a container object containing all the services used by Partoo SDK:
 *   - `iFrameWrapper`: service handling HTML elements
 *   - `messageListener`: service listening to JS message from Partoo App to dispatch redux action
 *   - `store`: Redux store managing SDK state
 *   - `sdk`: Partoo SDK used by developers to integrate Partoo App in 3rd party websites
 *
 * @param elementId {string}
 * @param store {Store<SDKState>}
 * @returns {{
 *      iframeWrapper: IFrameWrapper,
 *      messageListener: MessageListener,
 *      sdk: PartooSDK,
 *      store: Store<SDKState>
 * }}
 */
const makeContainer = (elementId, store) => {
  const messageListener = new _MessageListener__WEBPACK_IMPORTED_MODULE_5__["default"]();
  return {
    sdk: new _PartooSDK__WEBPACK_IMPORTED_MODULE_7__["default"](messageListener, elementId),
    messageListener,
    iframeWrapper: _IFrameWrapper__WEBPACK_IMPORTED_MODULE_4__["default"],
    store
  };
};
let container;

/**
 * Initialize SDK:
 *    - create Redux store
 *    - instantiate services
 *    - insert HTML elements
 *    - connect Redux store to services
 *
 * @param elementId {string} Id of the div inside which we are going to insert the HTML elements
 * @param options {Options} Display options
 */
const initializeSDK = (elementId, options) => {
  // Create Store & dispatch first action
  const sagaMiddleware = (0,redux_saga__WEBPACK_IMPORTED_MODULE_2__["default"])();
  const middlewares = [sagaMiddleware].filter(Boolean);
  let composeEnhancer = redux__WEBPACK_IMPORTED_MODULE_1__.compose;
  if (true) {
    /* eslint-disable no-underscore-dangle */
    composeEnhancer = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : redux__WEBPACK_IMPORTED_MODULE_1__.compose; // eslint-enable
  }
  const store = (0,redux__WEBPACK_IMPORTED_MODULE_1__.createStore)(_reducers__WEBPACK_IMPORTED_MODULE_9__["default"], composeEnhancer((0,redux__WEBPACK_IMPORTED_MODULE_1__.applyMiddleware)(...middlewares)));
  store.dispatch((0,_reducers_page__WEBPACK_IMPORTED_MODULE_10__.updateOptions)(options));
  sagaMiddleware.run(_sagas_handleMessageFromAppSagas__WEBPACK_IMPORTED_MODULE_12__["default"]);
  sagaMiddleware.run(_sagas_sendMessageToAppSagas__WEBPACK_IMPORTED_MODULE_14__["default"]);
  sagaMiddleware.run(_sagas_navigateSagas__WEBPACK_IMPORTED_MODULE_13__["default"]);

  // Insert iFrame
  _IFrameWrapper__WEBPACK_IMPORTED_MODULE_4__["default"].insert(elementId);
  container = makeContainer(elementId, store);

  // Connect instances to store
  (0,_redux_sdk__WEBPACK_IMPORTED_MODULE_11__.connect)(store, container.messageListener, ..._MessageListener_mappers__WEBPACK_IMPORTED_MODULE_6__["default"]);
  // @ts-ignore
  (0,_redux_sdk__WEBPACK_IMPORTED_MODULE_11__.connect)(store, container.sdk, ..._PartooSDK_mappers__WEBPACK_IMPORTED_MODULE_8__["default"]);
};

/**
 * Initialize and returns Partoo SDK. If `debugOn`, it returns the entire container instead.
 *
 * @param elementId {string} Id of the div inside which we are going to insert the HTML elements
 * @param options {Options} Display options
 * @param debugOn {boolean} If set to true, will return the container instead of the sdk instance.
 *                          By default, this param is set to `false` and it works only in dev mode.
 * @returns {PartooSDK|PartooSDKContainer}
 */
const init = (elementId, options, debugOn = false) => {
  initializeSDK(elementId, options);

  // we want debugOn to work only in dev mode
  if (app_config__WEBPACK_IMPORTED_MODULE_3__.DEBUG && debugOn) {
    return container;
  }
  return container.sdk;
};

/**
 * Destroy Partoo SDK
 *
 * @param callback {null|Function} Callback triggered once destroy is complete
 */
const destroy = (callback = null) => {
  const destroyCallback = () => {
    if (callback) {
      callback();
    }

    // @ts-ignore
    delete container.sdk;
    // @ts-ignore
    delete container.messageListener;
    // @ts-ignore
    delete container.store;
  };
  if (container.sdk !== null) {
    container.sdk.destroy(destroyCallback);
  }
};
})();

Partoo = __webpack_exports__;
/******/ })()
;